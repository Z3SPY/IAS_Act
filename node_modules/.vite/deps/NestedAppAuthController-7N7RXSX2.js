import {
  BridgeStatusCode,
  init_BridgeStatusCode
} from "./chunk-NI6AEUBZ.js";
import {
  AuthError,
  AuthToken_exports,
  AuthenticationScheme,
  ClientAuthError,
  ClientAuthErrorCodes_exports,
  CryptoOps,
  DEFAULT_CRYPTO_IMPLEMENTATION,
  DEFAULT_REQUEST,
  EventHandler,
  EventType,
  InteractionRequiredAuthError,
  InteractionType,
  OIDC_DEFAULT_SCOPES,
  PerformanceEvents,
  RequestParameterBuilder,
  ServerError,
  StringUtils,
  TimeUtils_exports,
  createClientAuthError,
  init_BrowserConstants,
  init_CryptoOps,
  init_EventHandler,
  init_EventType,
  init_dist
} from "./chunk-Y5QGPPC6.js";
import {
  __esm,
  init_buffer,
  init_process
} from "./chunk-IEY7EE4H.js";

// node_modules/@azure/msal-browser/dist/naa/BridgeError.mjs
function isBridgeError(error) {
  return error.status !== void 0;
}
var init_BridgeError = __esm({
  "node_modules/@azure/msal-browser/dist/naa/BridgeError.mjs"() {
    "use strict";
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/msal-browser/dist/naa/mapping/NestedAppAuthAdapter.mjs
var NestedAppAuthAdapter;
var init_NestedAppAuthAdapter = __esm({
  "node_modules/@azure/msal-browser/dist/naa/mapping/NestedAppAuthAdapter.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_dist();
    init_BridgeError();
    init_BridgeStatusCode();
    NestedAppAuthAdapter = class {
      constructor(clientId, clientCapabilities, crypto, logger) {
        this.clientId = clientId;
        this.clientCapabilities = clientCapabilities;
        this.crypto = crypto;
        this.logger = logger;
      }
      toNaaTokenRequest(request) {
        var _a;
        let extraParams;
        if (request.extraQueryParameters === void 0) {
          extraParams = /* @__PURE__ */ new Map();
        } else {
          extraParams = new Map(Object.entries(request.extraQueryParameters));
        }
        const requestBuilder = new RequestParameterBuilder();
        const claims = requestBuilder.addClientCapabilitiesToClaims(request.claims, this.clientCapabilities);
        const scopes = request.scopes || OIDC_DEFAULT_SCOPES;
        const tokenRequest = {
          platformBrokerId: (_a = request.account) == null ? void 0 : _a.homeAccountId,
          clientId: this.clientId,
          authority: request.authority,
          scope: scopes.join(" "),
          correlationId: request.correlationId !== void 0 ? request.correlationId : this.crypto.createNewGuid(),
          claims: !StringUtils.isEmptyObj(claims) ? claims : void 0,
          state: request.state,
          authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
          extraParameters: extraParams
        };
        return tokenRequest;
      }
      fromNaaTokenResponse(request, response, reqTimestamp) {
        if (!response.token.id_token || !response.token.access_token) {
          throw createClientAuthError(ClientAuthErrorCodes_exports.nullOrEmptyToken);
        }
        const expiresOn = new Date((reqTimestamp + (response.token.expires_in || 0)) * 1e3);
        const idTokenClaims = AuthToken_exports.extractTokenClaims(response.token.id_token, this.crypto.base64Decode);
        const account = this.fromNaaAccountInfo(response.account, idTokenClaims);
        const scopes = response.token.scope || request.scope;
        const authenticationResult = {
          authority: response.token.authority || account.environment,
          uniqueId: account.localAccountId,
          tenantId: account.tenantId,
          scopes: scopes.split(" "),
          account,
          idToken: response.token.id_token,
          idTokenClaims,
          accessToken: response.token.access_token,
          fromCache: true,
          expiresOn,
          tokenType: request.authenticationScheme || AuthenticationScheme.BEARER,
          correlationId: request.correlationId,
          extExpiresOn: expiresOn,
          state: request.state
        };
        return authenticationResult;
      }
      /*
       *  export type AccountInfo = {
       *     homeAccountId: string;
       *     environment: string;
       *     tenantId: string;
       *     username: string;
       *     localAccountId: string;
       *     name?: string;
       *     idToken?: string;
       *     idTokenClaims?: TokenClaims & {
       *         [key: string]:
       *             | string
       *             | number
       *             | string[]
       *             | object
       *             | undefined
       *             | unknown;
       *     };
       *     nativeAccountId?: string;
       *     authorityType?: string;
       * };
       */
      fromNaaAccountInfo(fromAccount, idTokenClaims) {
        const effectiveIdTokenClaims = idTokenClaims || fromAccount.idTokenClaims;
        const localAccountId = fromAccount.localAccountId || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.oid) || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.sub) || "";
        const tenantId = fromAccount.tenantId || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.tid) || "";
        const homeAccountId = fromAccount.homeAccountId || `${localAccountId}.${tenantId}`;
        const username = fromAccount.username || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.preferred_username) || "";
        const name = fromAccount.name || (effectiveIdTokenClaims == null ? void 0 : effectiveIdTokenClaims.name);
        const account = {
          homeAccountId,
          environment: fromAccount.environment,
          tenantId,
          username,
          localAccountId,
          name,
          idToken: fromAccount.idToken,
          idTokenClaims: effectiveIdTokenClaims
        };
        return account;
      }
      /**
       *
       * @param error BridgeError
       * @returns AuthError, ClientAuthError, ClientConfigurationError, ServerError, InteractionRequiredError
       */
      fromBridgeError(error) {
        if (isBridgeError(error)) {
          switch (error.status) {
            case BridgeStatusCode.UserCancel:
              return new ClientAuthError(ClientAuthErrorCodes_exports.userCanceled);
            case BridgeStatusCode.NoNetwork:
              return new ClientAuthError(ClientAuthErrorCodes_exports.noNetworkConnectivity);
            case BridgeStatusCode.AccountUnavailable:
              return new ClientAuthError(ClientAuthErrorCodes_exports.noAccountFound);
            case BridgeStatusCode.Disabled:
              return new ClientAuthError(ClientAuthErrorCodes_exports.nestedAppAuthBridgeDisabled);
            case BridgeStatusCode.NestedAppAuthUnavailable:
              return new ClientAuthError(error.code || ClientAuthErrorCodes_exports.nestedAppAuthBridgeDisabled, error.description);
            case BridgeStatusCode.TransientError:
            case BridgeStatusCode.PersistentError:
              return new ServerError(error.code, error.description);
            case BridgeStatusCode.UserInteractionRequired:
              return new InteractionRequiredAuthError(error.code, error.description);
            default:
              return new AuthError(error.code, error.description);
          }
        } else {
          return new AuthError("unknown_error", "An unknown error occurred");
        }
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/error/NestedAppAuthError.mjs
var NestedAppAuthErrorMessage, NestedAppAuthError;
var init_NestedAppAuthError = __esm({
  "node_modules/@azure/msal-browser/dist/error/NestedAppAuthError.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_dist();
    NestedAppAuthErrorMessage = {
      unsupportedMethod: {
        code: "unsupported_method",
        desc: "The PKCE code challenge and verifier could not be generated."
      }
    };
    NestedAppAuthError = class _NestedAppAuthError extends AuthError {
      constructor(errorCode, errorMessage) {
        super(errorCode, errorMessage);
        Object.setPrototypeOf(this, _NestedAppAuthError.prototype);
        this.name = "NestedAppAuthError";
      }
      static createUnsupportedError() {
        return new _NestedAppAuthError(NestedAppAuthErrorMessage.unsupportedMethod.code, NestedAppAuthErrorMessage.unsupportedMethod.desc);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/controllers/NestedAppAuthController.mjs
var NestedAppAuthController;
var init_NestedAppAuthController = __esm({
  "node_modules/@azure/msal-browser/dist/controllers/NestedAppAuthController.mjs"() {
    init_process();
    init_buffer();
    init_dist();
    init_BrowserConstants();
    init_CryptoOps();
    init_NestedAppAuthAdapter();
    init_NestedAppAuthError();
    init_EventHandler();
    init_EventType();
    NestedAppAuthController = class _NestedAppAuthController {
      constructor(operatingContext) {
        this.operatingContext = operatingContext;
        const proxy = this.operatingContext.getBridgeProxy();
        if (proxy !== void 0) {
          this.bridgeProxy = proxy;
        } else {
          throw new Error("unexpected: bridgeProxy is undefined");
        }
        this.config = operatingContext.getConfig();
        this.logger = this.operatingContext.getLogger();
        this.performanceClient = this.config.telemetry.client;
        this.browserCrypto = operatingContext.isBrowserEnvironment() ? new CryptoOps(this.logger, this.performanceClient) : DEFAULT_CRYPTO_IMPLEMENTATION;
        this.eventHandler = new EventHandler(this.logger, this.browserCrypto);
        this.nestedAppAuthAdapter = new NestedAppAuthAdapter(this.config.auth.clientId, this.config.auth.clientCapabilities, this.browserCrypto, this.logger);
      }
      getBrowserStorage() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      getEventHandler() {
        return this.eventHandler;
      }
      static async createController(operatingContext) {
        const controller = new _NestedAppAuthController(operatingContext);
        return Promise.resolve(controller);
      }
      initialize() {
        return Promise.resolve();
      }
      ensureValidRequest(request) {
        if (request == null ? void 0 : request.correlationId) {
          return request;
        }
        return {
          ...request,
          correlationId: this.browserCrypto.createNewGuid()
        };
      }
      async acquireTokenInteractive(request) {
        const validRequest = this.ensureValidRequest(request);
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, validRequest);
        const atPopupMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.AcquireTokenPopup, validRequest.correlationId);
        atPopupMeasurement == null ? void 0 : atPopupMeasurement.add({ nestedAppAuthRequest: true });
        try {
          const naaRequest = this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);
          const reqTimestamp = TimeUtils_exports.nowSeconds();
          const response = await this.bridgeProxy.getTokenInteractive(naaRequest);
          const result = this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response, reqTimestamp);
          this.operatingContext.setActiveAccount(result.account);
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);
          atPopupMeasurement.add({
            accessTokenSize: result.accessToken.length,
            idTokenSize: result.idToken.length
          });
          atPopupMeasurement.end({
            success: true,
            requestId: result.requestId
          });
          return result;
        } catch (e) {
          const error = this.nestedAppAuthAdapter.fromBridgeError(e);
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);
          atPopupMeasurement.end({
            success: false
          }, e);
          throw error;
        }
      }
      async acquireTokenSilentInternal(request) {
        const validRequest = this.ensureValidRequest(request);
        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Silent, validRequest);
        const ssoSilentMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.SsoSilent, validRequest.correlationId);
        ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.increment({
          visibilityChangeCount: 0
        });
        ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.add({
          nestedAppAuthRequest: true
        });
        try {
          const naaRequest = this.nestedAppAuthAdapter.toNaaTokenRequest(validRequest);
          const reqTimestamp = TimeUtils_exports.nowSeconds();
          const response = await this.bridgeProxy.getTokenSilent(naaRequest);
          const result = this.nestedAppAuthAdapter.fromNaaTokenResponse(naaRequest, response, reqTimestamp);
          this.operatingContext.setActiveAccount(result.account);
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Silent, result);
          ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.add({
            accessTokenSize: result.accessToken.length,
            idTokenSize: result.idToken.length
          });
          ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.end({
            success: true,
            requestId: result.requestId
          });
          return result;
        } catch (e) {
          const error = this.nestedAppAuthAdapter.fromBridgeError(e);
          this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Silent, null, e);
          ssoSilentMeasurement == null ? void 0 : ssoSilentMeasurement.end({
            success: false
          }, e);
          throw error;
        }
      }
      async acquireTokenPopup(request) {
        return this.acquireTokenInteractive(request);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      acquireTokenRedirect(request) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      async acquireTokenSilent(silentRequest) {
        return this.acquireTokenSilentInternal(silentRequest);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      acquireTokenByCode(request) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      acquireTokenNative(request, apiId, accountId) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      acquireTokenByRefreshToken(commonRequest, silentRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      /**
       * Adds event callbacks to array
       * @param callback
       */
      addEventCallback(callback) {
        return this.eventHandler.addEventCallback(callback);
      }
      /**
       * Removes callback with provided id from callback array
       * @param callbackId
       */
      removeEventCallback(callbackId) {
        this.eventHandler.removeEventCallback(callbackId);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      addPerformanceCallback(callback) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      removePerformanceCallback(callbackId) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      enableAccountStorageEvents() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      disableAccountStorageEvents() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getAccount(accountFilter) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      getAccountByHomeId(homeAccountId) {
        const currentAccount = this.operatingContext.getActiveAccount();
        if (currentAccount !== void 0) {
          if (currentAccount.homeAccountId === homeAccountId) {
            return this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount);
          } else {
            return null;
          }
        } else {
          return null;
        }
      }
      getAccountByLocalId(localId) {
        const currentAccount = this.operatingContext.getActiveAccount();
        if (currentAccount !== void 0) {
          if (currentAccount.localAccountId === localId) {
            return this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount);
          } else {
            return null;
          }
        } else {
          return null;
        }
      }
      getAccountByUsername(userName) {
        const currentAccount = this.operatingContext.getActiveAccount();
        if (currentAccount !== void 0) {
          if (currentAccount.username === userName) {
            return this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount);
          } else {
            return null;
          }
        } else {
          return null;
        }
      }
      getAllAccounts() {
        const currentAccount = this.operatingContext.getActiveAccount();
        if (currentAccount !== void 0) {
          return [
            this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount)
          ];
        } else {
          return [];
        }
      }
      handleRedirectPromise(hash) {
        return Promise.resolve(null);
      }
      loginPopup(request) {
        return this.acquireTokenInteractive(request || DEFAULT_REQUEST);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      loginRedirect(request) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      logout(logoutRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      logoutRedirect(logoutRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      logoutPopup(logoutRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      ssoSilent(request) {
        return this.acquireTokenSilentInternal(request);
      }
      getTokenCache() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.logger;
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger Logger instance
       */
      setLogger(logger) {
        this.logger = logger;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setActiveAccount(account) {
        this.logger.warning("nestedAppAuth does not support setActiveAccount");
        return;
      }
      getActiveAccount() {
        const currentAccount = this.operatingContext.getActiveAccount();
        if (currentAccount !== void 0) {
          return this.nestedAppAuthAdapter.fromNaaAccountInfo(currentAccount);
        } else {
          return null;
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      initializeWrapperLibrary(sku, version) {
        return;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setNavigationClient(navigationClient) {
        this.logger.warning("setNavigationClient is not supported in nested app auth");
      }
      getConfiguration() {
        return this.config;
      }
      isBrowserEnv() {
        return this.operatingContext.isBrowserEnvironment();
      }
      getBrowserCrypto() {
        return this.browserCrypto;
      }
      getPerformanceClient() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      getRedirectResponse() {
        throw NestedAppAuthError.createUnsupportedError();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async clearCache(logoutRequest) {
        throw NestedAppAuthError.createUnsupportedError();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async hydrateCache(result, request) {
        throw NestedAppAuthError.createUnsupportedError();
      }
    };
  }
});
init_NestedAppAuthController();
export {
  NestedAppAuthController
};
/*! Bundled license information:

@azure/msal-browser/dist/naa/BridgeError.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/naa/mapping/NestedAppAuthAdapter.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/error/NestedAppAuthError.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/controllers/NestedAppAuthController.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)
*/
//# sourceMappingURL=NestedAppAuthController-7N7RXSX2.js.map
