import {
  require_browser
} from "./chunk-7O6QKU2S.js";
import {
  require_buffer
} from "./chunk-TKINYOQN.js";
import {
  StandardController,
  buildConfiguration,
  init_BrowserCacheManager,
  init_BrowserConfigurationAuthError,
  init_BrowserConfigurationAuthErrorCodes,
  init_BrowserStorage,
  init_BrowserUtils,
  init_Configuration,
  init_NavigationClient,
  init_StandardController,
  init_packageMetadata,
  name,
  version
} from "./chunk-E6NUHKWC.js";
import {
  BridgeStatusCode,
  init_BridgeStatusCode
} from "./chunk-NI6AEUBZ.js";
import {
  BrowserCacheLocation,
  LOG_LEVEL_CACHE_KEY,
  LOG_PII_CACHE_KEY,
  LogLevel,
  Logger,
  createNewGuid,
  init_BrowserAuthError,
  init_BrowserAuthErrorCodes,
  init_BrowserConstants,
  init_BrowserCrypto,
  init_CryptoOps,
  init_EventHandler,
  init_EventType,
  init_MemoryStorage,
  init_dist
} from "./chunk-Y5QGPPC6.js";
import {
  init_BrowserPerformanceMeasurement
} from "./chunk-26TEOASW.js";
import {
  Buffer,
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  init_buffer,
  init_process,
  process
} from "./chunk-IEY7EE4H.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state3 = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state3);
      wrapped.listener = listener;
      state3.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name2) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name2, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
        if (name2 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name2, listener);
        } else {
          emitter.on(name2, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name2, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name2, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js
var require_writable_tracking_buffer = __commonJS({
  "node_modules/tedious/lib/tracking-buffer/writable-tracking-buffer.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var ZERO_LENGTH_BUFFER = Buffer.alloc(0);
    var WritableTrackingBuffer = class {
      constructor(initialSize, encoding, doubleSizeGrowth) {
        this.initialSize = initialSize;
        this.encoding = encoding || "ucs2";
        this.doubleSizeGrowth = doubleSizeGrowth || false;
        this.buffer = Buffer.alloc(this.initialSize, 0);
        this.compositeBuffer = ZERO_LENGTH_BUFFER;
        this.position = 0;
      }
      get data() {
        this.newBuffer(0);
        return this.compositeBuffer;
      }
      copyFrom(buffer) {
        const length = buffer.length;
        this.makeRoomFor(length);
        buffer.copy(this.buffer, this.position);
        this.position += length;
      }
      makeRoomFor(requiredLength) {
        if (this.buffer.length - this.position < requiredLength) {
          if (this.doubleSizeGrowth) {
            let size = Math.max(128, this.buffer.length * 2);
            while (size < requiredLength) {
              size *= 2;
            }
            this.newBuffer(size);
          } else {
            this.newBuffer(requiredLength);
          }
        }
      }
      newBuffer(size) {
        const buffer = this.buffer.slice(0, this.position);
        this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);
        this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);
        this.position = 0;
      }
      writeUInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeUInt8(value, this.position);
        this.position += length;
      }
      writeUInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16LE(value, this.position);
        this.position += length;
      }
      writeUShort(value) {
        this.writeUInt16LE(value);
      }
      writeUInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeUInt16BE(value, this.position);
        this.position += length;
      }
      writeUInt24LE(value) {
        const length = 3;
        this.makeRoomFor(length);
        this.buffer[this.position + 2] = value >>> 16 & 255;
        this.buffer[this.position + 1] = value >>> 8 & 255;
        this.buffer[this.position] = value & 255;
        this.position += length;
      }
      writeUInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32LE(value, this.position);
        this.position += length;
      }
      writeBigInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigInt64LE(value, this.position);
        this.position += length;
      }
      writeInt64LE(value) {
        this.writeBigInt64LE(BigInt(value));
      }
      writeUInt64LE(value) {
        this.writeBigUInt64LE(BigInt(value));
      }
      writeBigUInt64LE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeBigUInt64LE(value, this.position);
        this.position += length;
      }
      writeUInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeUInt32BE(value, this.position);
        this.position += length;
      }
      writeUInt40LE(value) {
        this.writeInt32LE(value & -1);
        this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));
      }
      writeInt8(value) {
        const length = 1;
        this.makeRoomFor(length);
        this.buffer.writeInt8(value, this.position);
        this.position += length;
      }
      writeInt16LE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16LE(value, this.position);
        this.position += length;
      }
      writeInt16BE(value) {
        const length = 2;
        this.makeRoomFor(length);
        this.buffer.writeInt16BE(value, this.position);
        this.position += length;
      }
      writeInt32LE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32LE(value, this.position);
        this.position += length;
      }
      writeInt32BE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeInt32BE(value, this.position);
        this.position += length;
      }
      writeFloatLE(value) {
        const length = 4;
        this.makeRoomFor(length);
        this.buffer.writeFloatLE(value, this.position);
        this.position += length;
      }
      writeDoubleLE(value) {
        const length = 8;
        this.makeRoomFor(length);
        this.buffer.writeDoubleLE(value, this.position);
        this.position += length;
      }
      writeString(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        const length = Buffer.byteLength(value, encoding);
        this.makeRoomFor(length);
        this.buffer.write(value, this.position, encoding);
        this.position += length;
      }
      writeBVarchar(value, encoding) {
        this.writeUInt8(value.length);
        this.writeString(value, encoding);
      }
      writeUsVarchar(value, encoding) {
        this.writeUInt16LE(value.length);
        this.writeString(value, encoding);
      }
      // TODO: Figure out what types are passed in other than `Buffer`
      writeUsVarbyte(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeUInt16LE(length);
        if (value instanceof Buffer) {
          this.writeBuffer(value);
        } else {
          this.makeRoomFor(length);
          this.buffer.write(value, this.position, encoding);
          this.position += length;
        }
      }
      writePLPBody(value, encoding) {
        if (encoding == null) {
          encoding = this.encoding;
        }
        let length;
        if (value instanceof Buffer) {
          length = value.length;
        } else {
          value = value.toString();
          length = Buffer.byteLength(value, encoding);
        }
        this.writeBuffer(UNKNOWN_PLP_LEN);
        if (length > 0) {
          this.writeUInt32LE(length);
          if (value instanceof Buffer) {
            this.writeBuffer(value);
          } else {
            this.makeRoomFor(length);
            this.buffer.write(value, this.position, encoding);
            this.position += length;
          }
        }
        this.writeUInt32LE(0);
      }
      writeBuffer(value) {
        const length = value.length;
        this.makeRoomFor(length);
        value.copy(this.buffer, this.position);
        this.position += length;
      }
      writeMoney(value) {
        this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));
        this.writeInt32LE(value & -1);
      }
    };
    var _default = exports.default = WritableTrackingBuffer;
    module.exports = WritableTrackingBuffer;
  }
});

// node_modules/emitter-component/index.js
var require_emitter_component = __commonJS({
  "node_modules/emitter-component/index.js"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Emitter;
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks[event] = this._callbacks[event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      var self2 = this;
      this._callbacks = this._callbacks || {};
      function on() {
        self2.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks[event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks[event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = [].slice.call(arguments, 1), callbacks = this._callbacks[event];
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks[event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/stream/index.js
var require_stream = __commonJS({
  "node_modules/stream/index.js"(exports, module) {
    init_process();
    init_buffer();
    var Emitter = require_emitter_component();
    function Stream() {
      Emitter.call(this);
    }
    Stream.prototype = new Emitter();
    module.exports = Stream;
    Stream.Stream = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (!this.hasListeners("error")) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.off("data", ondata);
        dest.off("drain", ondrain);
        source.off("end", onend);
        source.off("close", onclose);
        source.off("error", onerror);
        dest.off("error", onerror);
        source.off("end", cleanup);
        source.off("close", cleanup);
        dest.off("end", cleanup);
        dest.off("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("end", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node_modules/tedious/lib/token/token.js
var require_token = __commonJS({
  "node_modules/tedious/lib/token/token.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Token = exports.TYPE = exports.SSPIToken = exports.RowToken = exports.RoutingEnvChangeToken = exports.RollbackTransactionEnvChangeToken = exports.ReturnValueToken = exports.ReturnStatusToken = exports.ResetConnectionEnvChangeToken = exports.PacketSizeEnvChangeToken = exports.OrderToken = exports.NBCRowToken = exports.LoginAckToken = exports.LanguageEnvChangeToken = exports.InfoMessageToken = exports.FedAuthInfoToken = exports.FeatureExtAckToken = exports.ErrorMessageToken = exports.DoneToken = exports.DoneProcToken = exports.DoneInProcToken = exports.DatabaseMirroringPartnerEnvChangeToken = exports.DatabaseEnvChangeToken = exports.CommitTransactionEnvChangeToken = exports.CollationChangeToken = exports.ColMetadataToken = exports.CharsetEnvChangeToken = exports.BeginTransactionEnvChangeToken = void 0;
    var TYPE = exports.TYPE = {
      ALTMETADATA: 136,
      ALTROW: 211,
      COLMETADATA: 129,
      COLINFO: 165,
      DONE: 253,
      DONEPROC: 254,
      DONEINPROC: 255,
      ENVCHANGE: 227,
      ERROR: 170,
      FEATUREEXTACK: 174,
      FEDAUTHINFO: 238,
      INFO: 171,
      LOGINACK: 173,
      NBCROW: 210,
      OFFSET: 120,
      ORDER: 169,
      RETURNSTATUS: 121,
      RETURNVALUE: 172,
      ROW: 209,
      SSPI: 237,
      TABNAME: 164
    };
    var Token = class {
      constructor(name2, handlerName) {
        this.name = name2;
        this.handlerName = handlerName;
      }
    };
    exports.Token = Token;
    var ColMetadataToken = class extends Token {
      constructor(columns) {
        super("COLMETADATA", "onColMetadata");
        this.columns = columns;
      }
    };
    exports.ColMetadataToken = ColMetadataToken;
    var DoneToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONE", "onDone");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports.DoneToken = DoneToken;
    var DoneInProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEINPROC", "onDoneInProc");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports.DoneInProcToken = DoneInProcToken;
    var DoneProcToken = class extends Token {
      constructor({
        more,
        sqlError,
        attention,
        serverError,
        rowCount,
        curCmd
      }) {
        super("DONEPROC", "onDoneProc");
        this.more = more;
        this.sqlError = sqlError;
        this.attention = attention;
        this.serverError = serverError;
        this.rowCount = rowCount;
        this.curCmd = curCmd;
      }
    };
    exports.DoneProcToken = DoneProcToken;
    var DatabaseEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseChange");
        this.type = "DATABASE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.DatabaseEnvChangeToken = DatabaseEnvChangeToken;
    var LanguageEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onLanguageChange");
        this.type = "LANGUAGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.LanguageEnvChangeToken = LanguageEnvChangeToken;
    var CharsetEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCharsetChange");
        this.type = "CHARSET";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.CharsetEnvChangeToken = CharsetEnvChangeToken;
    var PacketSizeEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onPacketSizeChange");
        this.type = "PACKET_SIZE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.PacketSizeEnvChangeToken = PacketSizeEnvChangeToken;
    var BeginTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onBeginTransaction");
        this.type = "BEGIN_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.BeginTransactionEnvChangeToken = BeginTransactionEnvChangeToken;
    var CommitTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onCommitTransaction");
        this.type = "COMMIT_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.CommitTransactionEnvChangeToken = CommitTransactionEnvChangeToken;
    var RollbackTransactionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRollbackTransaction");
        this.type = "ROLLBACK_TXN";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.RollbackTransactionEnvChangeToken = RollbackTransactionEnvChangeToken;
    var DatabaseMirroringPartnerEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onDatabaseMirroringPartner");
        this.type = "DATABASE_MIRRORING_PARTNER";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.DatabaseMirroringPartnerEnvChangeToken = DatabaseMirroringPartnerEnvChangeToken;
    var ResetConnectionEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onResetConnection");
        this.type = "RESET_CONNECTION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.ResetConnectionEnvChangeToken = ResetConnectionEnvChangeToken;
    var CollationChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onSqlCollationChange");
        this.type = "SQL_COLLATION";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.CollationChangeToken = CollationChangeToken;
    var RoutingEnvChangeToken = class extends Token {
      constructor(newValue, oldValue) {
        super("ENVCHANGE", "onRoutingChange");
        this.type = "ROUTING_CHANGE";
        this.newValue = newValue;
        this.oldValue = oldValue;
      }
    };
    exports.RoutingEnvChangeToken = RoutingEnvChangeToken;
    var FeatureExtAckToken = class extends Token {
      /** Value of UTF8_SUPPORT acknowledgement.
       *
       * undefined when UTF8_SUPPORT not included in token. */
      constructor(fedAuth, utf8Support) {
        super("FEATUREEXTACK", "onFeatureExtAck");
        this.fedAuth = fedAuth;
        this.utf8Support = utf8Support;
      }
    };
    exports.FeatureExtAckToken = FeatureExtAckToken;
    var FedAuthInfoToken = class extends Token {
      constructor(spn, stsurl) {
        super("FEDAUTHINFO", "onFedAuthInfo");
        this.spn = spn;
        this.stsurl = stsurl;
      }
    };
    exports.FedAuthInfoToken = FedAuthInfoToken;
    var InfoMessageToken = class extends Token {
      constructor({
        number,
        state: state3,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("INFO", "onInfoMessage");
        this.number = number;
        this.state = state3;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports.InfoMessageToken = InfoMessageToken;
    var ErrorMessageToken = class extends Token {
      constructor({
        number,
        state: state3,
        class: clazz,
        message,
        serverName,
        procName,
        lineNumber
      }) {
        super("ERROR", "onErrorMessage");
        this.number = number;
        this.state = state3;
        this.class = clazz;
        this.message = message;
        this.serverName = serverName;
        this.procName = procName;
        this.lineNumber = lineNumber;
      }
    };
    exports.ErrorMessageToken = ErrorMessageToken;
    var LoginAckToken = class extends Token {
      constructor({
        interface: interfaze,
        tdsVersion,
        progName,
        progVersion
      }) {
        super("LOGINACK", "onLoginAck");
        this.interface = interfaze;
        this.tdsVersion = tdsVersion;
        this.progName = progName;
        this.progVersion = progVersion;
      }
    };
    exports.LoginAckToken = LoginAckToken;
    var NBCRowToken = class extends Token {
      constructor(columns) {
        super("NBCROW", "onRow");
        this.columns = columns;
      }
    };
    exports.NBCRowToken = NBCRowToken;
    var OrderToken = class extends Token {
      constructor(orderColumns) {
        super("ORDER", "onOrder");
        this.orderColumns = orderColumns;
      }
    };
    exports.OrderToken = OrderToken;
    var ReturnStatusToken = class extends Token {
      constructor(value) {
        super("RETURNSTATUS", "onReturnStatus");
        this.value = value;
      }
    };
    exports.ReturnStatusToken = ReturnStatusToken;
    var ReturnValueToken = class extends Token {
      constructor({
        paramOrdinal,
        paramName,
        metadata,
        value
      }) {
        super("RETURNVALUE", "onReturnValue");
        this.paramOrdinal = paramOrdinal;
        this.paramName = paramName;
        this.metadata = metadata;
        this.value = value;
      }
    };
    exports.ReturnValueToken = ReturnValueToken;
    var RowToken = class extends Token {
      constructor(columns) {
        super("ROW", "onRow");
        this.columns = columns;
      }
    };
    exports.RowToken = RowToken;
    var SSPIToken = class extends Token {
      constructor(ntlmpacket, ntlmpacketBuffer) {
        super("SSPICHALLENGE", "onSSPI");
        this.ntlmpacket = ntlmpacket;
        this.ntlmpacketBuffer = ntlmpacketBuffer;
      }
    };
    exports.SSPIToken = SSPIToken;
  }
});

// node_modules/tedious/lib/bulk-load.js
var require_bulk_load = __commonJS({
  "node_modules/tedious/lib/bulk-load.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _events = require_events();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _stream = require_stream();
    var _token = require_token();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var FLAGS = {
      nullable: 1 << 0,
      caseSen: 1 << 1,
      updateableReadWrite: 1 << 2,
      updateableUnknown: 1 << 3,
      identity: 1 << 4,
      computed: 1 << 5,
      // introduced in TDS 7.2
      fixedLenCLRType: 1 << 8,
      // introduced in TDS 7.2
      sparseColumnSet: 1 << 10,
      // introduced in TDS 7.3.B
      hidden: 1 << 13,
      // introduced in TDS 7.2
      key: 1 << 14,
      // introduced in TDS 7.2
      nullableUnknown: 1 << 15
      // introduced in TDS 7.2
    };
    var DONE_STATUS = {
      FINAL: 0,
      MORE: 1,
      ERROR: 2,
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    var rowTokenBuffer = Buffer.from([_token.TYPE.ROW]);
    var textPointerAndTimestampBuffer = Buffer.from([
      // TextPointer length
      16,
      // TextPointer
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // Timestamp
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    var textPointerNullBuffer = Buffer.from([0]);
    var RowTransform = class extends _stream.Transform {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      constructor(bulkLoad) {
        super({
          writableObjectMode: true
        });
        this.bulkLoad = bulkLoad;
        this.mainOptions = bulkLoad.options;
        this.columns = bulkLoad.columns;
        this.columnMetadataWritten = false;
      }
      /**
       * @private
       */
      _transform(row, _encoding, callback) {
        if (!this.columnMetadataWritten) {
          this.push(this.bulkLoad.getColMetaData());
          this.columnMetadataWritten = true;
        }
        this.push(rowTokenBuffer);
        for (let i = 0; i < this.columns.length; i++) {
          const c = this.columns[i];
          let value = Array.isArray(row) ? row[i] : row[c.objName];
          if (!this.bulkLoad.firstRowWritten) {
            try {
              value = c.type.validate(value, c.collation);
            } catch (error) {
              return callback(error);
            }
          }
          const parameter = {
            length: c.length,
            scale: c.scale,
            precision: c.precision,
            value
          };
          if (c.type.name === "Text" || c.type.name === "Image" || c.type.name === "NText") {
            if (value == null) {
              this.push(textPointerNullBuffer);
              continue;
            }
            this.push(textPointerAndTimestampBuffer);
          }
          this.push(c.type.generateParameterLength(parameter, this.mainOptions));
          for (const chunk of c.type.generateParameterData(parameter, this.mainOptions)) {
            this.push(chunk);
          }
        }
        process.nextTick(callback);
      }
      /**
       * @private
       */
      _flush(callback) {
        this.push(this.bulkLoad.createDoneToken());
        process.nextTick(callback);
      }
    };
    var BulkLoad = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      constructor(table, collation, connectionOptions, {
        checkConstraints = false,
        fireTriggers = false,
        keepNulls = false,
        lockTable = false,
        order = {}
      }, callback) {
        if (typeof checkConstraints !== "boolean") {
          throw new TypeError('The "options.checkConstraints" property must be of type boolean.');
        }
        if (typeof fireTriggers !== "boolean") {
          throw new TypeError('The "options.fireTriggers" property must be of type boolean.');
        }
        if (typeof keepNulls !== "boolean") {
          throw new TypeError('The "options.keepNulls" property must be of type boolean.');
        }
        if (typeof lockTable !== "boolean") {
          throw new TypeError('The "options.lockTable" property must be of type boolean.');
        }
        if (typeof order !== "object" || order === null) {
          throw new TypeError('The "options.order" property must be of type object.');
        }
        for (const [column, direction] of Object.entries(order)) {
          if (direction !== "ASC" && direction !== "DESC") {
            throw new TypeError('The value of the "' + column + '" key in the "options.order" object must be either "ASC" or "DESC".');
          }
        }
        super();
        this.error = void 0;
        this.canceled = false;
        this.executionStarted = false;
        this.collation = collation;
        this.table = table;
        this.options = connectionOptions;
        this.callback = callback;
        this.columns = [];
        this.columnsByName = {};
        this.firstRowWritten = false;
        this.streamingMode = false;
        this.rowToPacketTransform = new RowTransform(this);
        this.bulkOptions = {
          checkConstraints,
          fireTriggers,
          keepNulls,
          lockTable,
          order
        };
      }
      /**
       * Adds a column to the bulk load.
       *
       * The column definitions should match the table you are trying to insert into.
       * Attempting to call addColumn after the first row has been added will throw an exception.
       *
       * ```js
       * bulkLoad.addColumn('MyIntColumn', TYPES.Int, { nullable: false });
       * ```
       *
       * @param name The name of the column.
       * @param type One of the supported `data types`.
       * @param __namedParameters Additional column type information. At a minimum, `nullable` must be set to true or false.
       * @param length For VarChar, NVarChar, VarBinary. Use length as `Infinity` for VarChar(max), NVarChar(max) and VarBinary(max).
       * @param nullable Indicates whether the column accepts NULL values.
       * @param objName If the name of the column is different from the name of the property found on `rowObj` arguments passed to [[addRow]] or [[Connection.execBulkLoad]], then you can use this option to specify the property name.
       * @param precision For Numeric, Decimal.
       * @param scale For Numeric, Decimal, Time, DateTime2, DateTimeOffset.
      */
      addColumn(name2, type, {
        output = false,
        length,
        precision,
        scale,
        objName = name2,
        nullable = true
      }) {
        if (this.firstRowWritten) {
          throw new Error("Columns cannot be added to bulk insert after the first row has been written.");
        }
        if (this.executionStarted) {
          throw new Error("Columns cannot be added to bulk insert after execution has started.");
        }
        const column = {
          type,
          name: name2,
          value: null,
          output,
          length,
          precision,
          scale,
          objName,
          nullable,
          collation: this.collation
        };
        if ((type.id & 48) === 32) {
          if (column.length == null && type.resolveLength) {
            column.length = type.resolveLength(column);
          }
        }
        if (type.resolvePrecision && column.precision == null) {
          column.precision = type.resolvePrecision(column);
        }
        if (type.resolveScale && column.scale == null) {
          column.scale = type.resolveScale(column);
        }
        this.columns.push(column);
        this.columnsByName[name2] = column;
      }
      /**
       * @private
       */
      getOptionsSql() {
        const addOptions = [];
        if (this.bulkOptions.checkConstraints) {
          addOptions.push("CHECK_CONSTRAINTS");
        }
        if (this.bulkOptions.fireTriggers) {
          addOptions.push("FIRE_TRIGGERS");
        }
        if (this.bulkOptions.keepNulls) {
          addOptions.push("KEEP_NULLS");
        }
        if (this.bulkOptions.lockTable) {
          addOptions.push("TABLOCK");
        }
        if (this.bulkOptions.order) {
          const orderColumns = [];
          for (const [column, direction] of Object.entries(this.bulkOptions.order)) {
            orderColumns.push(`${column} ${direction}`);
          }
          if (orderColumns.length) {
            addOptions.push(`ORDER (${orderColumns.join(", ")})`);
          }
        }
        if (addOptions.length > 0) {
          return ` WITH (${addOptions.join(",")})`;
        } else {
          return "";
        }
      }
      /**
       * @private
       */
      getBulkInsertSql() {
        let sql = "insert bulk " + this.table + "(";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql += ", ";
          }
          sql += "[" + c.name + "] " + c.type.declaration(c);
        }
        sql += ")";
        sql += this.getOptionsSql();
        return sql;
      }
      /**
       * This is simply a helper utility function which returns a `CREATE TABLE SQL` statement based on the columns added to the bulkLoad object.
       * This may be particularly handy when you want to insert into a temporary table (a table which starts with `#`).
       *
       * ```js
       * var sql = bulkLoad.getTableCreationSql();
       * ```
       *
       * A side note on bulk inserting into temporary tables: if you want to access a local temporary table after executing the bulk load,
       * you'll need to use the same connection and execute your requests using [[Connection.execSqlBatch]] instead of [[Connection.execSql]]
       */
      getTableCreationSql() {
        let sql = "CREATE TABLE " + this.table + "(\n";
        for (let i = 0, len = this.columns.length; i < len; i++) {
          const c = this.columns[i];
          if (i !== 0) {
            sql += ",\n";
          }
          sql += "[" + c.name + "] " + c.type.declaration(c);
          if (c.nullable !== void 0) {
            sql += " " + (c.nullable ? "NULL" : "NOT NULL");
          }
        }
        sql += "\n)";
        return sql;
      }
      /**
       * @private
       */
      getColMetaData() {
        const tBuf = new _writableTrackingBuffer.default(100, null, true);
        tBuf.writeUInt8(_token.TYPE.COLMETADATA);
        tBuf.writeUInt16LE(this.columns.length);
        for (let j = 0, len = this.columns.length; j < len; j++) {
          const c = this.columns[j];
          if (this.options.tdsVersion < "7_2") {
            tBuf.writeUInt16LE(0);
          } else {
            tBuf.writeUInt32LE(0);
          }
          let flags = FLAGS.updateableReadWrite;
          if (c.nullable) {
            flags |= FLAGS.nullable;
          } else if (c.nullable === void 0 && this.options.tdsVersion >= "7_2") {
            flags |= FLAGS.nullableUnknown;
          }
          tBuf.writeUInt16LE(flags);
          tBuf.writeBuffer(c.type.generateTypeInfo(c, this.options));
          if (c.type.hasTableName) {
            tBuf.writeUsVarchar(this.table, "ucs2");
          }
          tBuf.writeBVarchar(c.name, "ucs2");
        }
        return tBuf.data;
      }
      /**
       * Sets a timeout for this bulk load.
       *
       * ```js
       * bulkLoad.setTimeout(timeout);
       * ```
       *
       * @param timeout The number of milliseconds before the bulk load is considered failed, or 0 for no timeout.
       *   When no timeout is set for the bulk load, the [[ConnectionOptions.requestTimeout]] of the Connection is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
      /**
       * @private
       */
      createDoneToken() {
        const tBuf = new _writableTrackingBuffer.default(this.options.tdsVersion < "7_2" ? 9 : 13);
        tBuf.writeUInt8(_token.TYPE.DONE);
        const status = DONE_STATUS.FINAL;
        tBuf.writeUInt16LE(status);
        tBuf.writeUInt16LE(0);
        tBuf.writeUInt32LE(0);
        if (this.options.tdsVersion >= "7_2") {
          tBuf.writeUInt32LE(0);
        }
        return tBuf.data;
      }
      /**
       * @private
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
    };
    var _default = exports.default = BulkLoad;
    module.exports = BulkLoad;
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:dns
var require_dns = __commonJS({
  "browser-external:dns"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "dns" has been externalized for browser compatibility. Cannot access "dns.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:constants
var require_constants = __commonJS({
  "browser-external:constants"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "constants" has been externalized for browser compatibility. Cannot access "constants.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@azure/identity/dist-esm/src/plugins/consumer.browser.js
function useIdentityPlugin(_plugin) {
  throw new Error("Identity plugins are not supported in browser environments.");
}
var init_consumer_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/plugins/consumer.browser.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/logger/dist/browser/log.js
function log(...args) {
  if (args.length > 0) {
    const firstArg = String(args[0]);
    if (firstArg.includes(":error")) {
      console.error(...args);
    } else if (firstArg.includes(":warning")) {
      console.warn(...args);
    } else if (firstArg.includes(":info")) {
      console.info(...args);
    } else if (firstArg.includes(":verbose")) {
      console.debug(...args);
    } else {
      console.debug(...args);
    }
  }
}
var init_log = __esm({
  "node_modules/@azure/logger/dist/browser/log.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/logger/dist/browser/debug.js
function enable(namespaces) {
  enabledString = namespaces;
  enabledNamespaces = [];
  skippedNamespaces = [];
  const wildcard = /\*/g;
  const namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
  for (const ns of namespaceList) {
    if (ns.startsWith("-")) {
      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
    } else {
      enabledNamespaces.push(new RegExp(`^${ns}$`));
    }
  }
  for (const instance of debuggers) {
    instance.enabled = enabled(instance.namespace);
  }
}
function enabled(namespace) {
  if (namespace.endsWith("*")) {
    return true;
  }
  for (const skipped of skippedNamespaces) {
    if (skipped.test(namespace)) {
      return false;
    }
  }
  for (const enabledNamespace of enabledNamespaces) {
    if (enabledNamespace.test(namespace)) {
      return true;
    }
  }
  return false;
}
function disable() {
  const result = enabledString || "";
  enable("");
  return result;
}
function createDebugger(namespace) {
  const newDebugger = Object.assign(debug, {
    enabled: enabled(namespace),
    destroy,
    log: debugObj.log,
    namespace,
    extend
  });
  function debug(...args) {
    if (!newDebugger.enabled) {
      return;
    }
    if (args.length > 0) {
      args[0] = `${namespace} ${args[0]}`;
    }
    newDebugger.log(...args);
  }
  debuggers.push(newDebugger);
  return newDebugger;
}
function destroy() {
  const index = debuggers.indexOf(this);
  if (index >= 0) {
    debuggers.splice(index, 1);
    return true;
  }
  return false;
}
function extend(namespace) {
  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
  newDebugger.log = this.log;
  return newDebugger;
}
var debugEnvVariable, enabledString, enabledNamespaces, skippedNamespaces, debuggers, debugObj, debug_default;
var init_debug = __esm({
  "node_modules/@azure/logger/dist/browser/debug.js"() {
    init_process();
    init_buffer();
    init_log();
    debugEnvVariable = typeof process !== "undefined" && process.env && process.env.DEBUG || void 0;
    enabledNamespaces = [];
    skippedNamespaces = [];
    debuggers = [];
    if (debugEnvVariable) {
      enable(debugEnvVariable);
    }
    debugObj = Object.assign((namespace) => {
      return createDebugger(namespace);
    }, {
      enable,
      enabled,
      disable,
      log
    });
    debug_default = debugObj;
  }
});

// node_modules/@azure/logger/dist/browser/index.js
function setLogLevel(level) {
  if (level && !isAzureLogLevel(level)) {
    throw new Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
  }
  azureLogLevel = level;
  const enabledNamespaces2 = [];
  for (const logger21 of registeredLoggers) {
    if (shouldEnable(logger21)) {
      enabledNamespaces2.push(logger21.namespace);
    }
  }
  debug_default.enable(enabledNamespaces2.join(","));
}
function getLogLevel() {
  return azureLogLevel;
}
function createClientLogger(namespace) {
  const clientRootLogger = AzureLogger.extend(namespace);
  patchLogMethod(AzureLogger, clientRootLogger);
  return {
    error: createLogger(clientRootLogger, "error"),
    warning: createLogger(clientRootLogger, "warning"),
    info: createLogger(clientRootLogger, "info"),
    verbose: createLogger(clientRootLogger, "verbose")
  };
}
function patchLogMethod(parent, child) {
  child.log = (...args) => {
    parent.log(...args);
  };
}
function createLogger(parent, level) {
  const logger21 = Object.assign(parent.extend(level), {
    level
  });
  patchLogMethod(parent, logger21);
  if (shouldEnable(logger21)) {
    const enabledNamespaces2 = debug_default.disable();
    debug_default.enable(enabledNamespaces2 + "," + logger21.namespace);
  }
  registeredLoggers.add(logger21);
  return logger21;
}
function shouldEnable(logger21) {
  return Boolean(azureLogLevel && levelMap[logger21.level] <= levelMap[azureLogLevel]);
}
function isAzureLogLevel(logLevel) {
  return AZURE_LOG_LEVELS.includes(logLevel);
}
var registeredLoggers, logLevelFromEnv, azureLogLevel, AzureLogger, AZURE_LOG_LEVELS, levelMap;
var init_browser = __esm({
  "node_modules/@azure/logger/dist/browser/index.js"() {
    init_process();
    init_buffer();
    init_debug();
    registeredLoggers = /* @__PURE__ */ new Set();
    logLevelFromEnv = typeof process !== "undefined" && process.env && process.env.AZURE_LOG_LEVEL || void 0;
    AzureLogger = debug_default("azure");
    AzureLogger.log = (...args) => {
      debug_default.log(...args);
    };
    AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
    if (logLevelFromEnv) {
      if (isAzureLogLevel(logLevelFromEnv)) {
        setLogLevel(logLevelFromEnv);
      } else {
        console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
      }
    }
    levelMap = {
      verbose: 400,
      info: 300,
      warning: 200,
      error: 100
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/util/logging.js
function formatSuccess(scope) {
  return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
}
function formatError(scope, error) {
  let message = "ERROR.";
  if (scope === null || scope === void 0 ? void 0 : scope.length) {
    message += ` Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
  }
  return `${message} Error message: ${typeof error === "string" ? error : error.message}.`;
}
function credentialLoggerInstance(title, parent, log2 = logger) {
  const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;
  function info(message) {
    log2.info(`${fullTitle} =>`, message);
  }
  function warning(message) {
    log2.warning(`${fullTitle} =>`, message);
  }
  function verbose(message) {
    log2.verbose(`${fullTitle} =>`, message);
  }
  return {
    title,
    fullTitle,
    info,
    warning,
    verbose
  };
}
function credentialLogger(title, log2 = logger) {
  const credLogger = credentialLoggerInstance(title, void 0, log2);
  return Object.assign(Object.assign({}, credLogger), { parent: log2, getToken: credentialLoggerInstance("=> getToken()", credLogger, log2) });
}
var logger;
var init_logging = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/logging.js"() {
    init_process();
    init_buffer();
    init_browser();
    logger = createClientLogger("identity");
  }
});

// node_modules/@azure/identity/dist-esm/src/errors.js
function isErrorResponse(errorResponse) {
  return errorResponse && typeof errorResponse.error === "string" && typeof errorResponse.error_description === "string";
}
function convertOAuthErrorResponseToErrorResponse(errorBody) {
  return {
    error: errorBody.error,
    errorDescription: errorBody.error_description,
    correlationId: errorBody.correlation_id,
    errorCodes: errorBody.error_codes,
    timestamp: errorBody.timestamp,
    traceId: errorBody.trace_id
  };
}
var CredentialUnavailableErrorName, CredentialUnavailableError, AuthenticationErrorName, AuthenticationError, AggregateAuthenticationErrorName, AggregateAuthenticationError, AuthenticationRequiredError;
var init_errors = __esm({
  "node_modules/@azure/identity/dist-esm/src/errors.js"() {
    init_process();
    init_buffer();
    CredentialUnavailableErrorName = "CredentialUnavailableError";
    CredentialUnavailableError = class extends Error {
      constructor(message) {
        super(message);
        this.name = CredentialUnavailableErrorName;
      }
    };
    AuthenticationErrorName = "AuthenticationError";
    AuthenticationError = class extends Error {
      // eslint-disable-next-line @typescript-eslint/ban-types
      constructor(statusCode, errorBody) {
        let errorResponse = {
          error: "unknown",
          errorDescription: "An unknown error occurred and no additional details are available."
        };
        if (isErrorResponse(errorBody)) {
          errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
        } else if (typeof errorBody === "string") {
          try {
            const oauthErrorResponse = JSON.parse(errorBody);
            errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
          } catch (e) {
            if (statusCode === 400) {
              errorResponse = {
                error: "authority_not_found",
                errorDescription: "The specified authority URL was not found."
              };
            } else {
              errorResponse = {
                error: "unknown_error",
                errorDescription: `An unknown error has occurred. Response body:

${errorBody}`
              };
            }
          }
        } else {
          errorResponse = {
            error: "unknown_error",
            errorDescription: "An unknown error occurred and no additional details are available."
          };
        }
        super(`${errorResponse.error} Status code: ${statusCode}
More details:
${errorResponse.errorDescription}`);
        this.statusCode = statusCode;
        this.errorResponse = errorResponse;
        this.name = AuthenticationErrorName;
      }
    };
    AggregateAuthenticationErrorName = "AggregateAuthenticationError";
    AggregateAuthenticationError = class extends Error {
      constructor(errors, errorMessage2) {
        const errorDetail = errors.join("\n");
        super(`${errorMessage2}
${errorDetail}`);
        this.errors = errors;
        this.name = AggregateAuthenticationErrorName;
      }
    };
    AuthenticationRequiredError = class extends Error {
      constructor(options) {
        super(options.message);
        this.scopes = options.scopes;
        this.getTokenOptions = options.getTokenOptions;
        this.name = "AuthenticationRequiredError";
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/constants.js
var SDK_VERSION, DeveloperSignOnClientId, DefaultTenantId, AzureAuthorityHosts, DefaultAuthorityHost, ALL_TENANTS;
var init_constants = __esm({
  "node_modules/@azure/identity/dist-esm/src/constants.js"() {
    init_process();
    init_buffer();
    SDK_VERSION = `3.4.2`;
    DeveloperSignOnClientId = "04b07795-8ddb-461a-bbee-02f9e1bf7b46";
    DefaultTenantId = "common";
    (function(AzureAuthorityHosts2) {
      AzureAuthorityHosts2["AzureChina"] = "https://login.chinacloudapi.cn";
      AzureAuthorityHosts2["AzureGermany"] = "https://login.microsoftonline.de";
      AzureAuthorityHosts2["AzureGovernment"] = "https://login.microsoftonline.us";
      AzureAuthorityHosts2["AzurePublicCloud"] = "https://login.microsoftonline.com";
    })(AzureAuthorityHosts || (AzureAuthorityHosts = {}));
    DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;
    ALL_TENANTS = ["*"];
  }
});

// node_modules/@azure/core-tracing/dist/browser/tracingContext.js
function createTracingContext(options = {}) {
  let context = new TracingContextImpl(options.parentContext);
  if (options.span) {
    context = context.setValue(knownContextKeys.span, options.span);
  }
  if (options.namespace) {
    context = context.setValue(knownContextKeys.namespace, options.namespace);
  }
  return context;
}
var knownContextKeys, TracingContextImpl;
var init_tracingContext = __esm({
  "node_modules/@azure/core-tracing/dist/browser/tracingContext.js"() {
    init_process();
    init_buffer();
    knownContextKeys = {
      span: Symbol.for("@azure/core-tracing span"),
      namespace: Symbol.for("@azure/core-tracing namespace")
    };
    TracingContextImpl = class _TracingContextImpl {
      constructor(initialContext) {
        this._contextMap = initialContext instanceof _TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map();
      }
      setValue(key, value) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.set(key, value);
        return newContext;
      }
      getValue(key) {
        return this._contextMap.get(key);
      }
      deleteValue(key) {
        const newContext = new _TracingContextImpl(this);
        newContext._contextMap.delete(key);
        return newContext;
      }
    };
  }
});

// node_modules/@azure/core-tracing/dist/browser/state.js
var state;
var init_state = __esm({
  "node_modules/@azure/core-tracing/dist/browser/state.js"() {
    init_process();
    init_buffer();
    state = {
      instrumenterImplementation: void 0
    };
  }
});

// node_modules/@azure/core-tracing/dist/browser/instrumenter.js
function createDefaultTracingSpan() {
  return {
    end: () => {
    },
    isRecording: () => false,
    recordException: () => {
    },
    setAttribute: () => {
    },
    setStatus: () => {
    }
  };
}
function createDefaultInstrumenter() {
  return {
    createRequestHeaders: () => {
      return {};
    },
    parseTraceparentHeader: () => {
      return void 0;
    },
    startSpan: (_name, spanOptions) => {
      return {
        span: createDefaultTracingSpan(),
        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext })
      };
    },
    withContext(_context, callback, ...callbackArgs) {
      return callback(...callbackArgs);
    }
  };
}
function getInstrumenter() {
  if (!state.instrumenterImplementation) {
    state.instrumenterImplementation = createDefaultInstrumenter();
  }
  return state.instrumenterImplementation;
}
var init_instrumenter = __esm({
  "node_modules/@azure/core-tracing/dist/browser/instrumenter.js"() {
    init_process();
    init_buffer();
    init_tracingContext();
    init_state();
  }
});

// node_modules/@azure/core-tracing/dist/browser/tracingClient.js
function createTracingClient(options) {
  const { namespace, packageName, packageVersion } = options;
  function startSpan(name2, operationOptions, spanOptions) {
    var _a3;
    const startSpanResult = getInstrumenter().startSpan(name2, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a3 = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a3 === void 0 ? void 0 : _a3.tracingContext }));
    let tracingContext = startSpanResult.tracingContext;
    const span = startSpanResult.span;
    if (!tracingContext.getValue(knownContextKeys.namespace)) {
      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);
    }
    span.setAttribute("az.namespace", tracingContext.getValue(knownContextKeys.namespace));
    const updatedOptions = Object.assign({}, operationOptions, {
      tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext })
    });
    return {
      span,
      updatedOptions
    };
  }
  async function withSpan(name2, operationOptions, callback, spanOptions) {
    const { span, updatedOptions } = startSpan(name2, operationOptions, spanOptions);
    try {
      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
      span.setStatus({ status: "success" });
      return result;
    } catch (err) {
      span.setStatus({ status: "error", error: err });
      throw err;
    } finally {
      span.end();
    }
  }
  function withContext(context, callback, ...callbackArgs) {
    return getInstrumenter().withContext(context, callback, ...callbackArgs);
  }
  function parseTraceparentHeader(traceparentHeader) {
    return getInstrumenter().parseTraceparentHeader(traceparentHeader);
  }
  function createRequestHeaders(tracingContext) {
    return getInstrumenter().createRequestHeaders(tracingContext);
  }
  return {
    startSpan,
    withSpan,
    withContext,
    parseTraceparentHeader,
    createRequestHeaders
  };
}
var init_tracingClient = __esm({
  "node_modules/@azure/core-tracing/dist/browser/tracingClient.js"() {
    init_process();
    init_buffer();
    init_instrumenter();
    init_tracingContext();
  }
});

// node_modules/@azure/core-tracing/dist/browser/index.js
var init_browser2 = __esm({
  "node_modules/@azure/core-tracing/dist/browser/index.js"() {
    init_process();
    init_buffer();
    init_instrumenter();
    init_tracingClient();
  }
});

// node_modules/@azure/identity/dist-esm/src/util/tracing.js
var tracingClient;
var init_tracing = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/tracing.js"() {
    init_process();
    init_buffer();
    init_constants();
    init_browser2();
    tracingClient = createTracingClient({
      namespace: "Microsoft.AAD",
      packageName: "@azure/identity",
      packageVersion: SDK_VERSION
    });
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/chainedTokenCredential.js
var logger2, ChainedTokenCredential;
var init_chainedTokenCredential = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/chainedTokenCredential.js"() {
    init_process();
    init_buffer();
    init_errors();
    init_logging();
    init_tracing();
    logger2 = credentialLogger("ChainedTokenCredential");
    ChainedTokenCredential = class {
      /**
       * Creates an instance of ChainedTokenCredential using the given credentials.
       *
       * @param sources - `TokenCredential` implementations to be tried in order.
       *
       * Example usage:
       * ```javascript
       * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
       * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
       * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
       * ```
       */
      constructor(...sources) {
        this._sources = [];
        this._sources = sources;
      }
      /**
       * Returns the first access token returned by one of the chained
       * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
       * when one or more credentials throws an {@link AuthenticationError} and
       * no credentials have returned an access token.
       *
       * This method is called automatically by Azure SDK client libraries. You may call this method
       * directly, but you must also handle token caching and token refreshing.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                `TokenCredential` implementation might make.
       */
      async getToken(scopes, options = {}) {
        const { token } = await this.getTokenInternal(scopes, options);
        return token;
      }
      async getTokenInternal(scopes, options = {}) {
        let token = null;
        let successfulCredential;
        const errors = [];
        return tracingClient.withSpan("ChainedTokenCredential.getToken", options, async (updatedOptions) => {
          for (let i = 0; i < this._sources.length && token === null; i++) {
            try {
              token = await this._sources[i].getToken(scopes, updatedOptions);
              successfulCredential = this._sources[i];
            } catch (err) {
              if (err.name === "CredentialUnavailableError" || err.name === "AuthenticationRequiredError") {
                errors.push(err);
              } else {
                logger2.getToken.info(formatError(scopes, err));
                throw err;
              }
            }
          }
          if (!token && errors.length > 0) {
            const err = new AggregateAuthenticationError(errors, "ChainedTokenCredential authentication failed.");
            logger2.getToken.info(formatError(scopes, err));
            throw err;
          }
          logger2.getToken.info(`Result for ${successfulCredential.constructor.name}: ${formatSuccess(scopes)}`);
          if (token === null) {
            throw new CredentialUnavailableError("Failed to retrieve a valid token");
          }
          return { token, successfulCredential };
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/defaultAzureCredential.browser.js
var BrowserNotSupportedError, logger3, DefaultAzureCredential;
var init_defaultAzureCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/defaultAzureCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    init_chainedTokenCredential();
    BrowserNotSupportedError = new Error("DefaultAzureCredential is not supported in the browser. Use InteractiveBrowserCredential instead.");
    logger3 = credentialLogger("DefaultAzureCredential");
    DefaultAzureCredential = class extends ChainedTokenCredential {
      /**
       * Creates an instance of the DefaultAzureCredential class.
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(_tokenCredentialOptions) {
        super();
        logger3.info(formatError("", BrowserNotSupportedError));
        throw BrowserNotSupportedError;
      }
      getToken() {
        logger3.getToken.info(formatError("", BrowserNotSupportedError));
        throw BrowserNotSupportedError;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/operatingcontext/BaseOperatingContext.mjs
var BaseOperatingContext;
var init_BaseOperatingContext = __esm({
  "node_modules/@azure/msal-browser/dist/operatingcontext/BaseOperatingContext.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_dist();
    init_Configuration();
    init_packageMetadata();
    init_BrowserConstants();
    BaseOperatingContext = class _BaseOperatingContext {
      static loggerCallback(level, message) {
        switch (level) {
          case LogLevel.Error:
            console.error(message);
            return;
          case LogLevel.Info:
            console.info(message);
            return;
          case LogLevel.Verbose:
            console.debug(message);
            return;
          case LogLevel.Warning:
            console.warn(message);
            return;
          default:
            console.log(message);
            return;
        }
      }
      constructor(config) {
        var _a3;
        this.browserEnvironment = typeof window !== "undefined";
        this.config = buildConfiguration(config, this.browserEnvironment);
        let sessionStorage;
        try {
          sessionStorage = window[BrowserCacheLocation.SessionStorage];
        } catch (e) {
        }
        const logLevelKey = sessionStorage == null ? void 0 : sessionStorage.getItem(LOG_LEVEL_CACHE_KEY);
        const piiLoggingKey = (_a3 = sessionStorage == null ? void 0 : sessionStorage.getItem(LOG_PII_CACHE_KEY)) == null ? void 0 : _a3.toLowerCase();
        const piiLoggingEnabled = piiLoggingKey === "true" ? true : piiLoggingKey === "false" ? false : void 0;
        const loggerOptions = { ...this.config.system.loggerOptions };
        const logLevel = logLevelKey && Object.keys(LogLevel).includes(logLevelKey) ? LogLevel[logLevelKey] : void 0;
        if (logLevel) {
          loggerOptions.loggerCallback = _BaseOperatingContext.loggerCallback;
          loggerOptions.logLevel = logLevel;
        }
        if (piiLoggingEnabled !== void 0) {
          loggerOptions.piiLoggingEnabled = piiLoggingEnabled;
        }
        this.logger = new Logger(loggerOptions, name, version);
        this.available = false;
      }
      /**
       * Return the MSAL config
       * @returns BrowserConfiguration
       */
      getConfig() {
        return this.config;
      }
      /**
       * Returns the MSAL Logger
       * @returns Logger
       */
      getLogger() {
        return this.logger;
      }
      isAvailable() {
        return this.available;
      }
      isBrowserEnvironment() {
        return this.browserEnvironment;
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/naa/BridgeProxy.mjs
var BridgeProxy;
var init_BridgeProxy = __esm({
  "node_modules/@azure/msal-browser/dist/naa/BridgeProxy.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_BridgeStatusCode();
    init_BrowserCrypto();
    BridgeProxy = class _BridgeProxy {
      /**
       * initializeNestedAppAuthBridge - Initializes the bridge to the host app
       * @returns a promise that resolves to an InitializeBridgeResponse or rejects with an Error
       * @remarks This method will be called by the create factory method
       * @remarks If the bridge is not available, this method will throw an error
       */
      static async initializeNestedAppAuthBridge() {
        if (window === void 0) {
          throw new Error("window is undefined");
        }
        if (window.nestedAppAuthBridge === void 0) {
          throw new Error("window.nestedAppAuthBridge is undefined");
        }
        try {
          window.nestedAppAuthBridge.addEventListener("message", (response) => {
            const responsePayload = typeof response === "string" ? response : response.data;
            const responseEnvelope = JSON.parse(responsePayload);
            const request = _BridgeProxy.bridgeRequests.find((element) => element.requestId === responseEnvelope.requestId);
            if (request !== void 0) {
              _BridgeProxy.bridgeRequests.splice(_BridgeProxy.bridgeRequests.indexOf(request), 1);
              if (responseEnvelope.success) {
                request.resolve(responseEnvelope);
              } else {
                request.reject(responseEnvelope.error);
              }
            }
          });
          const bridgeResponse = await new Promise((resolve, reject) => {
            const message = {
              messageType: "NestedAppAuthRequest",
              method: "GetInitContext",
              requestId: createNewGuid()
            };
            const request = {
              requestId: message.requestId,
              method: message.method,
              resolve,
              reject
            };
            _BridgeProxy.bridgeRequests.push(request);
            window.nestedAppAuthBridge.postMessage(JSON.stringify(message));
          });
          return _BridgeProxy.validateBridgeResultOrThrow(bridgeResponse.initContext);
        } catch (error) {
          window.console.log(error);
          throw error;
        }
      }
      /**
       * getTokenInteractive - Attempts to get a token interactively from the bridge
       * @param request A token request
       * @returns a promise that resolves to an auth result or rejects with a BridgeError
       */
      getTokenInteractive(request) {
        return this.getToken("GetTokenPopup", request);
      }
      /**
       * getTokenSilent Attempts to get a token silently from the bridge
       * @param request A token request
       * @returns a promise that resolves to an auth result or rejects with a BridgeError
       */
      getTokenSilent(request) {
        return this.getToken("GetToken", request);
      }
      async getToken(requestType, request) {
        const result = await this.sendRequest(requestType, {
          tokenParams: request
        });
        return {
          token: _BridgeProxy.validateBridgeResultOrThrow(result.token),
          account: _BridgeProxy.validateBridgeResultOrThrow(result.account)
        };
      }
      async getActiveAccount() {
        const result = await this.sendRequest("GetActiveAccount");
        return _BridgeProxy.validateBridgeResultOrThrow(result.account);
      }
      getHostCapabilities() {
        return this.capabilities ?? null;
      }
      /**
       * A method used to send a request to the bridge
       * @param request A token request
       * @returns a promise that resolves to a response of provided type or rejects with a BridgeError
       */
      sendRequest(method, requestParams) {
        const message = {
          messageType: "NestedAppAuthRequest",
          method,
          requestId: createNewGuid(),
          ...requestParams
        };
        const promise = new Promise((resolve, reject) => {
          const request = {
            requestId: message.requestId,
            method: message.method,
            resolve,
            reject
          };
          _BridgeProxy.bridgeRequests.push(request);
          window.nestedAppAuthBridge.postMessage(JSON.stringify(message));
        });
        return promise;
      }
      static validateBridgeResultOrThrow(input) {
        if (input === void 0) {
          const bridgeError = {
            status: BridgeStatusCode.NestedAppAuthUnavailable
          };
          throw bridgeError;
        }
        return input;
      }
      /**
       * Private constructor for BridgeProxy
       * @param sdkName The name of the SDK being used to make requests on behalf of the app
       * @param sdkVersion The version of the SDK being used to make requests on behalf of the app
       * @param capabilities The capabilities of the bridge / SDK / platform broker
       */
      constructor(sdkName, sdkVersion, capabilities) {
        this.sdkName = sdkName;
        this.sdkVersion = sdkVersion;
        this.capabilities = capabilities;
      }
      /**
       * Factory method for creating an implementation of IBridgeProxy
       * @returns A promise that resolves to a BridgeProxy implementation
       */
      static async create() {
        const response = await _BridgeProxy.initializeNestedAppAuthBridge();
        return new _BridgeProxy(response.sdkName, response.sdkVersion, response.capabilities);
      }
    };
    BridgeProxy.bridgeRequests = [];
  }
});

// node_modules/@azure/msal-browser/dist/operatingcontext/TeamsAppOperatingContext.mjs
var TeamsAppOperatingContext;
var init_TeamsAppOperatingContext = __esm({
  "node_modules/@azure/msal-browser/dist/operatingcontext/TeamsAppOperatingContext.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_BaseOperatingContext();
    init_BridgeProxy();
    TeamsAppOperatingContext = class _TeamsAppOperatingContext extends BaseOperatingContext {
      constructor() {
        super(...arguments);
        this.bridgeProxy = void 0;
        this.activeAccount = void 0;
      }
      /**
       * Return the module name.  Intended for use with import() to enable dynamic import
       * of the implementation associated with this operating context
       * @returns
       */
      getModuleName() {
        return _TeamsAppOperatingContext.MODULE_NAME;
      }
      /**
       * Returns the unique identifier for this operating context
       * @returns string
       */
      getId() {
        return _TeamsAppOperatingContext.ID;
      }
      getBridgeProxy() {
        return this.bridgeProxy;
      }
      getActiveAccount() {
        return this.activeAccount;
      }
      setActiveAccount(account) {
        this.activeAccount = account;
      }
      /**
       * Checks whether the operating context is available.
       * Confirms that the code is running a browser rather.  This is required.
       * @returns Promise<boolean> indicating whether this operating context is currently available.
       */
      async initialize() {
        var _a3;
        try {
          if (typeof window !== "undefined") {
            const bridgeProxy = await BridgeProxy.create();
            try {
              if ((_a3 = bridgeProxy.getHostCapabilities()) == null ? void 0 : _a3.queryAccount) {
                this.activeAccount = await bridgeProxy.getActiveAccount();
              }
            } catch (e) {
              this.activeAccount = void 0;
            }
            this.bridgeProxy = bridgeProxy;
            this.available = bridgeProxy !== void 0;
          } else {
            this.available = false;
          }
        } catch (e) {
          this.available = false;
        } finally {
          return this.available;
        }
      }
    };
    TeamsAppOperatingContext.MODULE_NAME = "";
    TeamsAppOperatingContext.ID = "TeamsAppOperatingContext";
  }
});

// node_modules/@azure/msal-browser/dist/operatingcontext/StandardOperatingContext.mjs
var StandardOperatingContext;
var init_StandardOperatingContext = __esm({
  "node_modules/@azure/msal-browser/dist/operatingcontext/StandardOperatingContext.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_BaseOperatingContext();
    StandardOperatingContext = class _StandardOperatingContext extends BaseOperatingContext {
      /**
       * Return the module name.  Intended for use with import() to enable dynamic import
       * of the implementation associated with this operating context
       * @returns
       */
      getModuleName() {
        return _StandardOperatingContext.MODULE_NAME;
      }
      /**
       * Returns the unique identifier for this operating context
       * @returns string
       */
      getId() {
        return _StandardOperatingContext.ID;
      }
      /**
       * Checks whether the operating context is available.
       * Confirms that the code is running a browser rather.  This is required.
       * @returns Promise<boolean> indicating whether this operating context is currently available.
       */
      async initialize() {
        this.available = typeof window !== "undefined";
        return this.available;
      }
    };
    StandardOperatingContext.MODULE_NAME = "";
    StandardOperatingContext.ID = "StandardOperatingContext";
  }
});

// node_modules/@azure/msal-browser/dist/controllers/ControllerFactory.mjs
async function createV3Controller(config) {
  const standard = new StandardOperatingContext(config);
  await standard.initialize();
  const controller = await import("./StandardController-KFTYCUS2.js");
  return controller.StandardController.createController(standard);
}
var init_ControllerFactory = __esm({
  "node_modules/@azure/msal-browser/dist/controllers/ControllerFactory.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_TeamsAppOperatingContext();
    init_StandardOperatingContext();
  }
});

// node_modules/@azure/msal-browser/dist/app/PublicClientApplication.mjs
var PublicClientApplication;
var init_PublicClientApplication = __esm({
  "node_modules/@azure/msal-browser/dist/app/PublicClientApplication.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_ControllerFactory();
    init_StandardController();
    init_StandardOperatingContext();
    PublicClientApplication = class _PublicClientApplication {
      static async createPublicClientApplication(configuration) {
        const controller = await createV3Controller(configuration);
        const pca = new _PublicClientApplication(configuration, controller);
        return pca;
      }
      /**
       * @constructor
       * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object
       *
       * Important attributes in the Configuration object for auth are:
       * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview
       * - authority: the authority URL for your application.
       * - redirect_uri: the uri of your application registered in the portal.
       *
       * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.
       * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}
       * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
       * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
       * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
       * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
       *
       * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/
       * Full B2C functionality will be available in this library in future versions.
       *
       * @param configuration Object for the MSAL PublicClientApplication instance
       * @param IController Optional parameter to explictly set the controller. (Will be removed when we remove public constructor)
       */
      constructor(configuration, controller) {
        if (controller) {
          this.controller = controller;
        } else {
          const standardOperatingContext = new StandardOperatingContext(configuration);
          this.controller = new StandardController(standardOperatingContext);
        }
      }
      /**
       * Initializer function to perform async startup tasks such as connecting to WAM extension
       */
      async initialize() {
        return this.controller.initialize();
      }
      /**
       * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser
       *
       * @param request
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      async acquireTokenPopup(request) {
        return this.controller.acquireTokenPopup(request);
      }
      /**
       * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects
       * the page, so any code that follows this function will not execute.
       *
       * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
       * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
       *
       * @param request
       */
      acquireTokenRedirect(request) {
        return this.controller.acquireTokenRedirect(request);
      }
      /**
       * Silently acquire an access token for a given set of scopes. Returns currently processing promise if parallel requests are made.
       *
       * @param {@link (SilentRequest:type)}
       * @returns {Promise.<AuthenticationResult>} - a promise that is fulfilled when this function has completed, or rejected if an error was raised. Returns the {@link AuthenticationResult} object
       */
      acquireTokenSilent(silentRequest) {
        return this.controller.acquireTokenSilent(silentRequest);
      }
      /**
       * This function redeems an authorization code (passed as code) from the eSTS token endpoint.
       * This authorization code should be acquired server-side using a confidential client to acquire a spa_code.
       * This API is not indended for normal authorization code acquisition and redemption.
       *
       * Redemption of this authorization code will not require PKCE, as it was acquired by a confidential client.
       *
       * @param request {@link AuthorizationCodeRequest}
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      acquireTokenByCode(request) {
        return this.controller.acquireTokenByCode(request);
      }
      /**
       * Adds event callbacks to array
       * @param callback
       */
      addEventCallback(callback) {
        return this.controller.addEventCallback(callback);
      }
      /**
       * Removes callback with provided id from callback array
       * @param callbackId
       */
      removeEventCallback(callbackId) {
        return this.controller.removeEventCallback(callbackId);
      }
      /**
       * Registers a callback to receive performance events.
       *
       * @param {PerformanceCallbackFunction} callback
       * @returns {string}
       */
      addPerformanceCallback(callback) {
        return this.controller.addPerformanceCallback(callback);
      }
      /**
       * Removes a callback registered with addPerformanceCallback.
       *
       * @param {string} callbackId
       * @returns {boolean}
       */
      removePerformanceCallback(callbackId) {
        return this.controller.removePerformanceCallback(callbackId);
      }
      /**
       * Adds event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
       */
      enableAccountStorageEvents() {
        this.controller.enableAccountStorageEvents();
      }
      /**
       * Removes event listener that emits an event when a user account is added or removed from localstorage in a different browser tab or window
       */
      disableAccountStorageEvents() {
        this.controller.disableAccountStorageEvents();
      }
      /**
       * Returns the first account found in the cache that matches the account filter passed in.
       * @param accountFilter
       * @returns The first account found in the cache matching the provided filter or null if no account could be found.
       */
      getAccount(accountFilter) {
        return this.controller.getAccount(accountFilter);
      }
      /**
       * Returns the signed in account matching homeAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param homeAccountId
       * @returns The account object stored in MSAL
       * @deprecated - Use getAccount instead
       */
      getAccountByHomeId(homeAccountId) {
        return this.controller.getAccountByHomeId(homeAccountId);
      }
      /**
       * Returns the signed in account matching localAccountId.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found
       * @param localAccountId
       * @returns The account object stored in MSAL
       * @deprecated - Use getAccount instead
       */
      getAccountByLocalId(localId) {
        return this.controller.getAccountByLocalId(localId);
      }
      /**
       * Returns the signed in account matching username.
       * (the account object is created at the time of successful login)
       * or null when no matching account is found.
       * This API is provided for convenience but getAccountById should be used for best reliability
       * @param userName
       * @returns The account object stored in MSAL
       * @deprecated - Use getAccount instead
       */
      getAccountByUsername(userName) {
        return this.controller.getAccountByUsername(userName);
      }
      /**
       * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
       * @param accountFilter - (Optional) filter to narrow down the accounts returned
       * @returns Array of AccountInfo objects in cache
       */
      getAllAccounts(accountFilter) {
        return this.controller.getAllAccounts(accountFilter);
      }
      /**
       * Event handler function which allows users to fire events after the PublicClientApplication object
       * has loaded during redirect flows. This should be invoked on all page loads involved in redirect
       * auth flows.
       * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.
       * @returns Token response or null. If the return value is null, then no auth redirect was detected.
       */
      handleRedirectPromise(hash) {
        return this.controller.handleRedirectPromise(hash);
      }
      /**
       * Use when initiating the login process via opening a popup window in the user's browser
       *
       * @param request
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      loginPopup(request) {
        return this.controller.loginPopup(request);
      }
      /**
       * Use when initiating the login process by redirecting the user's browser to the authorization endpoint. This function redirects the page, so
       * any code that follows this function will not execute.
       *
       * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current
       * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.
       *
       * @param request
       */
      loginRedirect(request) {
        return this.controller.loginRedirect(request);
      }
      /**
       * Deprecated logout function. Use logoutRedirect or logoutPopup instead
       * @param logoutRequest
       * @deprecated
       */
      logout(logoutRequest) {
        return this.controller.logout(logoutRequest);
      }
      /**
       * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.
       * Default behaviour is to redirect the user to `window.location.href`.
       * @param logoutRequest
       */
      logoutRedirect(logoutRequest) {
        return this.controller.logoutRedirect(logoutRequest);
      }
      /**
       * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server
       * @param logoutRequest
       */
      logoutPopup(logoutRequest) {
        return this.controller.logoutPopup(logoutRequest);
      }
      /**
       * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:
       * - Any browser using a form of Intelligent Tracking Prevention
       * - If there is not an established session with the service
       *
       * In these cases, the request must be done inside a popup or full frame redirect.
       *
       * For the cases where interaction is required, you cannot send a request with prompt=none.
       *
       * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as
       * you session on the server still exists.
       * @param request {@link SsoSilentRequest}
       *
       * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.
       */
      ssoSilent(request) {
        return this.controller.ssoSilent(request);
      }
      /**
       * Gets the token cache for the application.
       */
      getTokenCache() {
        return this.controller.getTokenCache();
      }
      /**
       * Returns the logger instance
       */
      getLogger() {
        return this.controller.getLogger();
      }
      /**
       * Replaces the default logger set in configurations with new Logger with new configurations
       * @param logger Logger instance
       */
      setLogger(logger21) {
        this.controller.setLogger(logger21);
      }
      /**
       * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.
       * @param account
       */
      setActiveAccount(account) {
        this.controller.setActiveAccount(account);
      }
      /**
       * Gets the currently active account
       */
      getActiveAccount() {
        return this.controller.getActiveAccount();
      }
      /**
       * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.
       * @param sku
       * @param version
       */
      initializeWrapperLibrary(sku, version2) {
        return this.controller.initializeWrapperLibrary(sku, version2);
      }
      /**
       * Sets navigation client
       * @param navigationClient
       */
      setNavigationClient(navigationClient) {
        this.controller.setNavigationClient(navigationClient);
      }
      /**
       * Returns the configuration object
       * @internal
       */
      getConfiguration() {
        return this.controller.getConfiguration();
      }
      /**
       * Hydrates cache with the tokens and account in the AuthenticationResult object
       * @param result
       * @param request - The request object that was used to obtain the AuthenticationResult
       * @returns
       */
      async hydrateCache(result, request) {
        return this.controller.hydrateCache(result, request);
      }
      /**
       * Clears tokens and account from the browser cache.
       * @param logoutRequest
       */
      clearCache(logoutRequest) {
        return this.controller.clearCache(logoutRequest);
      }
    };
  }
});

// node_modules/@azure/msal-browser/dist/controllers/UnknownOperatingContextController.mjs
var init_UnknownOperatingContextController = __esm({
  "node_modules/@azure/msal-browser/dist/controllers/UnknownOperatingContextController.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_dist();
    init_BrowserCacheManager();
    init_CryptoOps();
    init_BrowserUtils();
    init_EventHandler();
  }
});

// node_modules/@azure/msal-browser/dist/operatingcontext/UnknownOperatingContext.mjs
var UnknownOperatingContext;
var init_UnknownOperatingContext = __esm({
  "node_modules/@azure/msal-browser/dist/operatingcontext/UnknownOperatingContext.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_BaseOperatingContext();
    UnknownOperatingContext = class _UnknownOperatingContext extends BaseOperatingContext {
      /**
       * Return the module name.  Intended for use with import() to enable dynamic import
       * of the implementation associated with this operating context
       * @returns
       */
      getModuleName() {
        return _UnknownOperatingContext.MODULE_NAME;
      }
      /**
       * Returns the unique identifier for this operating context
       * @returns string
       */
      getId() {
        return _UnknownOperatingContext.ID;
      }
      /**
       * Checks whether the operating context is available.
       * Confirms that the code is running a browser rather.  This is required.
       * @returns Promise<boolean> indicating whether this operating context is currently available.
       */
      async initialize() {
        return true;
      }
    };
    UnknownOperatingContext.MODULE_NAME = "";
    UnknownOperatingContext.ID = "UnknownOperatingContext";
  }
});

// node_modules/@azure/msal-browser/dist/app/PublicClientNext.mjs
var init_PublicClientNext = __esm({
  "node_modules/@azure/msal-browser/dist/app/PublicClientNext.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_ControllerFactory();
    init_UnknownOperatingContextController();
    init_UnknownOperatingContext();
  }
});

// node_modules/@azure/msal-browser/dist/app/IPublicClientApplication.mjs
var init_IPublicClientApplication = __esm({
  "node_modules/@azure/msal-browser/dist/app/IPublicClientApplication.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_BrowserConfigurationAuthError();
    init_BrowserConfigurationAuthErrorCodes();
  }
});

// node_modules/@azure/msal-browser/dist/event/EventMessage.mjs
var init_EventMessage = __esm({
  "node_modules/@azure/msal-browser/dist/event/EventMessage.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_EventType();
    init_BrowserConstants();
  }
});

// node_modules/@azure/msal-browser/dist/crypto/SignedHttpRequest.mjs
var init_SignedHttpRequest = __esm({
  "node_modules/@azure/msal-browser/dist/crypto/SignedHttpRequest.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_CryptoOps();
    init_dist();
    init_packageMetadata();
  }
});

// node_modules/@azure/msal-browser/dist/telemetry/BrowserPerformanceClient.mjs
var init_BrowserPerformanceClient = __esm({
  "node_modules/@azure/msal-browser/dist/telemetry/BrowserPerformanceClient.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_dist();
    init_packageMetadata();
    init_BrowserConstants();
    init_BrowserCrypto();
  }
});

// node_modules/@azure/msal-browser/dist/index.mjs
var init_dist2 = __esm({
  "node_modules/@azure/msal-browser/dist/index.mjs"() {
    "use strict";
    init_process();
    init_buffer();
    init_BrowserUtils();
    init_PublicClientApplication();
    init_PublicClientNext();
    init_Configuration();
    init_BrowserConstants();
    init_BrowserAuthError();
    init_BrowserConfigurationAuthError();
    init_IPublicClientApplication();
    init_NavigationClient();
    init_MemoryStorage();
    init_BrowserStorage();
    init_EventMessage();
    init_EventType();
    init_SignedHttpRequest();
    init_BrowserPerformanceClient();
    init_BrowserPerformanceMeasurement();
    init_dist();
    init_packageMetadata();
    init_BrowserAuthErrorCodes();
    init_BrowserConfigurationAuthErrorCodes();
  }
});

// node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js
function abortSignal(signal) {
  if (signal.aborted) {
    return;
  }
  if (signal.onabort) {
    signal.onabort.call(signal);
  }
  const listeners = listenersMap.get(signal);
  if (listeners) {
    listeners.slice().forEach((listener) => {
      listener.call(signal, { type: "abort" });
    });
  }
  abortedMap.set(signal, true);
}
var listenersMap, abortedMap, AbortSignal;
var init_AbortSignal = __esm({
  "node_modules/@azure/abort-controller/dist-esm/src/AbortSignal.js"() {
    init_process();
    init_buffer();
    listenersMap = /* @__PURE__ */ new WeakMap();
    abortedMap = /* @__PURE__ */ new WeakMap();
    AbortSignal = class _AbortSignal {
      constructor() {
        this.onabort = null;
        listenersMap.set(this, []);
        abortedMap.set(this, false);
      }
      /**
       * Status of whether aborted or not.
       *
       * @readonly
       */
      get aborted() {
        if (!abortedMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        return abortedMap.get(this);
      }
      /**
       * Creates a new AbortSignal instance that will never be aborted.
       *
       * @readonly
       */
      static get none() {
        return new _AbortSignal();
      }
      /**
       * Added new "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be added
       */
      addEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        listeners.push(listener);
      }
      /**
       * Remove "abort" event listener, only support "abort" event.
       *
       * @param _type - Only support "abort" event
       * @param listener - The listener to be removed
       */
      removeEventListener(_type, listener) {
        if (!listenersMap.has(this)) {
          throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        }
        const listeners = listenersMap.get(this);
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
      /**
       * Dispatches a synthetic event to the AbortSignal.
       */
      dispatchEvent(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
      }
    };
  }
});

// node_modules/@azure/abort-controller/dist-esm/src/AbortController.js
var AbortError, AbortController2;
var init_AbortController = __esm({
  "node_modules/@azure/abort-controller/dist-esm/src/AbortController.js"() {
    init_process();
    init_buffer();
    init_AbortSignal();
    AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    AbortController2 = class {
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      constructor(parentSignals) {
        this._signal = new AbortSignal();
        if (!parentSignals) {
          return;
        }
        if (!Array.isArray(parentSignals)) {
          parentSignals = arguments;
        }
        for (const parentSignal of parentSignals) {
          if (parentSignal.aborted) {
            this.abort();
          } else {
            parentSignal.addEventListener("abort", () => {
              this.abort();
            });
          }
        }
      }
      /**
       * The AbortSignal associated with this controller that will signal aborted
       * when the abort method is called on this controller.
       *
       * @readonly
       */
      get signal() {
        return this._signal;
      }
      /**
       * Signal that any operations passed this controller's associated abort signal
       * to cancel any remaining work and throw an `AbortError`.
       */
      abort() {
        abortSignal(this._signal);
      }
      /**
       * Creates a new AbortSignal instance that will abort after the provided ms.
       * @param ms - Elapsed time in milliseconds to trigger an abort.
       */
      static timeout(ms) {
        const signal = new AbortSignal();
        const timer = setTimeout(abortSignal, ms, signal);
        if (typeof timer.unref === "function") {
          timer.unref();
        }
        return signal;
      }
    };
  }
});

// node_modules/@azure/abort-controller/dist-esm/src/index.js
var init_src = __esm({
  "node_modules/@azure/abort-controller/dist-esm/src/index.js"() {
    init_process();
    init_buffer();
    init_AbortController();
    init_AbortSignal();
  }
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/browser/AbortError.js
var init_AbortError = __esm({
  "node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/browser/AbortError.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/browser/index.js
var init_browser3 = __esm({
  "node_modules/@azure/core-util/node_modules/@azure/abort-controller/dist/browser/index.js"() {
    init_process();
    init_buffer();
    init_AbortError();
  }
});

// node_modules/@azure/core-util/dist/browser/createAbortablePromise.js
var init_createAbortablePromise = __esm({
  "node_modules/@azure/core-util/dist/browser/createAbortablePromise.js"() {
    init_process();
    init_buffer();
    init_browser3();
  }
});

// node_modules/@azure/core-util/dist/browser/delay.js
var init_delay = __esm({
  "node_modules/@azure/core-util/dist/browser/delay.js"() {
    init_process();
    init_buffer();
    init_createAbortablePromise();
  }
});

// node_modules/@azure/core-util/dist/browser/aborterUtils.js
var init_aborterUtils = __esm({
  "node_modules/@azure/core-util/dist/browser/aborterUtils.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-util/dist/browser/random.js
function getRandomIntegerInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  const offset = Math.floor(Math.random() * (max - min + 1));
  return offset + min;
}
var init_random = __esm({
  "node_modules/@azure/core-util/dist/browser/random.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-util/dist/browser/object.js
function isObject(input) {
  return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}
var init_object = __esm({
  "node_modules/@azure/core-util/dist/browser/object.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-util/dist/browser/error.js
function isError(e) {
  if (isObject(e)) {
    const hasName = typeof e.name === "string";
    const hasMessage = typeof e.message === "string";
    return hasName && hasMessage;
  }
  return false;
}
function getErrorMessage(e) {
  if (isError(e)) {
    return e.message;
  } else {
    let stringified;
    try {
      if (typeof e === "object" && e) {
        stringified = JSON.stringify(e);
      } else {
        stringified = String(e);
      }
    } catch (err) {
      stringified = "[unable to stringify input]";
    }
    return `Unknown error ${stringified}`;
  }
}
var init_error = __esm({
  "node_modules/@azure/core-util/dist/browser/error.js"() {
    init_process();
    init_buffer();
    init_object();
  }
});

// node_modules/@azure/core-util/dist/browser/bytesEncoding.js
function stringToUint8Array(value, format) {
  switch (format) {
    case "utf-8":
      return utf8StringToUint8Array(value);
    case "base64":
      return base64ToUint8Array(value);
    case "base64url":
      return base64UrlToUint8Array(value);
    case "hex":
      return hexStringToUint8Array(value);
  }
}
function utf8StringToUint8Array(value) {
  return new TextEncoder().encode(value);
}
function base64ToUint8Array(value) {
  return new Uint8Array([...atob(value)].map((x) => x.charCodeAt(0)));
}
function base64UrlToUint8Array(value) {
  const base64String = value.replace(/-/g, "+").replace(/_/g, "/");
  return base64ToUint8Array(base64String);
}
function hexStringToUint8Array(value) {
  const bytes = new Uint8Array(value.length / 2);
  for (let i = 0; i < value.length / 2; ++i) {
    const highNibble = value[2 * i];
    const lowNibble = value[2 * i + 1];
    if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) {
      return bytes.slice(0, i);
    }
    bytes[i] = parseInt(`${highNibble}${lowNibble}`, 16);
  }
  return bytes;
}
var hexDigits;
var init_bytesEncoding = __esm({
  "node_modules/@azure/core-util/dist/browser/bytesEncoding.js"() {
    init_process();
    init_buffer();
    hexDigits = new Set("0123456789abcdefABCDEF");
  }
});

// node_modules/@azure/core-util/dist/browser/sha256.js
var init_sha256 = __esm({
  "node_modules/@azure/core-util/dist/browser/sha256.js"() {
    init_process();
    init_buffer();
    init_bytesEncoding();
  }
});

// node_modules/@azure/core-util/dist/browser/typeGuards.js
var init_typeGuards = __esm({
  "node_modules/@azure/core-util/dist/browser/typeGuards.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-util/dist/browser/uuidUtils.common.js
function generateUUID() {
  let uuid = "";
  for (let i = 0; i < 32; i++) {
    const randomNumber = Math.floor(Math.random() * 16);
    if (i === 12) {
      uuid += "4";
    } else if (i === 16) {
      uuid += randomNumber & 3 | 8;
    } else {
      uuid += randomNumber.toString(16);
    }
    if (i === 7 || i === 11 || i === 15 || i === 19) {
      uuid += "-";
    }
  }
  return uuid;
}
var init_uuidUtils_common = __esm({
  "node_modules/@azure/core-util/dist/browser/uuidUtils.common.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-util/dist/browser/uuidUtils.js
function randomUUID() {
  return uuidFunction();
}
var _a, uuidFunction;
var init_uuidUtils = __esm({
  "node_modules/@azure/core-util/dist/browser/uuidUtils.js"() {
    init_process();
    init_buffer();
    init_uuidUtils_common();
    uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : generateUUID;
  }
});

// node_modules/@azure/core-util/dist/browser/checkEnvironment.js
var _a2, _b, _c, _d, isBrowser, isWebWorker, isDeno, isBun, isNodeLike, isNode, isReactNative;
var init_checkEnvironment = __esm({
  "node_modules/@azure/core-util/dist/browser/checkEnvironment.js"() {
    init_process();
    init_buffer();
    isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_a2 = self.constructor) === null || _a2 === void 0 ? void 0 : _a2.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "SharedWorkerGlobalScope");
    isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_d = globalThis.process.versions) === null || _d === void 0 ? void 0 : _d.node);
    isNode = isNodeLike;
    isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
  }
});

// node_modules/@azure/core-util/dist/browser/index.js
var init_browser4 = __esm({
  "node_modules/@azure/core-util/dist/browser/index.js"() {
    init_process();
    init_buffer();
    init_delay();
    init_aborterUtils();
    init_createAbortablePromise();
    init_random();
    init_object();
    init_error();
    init_sha256();
    init_typeGuards();
    init_uuidUtils();
    init_checkEnvironment();
    init_bytesEncoding();
  }
});

// node_modules/@azure/identity/dist-esm/src/msal/utils.browser.js
function ensureValidMsalToken(scopes, logger21, msalToken, getTokenOptions) {
  const error = (message) => {
    logger21.getToken.info(message);
    return new AuthenticationRequiredError({
      scopes: Array.isArray(scopes) ? scopes : [scopes],
      getTokenOptions,
      message
    });
  };
  if (!msalToken) {
    throw error("No response");
  }
  if (!msalToken.expiresOn) {
    throw error(`Response had no "expiresOn" property.`);
  }
  if (!msalToken.accessToken) {
    throw error(`Response had no "accessToken" property.`);
  }
}
function getAuthority(tenantId, host) {
  if (!host) {
    host = DefaultAuthorityHost;
  }
  if (new RegExp(`${tenantId}/?$`).test(host)) {
    return host;
  }
  if (host.endsWith("/")) {
    return host + tenantId;
  } else {
    return `${host}/${tenantId}`;
  }
}
function getKnownAuthorities(tenantId, authorityHost, disableInstanceDiscovery) {
  if (tenantId === "adfs" && authorityHost || disableInstanceDiscovery) {
    return [authorityHost];
  }
  return [];
}
function getMSALLogLevel(logLevel) {
  switch (logLevel) {
    case "error":
      return LogLevel.Error;
    case "info":
      return LogLevel.Info;
    case "verbose":
      return LogLevel.Verbose;
    case "warning":
      return LogLevel.Warning;
    default:
      return LogLevel.Info;
  }
}
function publicToMsal(account) {
  const [environment] = account.authority.match(/([a-z]*\.[a-z]*\.[a-z]*)/) || [""];
  return Object.assign(Object.assign({}, account), { localAccountId: account.homeAccountId, environment });
}
function msalToPublic(clientId, account) {
  const record = {
    authority: getAuthority(account.tenantId, account.environment),
    homeAccountId: account.homeAccountId,
    tenantId: account.tenantId || DefaultTenantId,
    username: account.username,
    clientId,
    version: LatestAuthenticationRecordVersion
  };
  return record;
}
function serializeAuthenticationRecord(record) {
  return JSON.stringify(record);
}
function deserializeAuthenticationRecord(serializedRecord) {
  const parsed = JSON.parse(serializedRecord);
  if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {
    throw Error("Unsupported AuthenticationRecord version");
  }
  return parsed;
}
var LatestAuthenticationRecordVersion, defaultLoggerCallback, MsalBaseUtilities;
var init_utils_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/msal/utils.browser.js"() {
    init_process();
    init_buffer();
    init_dist2();
    init_errors();
    init_logging();
    init_constants();
    init_src();
    init_browser4();
    LatestAuthenticationRecordVersion = "1.0";
    defaultLoggerCallback = (logger21, platform = isNode ? "Node" : "Browser") => (level, message, containsPii) => {
      if (containsPii) {
        return;
      }
      switch (level) {
        case LogLevel.Error:
          logger21.info(`MSAL ${platform} V2 error: ${message}`);
          return;
        case LogLevel.Info:
          logger21.info(`MSAL ${platform} V2 info message: ${message}`);
          return;
        case LogLevel.Verbose:
          logger21.info(`MSAL ${platform} V2 verbose message: ${message}`);
          return;
        case LogLevel.Warning:
          logger21.info(`MSAL ${platform} V2 warning: ${message}`);
          return;
      }
    };
    MsalBaseUtilities = class {
      constructor(options) {
        this.logger = options.logger;
        this.account = options.authenticationRecord;
      }
      /**
       * Generates a UUID
       */
      generateUuid() {
        return randomUUID();
      }
      /**
       * Handles the MSAL authentication result.
       * If the result has an account, we update the local account reference.
       * If the token received is invalid, an error will be thrown depending on what's missing.
       */
      handleResult(scopes, clientId, result, getTokenOptions) {
        if (result === null || result === void 0 ? void 0 : result.account) {
          this.account = msalToPublic(clientId, result.account);
        }
        ensureValidMsalToken(scopes, this.logger, result, getTokenOptions);
        this.logger.getToken.info(formatSuccess(scopes));
        return {
          token: result.accessToken,
          expiresOnTimestamp: result.expiresOn.getTime()
        };
      }
      /**
       * Handles MSAL errors.
       */
      handleError(scopes, error, getTokenOptions) {
        if (error.name === "AuthError" || error.name === "ClientAuthError" || error.name === "BrowserAuthError") {
          const msalError = error;
          switch (msalError.errorCode) {
            case "endpoints_resolution_error":
              this.logger.info(formatError(scopes, error.message));
              return new CredentialUnavailableError(error.message);
            case "device_code_polling_cancelled":
              return new AbortError("The authentication has been aborted by the caller.");
            case "consent_required":
            case "interaction_required":
            case "login_required":
              this.logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));
              break;
            default:
              this.logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));
              break;
          }
        }
        if (error.name === "ClientConfigurationError" || error.name === "BrowserConfigurationAuthError" || error.name === "AbortError") {
          return error;
        }
        return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/pipeline.js
function createEmptyPipeline() {
  return HttpPipeline.create();
}
var ValidPhaseNames, HttpPipeline;
var init_pipeline = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/pipeline.js"() {
    init_process();
    init_buffer();
    ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
    HttpPipeline = class _HttpPipeline {
      constructor(policies) {
        var _a3;
        this._policies = [];
        this._policies = (_a3 = policies === null || policies === void 0 ? void 0 : policies.slice(0)) !== null && _a3 !== void 0 ? _a3 : [];
        this._orderedPolicies = void 0;
      }
      addPolicy(policy, options = {}) {
        if (options.phase && options.afterPhase) {
          throw new Error("Policies inside a phase cannot specify afterPhase.");
        }
        if (options.phase && !ValidPhaseNames.has(options.phase)) {
          throw new Error(`Invalid phase name: ${options.phase}`);
        }
        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
          throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
        }
        this._policies.push({
          policy,
          options
        });
        this._orderedPolicies = void 0;
      }
      removePolicy(options) {
        const removedPolicies = [];
        this._policies = this._policies.filter((policyDescriptor) => {
          if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase) {
            removedPolicies.push(policyDescriptor.policy);
            return false;
          } else {
            return true;
          }
        });
        this._orderedPolicies = void 0;
        return removedPolicies;
      }
      sendRequest(httpClient, request) {
        const policies = this.getOrderedPolicies();
        const pipeline = policies.reduceRight((next, policy) => {
          return (req) => {
            return policy.sendRequest(req, next);
          };
        }, (req) => httpClient.sendRequest(req));
        return pipeline(request);
      }
      getOrderedPolicies() {
        if (!this._orderedPolicies) {
          this._orderedPolicies = this.orderPolicies();
        }
        return this._orderedPolicies;
      }
      clone() {
        return new _HttpPipeline(this._policies);
      }
      static create() {
        return new _HttpPipeline();
      }
      orderPolicies() {
        const result = [];
        const policyMap = /* @__PURE__ */ new Map();
        function createPhase(name2) {
          return {
            name: name2,
            policies: /* @__PURE__ */ new Set(),
            hasRun: false,
            hasAfterPolicies: false
          };
        }
        const serializePhase = createPhase("Serialize");
        const noPhase = createPhase("None");
        const deserializePhase = createPhase("Deserialize");
        const retryPhase = createPhase("Retry");
        const signPhase = createPhase("Sign");
        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
        function getPhase(phase) {
          if (phase === "Retry") {
            return retryPhase;
          } else if (phase === "Serialize") {
            return serializePhase;
          } else if (phase === "Deserialize") {
            return deserializePhase;
          } else if (phase === "Sign") {
            return signPhase;
          } else {
            return noPhase;
          }
        }
        for (const descriptor of this._policies) {
          const policy = descriptor.policy;
          const options = descriptor.options;
          const policyName = policy.name;
          if (policyMap.has(policyName)) {
            throw new Error("Duplicate policy names not allowed in pipeline");
          }
          const node = {
            policy,
            dependsOn: /* @__PURE__ */ new Set(),
            dependants: /* @__PURE__ */ new Set()
          };
          if (options.afterPhase) {
            node.afterPhase = getPhase(options.afterPhase);
            node.afterPhase.hasAfterPolicies = true;
          }
          policyMap.set(policyName, node);
          const phase = getPhase(options.phase);
          phase.policies.add(node);
        }
        for (const descriptor of this._policies) {
          const { policy, options } = descriptor;
          const policyName = policy.name;
          const node = policyMap.get(policyName);
          if (!node) {
            throw new Error(`Missing node for policy ${policyName}`);
          }
          if (options.afterPolicies) {
            for (const afterPolicyName of options.afterPolicies) {
              const afterNode = policyMap.get(afterPolicyName);
              if (afterNode) {
                node.dependsOn.add(afterNode);
                afterNode.dependants.add(node);
              }
            }
          }
          if (options.beforePolicies) {
            for (const beforePolicyName of options.beforePolicies) {
              const beforeNode = policyMap.get(beforePolicyName);
              if (beforeNode) {
                beforeNode.dependsOn.add(node);
                node.dependants.add(beforeNode);
              }
            }
          }
        }
        function walkPhase(phase) {
          phase.hasRun = true;
          for (const node of phase.policies) {
            if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
              continue;
            }
            if (node.dependsOn.size === 0) {
              result.push(node.policy);
              for (const dependant of node.dependants) {
                dependant.dependsOn.delete(node);
              }
              policyMap.delete(node.policy.name);
              phase.policies.delete(node);
            }
          }
        }
        function walkPhases() {
          for (const phase of orderedPhases) {
            walkPhase(phase);
            if (phase.policies.size > 0 && phase !== noPhase) {
              if (!noPhase.hasRun) {
                walkPhase(noPhase);
              }
              return;
            }
            if (phase.hasAfterPolicies) {
              walkPhase(noPhase);
            }
          }
        }
        let iteration = 0;
        while (policyMap.size > 0) {
          iteration++;
          const initialResultLength = result.length;
          walkPhases();
          if (result.length <= initialResultLength && iteration > 1) {
            throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
          }
        }
        return result;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/log.js
var logger4;
var init_log2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/log.js"() {
    init_process();
    init_buffer();
    init_browser();
    logger4 = createClientLogger("core-rest-pipeline");
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/sanitizer.js
var RedactedString, defaultAllowedHeaderNames, defaultAllowedQueryParameters, Sanitizer;
var init_sanitizer = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/sanitizer.js"() {
    init_process();
    init_buffer();
    init_browser4();
    RedactedString = "REDACTED";
    defaultAllowedHeaderNames = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate"
    ];
    defaultAllowedQueryParameters = ["api-version"];
    Sanitizer = class {
      constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
      }
      sanitize(obj) {
        const seen = /* @__PURE__ */ new Set();
        return JSON.stringify(obj, (key, value) => {
          if (value instanceof Error) {
            return Object.assign(Object.assign({}, value), { name: value.name, message: value.message });
          }
          if (key === "headers") {
            return this.sanitizeHeaders(value);
          } else if (key === "url") {
            return this.sanitizeUrl(value);
          } else if (key === "query") {
            return this.sanitizeQuery(value);
          } else if (key === "body") {
            return void 0;
          } else if (key === "response") {
            return void 0;
          } else if (key === "operationSpec") {
            return void 0;
          } else if (Array.isArray(value) || isObject(value)) {
            if (seen.has(value)) {
              return "[Circular]";
            }
            seen.add(value);
          }
          return value;
        }, 2);
      }
      sanitizeHeaders(obj) {
        const sanitized = {};
        for (const key of Object.keys(obj)) {
          if (this.allowedHeaderNames.has(key.toLowerCase())) {
            sanitized[key] = obj[key];
          } else {
            sanitized[key] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeQuery(value) {
        if (typeof value !== "object" || value === null) {
          return value;
        }
        const sanitized = {};
        for (const k of Object.keys(value)) {
          if (this.allowedQueryParameters.has(k.toLowerCase())) {
            sanitized[k] = value[k];
          } else {
            sanitized[k] = RedactedString;
          }
        }
        return sanitized;
      }
      sanitizeUrl(value) {
        if (typeof value !== "string" || value === null) {
          return value;
        }
        const url = new URL(value);
        if (!url.search) {
          return value;
        }
        for (const [key] of url.searchParams) {
          if (!this.allowedQueryParameters.has(key.toLowerCase())) {
            url.searchParams.set(key, RedactedString);
          }
        }
        return url.toString();
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/logPolicy.js
function logPolicy(options = {}) {
  var _a3;
  const logger21 = (_a3 = options.logger) !== null && _a3 !== void 0 ? _a3 : logger4.info;
  const sanitizer = new Sanitizer({
    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
  });
  return {
    name: logPolicyName,
    async sendRequest(request, next) {
      if (!logger21.enabled) {
        return next(request);
      }
      logger21(`Request: ${sanitizer.sanitize(request)}`);
      const response = await next(request);
      logger21(`Response status code: ${response.status}`);
      logger21(`Headers: ${sanitizer.sanitize(response.headers)}`);
      return response;
    }
  };
}
var logPolicyName;
var init_logPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/logPolicy.js"() {
    init_process();
    init_buffer();
    init_log2();
    init_sanitizer();
    logPolicyName = "logPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/redirectPolicy.js
function redirectPolicy(options = {}) {
  const { maxRetries = 20 } = options;
  return {
    name: redirectPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return handleRedirect(next, response, maxRetries);
    }
  };
}
async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
  const { request, status, headers } = response;
  const locationHeader = headers.get("location");
  if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
    const url = new URL(locationHeader, request.url);
    request.url = url.toString();
    if (status === 303) {
      request.method = "GET";
      request.headers.delete("Content-Length");
      delete request.body;
    }
    request.headers.delete("Authorization");
    const res = await next(request);
    return handleRedirect(next, res, maxRetries, currentRetries + 1);
  }
  return response;
}
var redirectPolicyName, allowedRedirect;
var init_redirectPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/redirectPolicy.js"() {
    init_process();
    init_buffer();
    redirectPolicyName = "redirectPolicy";
    allowedRedirect = ["GET", "HEAD"];
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgentPlatform.js
function getHeaderName() {
  return "x-ms-useragent";
}
function setPlatformSpecificData(map) {
  var _a3, _b2, _c2;
  const localNavigator = globalThis.navigator;
  map.set("OS", ((_c2 = (_b2 = (_a3 = localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.userAgentData) === null || _a3 === void 0 ? void 0 : _a3.platform) !== null && _b2 !== void 0 ? _b2 : localNavigator === null || localNavigator === void 0 ? void 0 : localNavigator.platform) !== null && _c2 !== void 0 ? _c2 : "unknown").replace(" ", ""));
}
var init_userAgentPlatform = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgentPlatform.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/constants.js
var SDK_VERSION2, DEFAULT_RETRY_POLICY_COUNT;
var init_constants2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/constants.js"() {
    init_process();
    init_buffer();
    SDK_VERSION2 = "1.16.0";
    DEFAULT_RETRY_POLICY_COUNT = 3;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgent.js
function getUserAgentString(telemetryInfo) {
  const parts = [];
  for (const [key, value] of telemetryInfo) {
    const token = value ? `${key}/${value}` : key;
    parts.push(token);
  }
  return parts.join(" ");
}
function getUserAgentHeaderName() {
  return getHeaderName();
}
function getUserAgentValue(prefix) {
  const runtimeInfo = /* @__PURE__ */ new Map();
  runtimeInfo.set("core-rest-pipeline", SDK_VERSION2);
  setPlatformSpecificData(runtimeInfo);
  const defaultAgent = getUserAgentString(runtimeInfo);
  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  return userAgentValue;
}
var init_userAgent = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/userAgent.js"() {
    init_process();
    init_buffer();
    init_userAgentPlatform();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/userAgentPolicy.js
function userAgentPolicy(options = {}) {
  const userAgentValue = getUserAgentValue(options.userAgentPrefix);
  return {
    name: userAgentPolicyName,
    async sendRequest(request, next) {
      if (!request.headers.has(UserAgentHeaderName)) {
        request.headers.set(UserAgentHeaderName, userAgentValue);
      }
      return next(request);
    }
  };
}
var UserAgentHeaderName, userAgentPolicyName;
var init_userAgentPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/userAgentPolicy.js"() {
    init_process();
    init_buffer();
    init_userAgent();
    UserAgentHeaderName = getUserAgentHeaderName();
    userAgentPolicyName = "userAgentPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/typeGuards.js
function isNodeReadableStream(x) {
  return Boolean(x && typeof x["pipe"] === "function");
}
function isWebReadableStream(x) {
  return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
}
function isBlob(x) {
  return typeof x.stream === "function";
}
var init_typeGuards2 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/typeGuards.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/file.js
function hasRawContent(x) {
  return typeof x[rawContent] === "function";
}
function getRawContent(blob) {
  if (hasRawContent(blob)) {
    return blob[rawContent]();
  } else {
    return blob.stream();
  }
}
var rawContent;
var init_file = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/file.js"() {
    init_process();
    init_buffer();
    init_browser4();
    init_typeGuards2();
    rawContent = Symbol("rawContent");
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/concat.js
function drain(stream) {
  return new Response(stream).blob();
}
async function toBlobPart(source) {
  if (source instanceof Blob || source instanceof Uint8Array) {
    return source;
  }
  if (isWebReadableStream(source)) {
    return drain(source);
  }
  const rawContent2 = getRawContent(source);
  if (isNodeReadableStream(rawContent2)) {
    throw new Error("Encountered unexpected type. In the browser, `concat` supports Web ReadableStream, Blob, Uint8Array, and files created using `createFile` only.");
  }
  return toBlobPart(rawContent2);
}
async function concat(sources) {
  const parts = [];
  for (const source of sources) {
    parts.push(await toBlobPart(typeof source === "function" ? source() : source));
  }
  return new Blob(parts);
}
var init_concat = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/concat.js"() {
    init_process();
    init_buffer();
    init_file();
    init_typeGuards2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/multipartPolicy.js
function generateBoundary() {
  return `----AzSDKFormBoundary${randomUUID()}`;
}
function encodeHeaders(headers) {
  let result = "";
  for (const [key, value] of headers) {
    result += `${key}: ${value}\r
`;
  }
  return result;
}
function getLength(source) {
  if (source instanceof Uint8Array) {
    return source.byteLength;
  } else if (isBlob(source)) {
    return source.size === -1 ? void 0 : source.size;
  } else {
    return void 0;
  }
}
function getTotalLength(sources) {
  let total = 0;
  for (const source of sources) {
    const partLength = getLength(source);
    if (partLength === void 0) {
      return void 0;
    } else {
      total += partLength;
    }
  }
  return total;
}
async function buildRequestBody(request, parts, boundary) {
  const sources = [
    stringToUint8Array(`--${boundary}`, "utf-8"),
    ...parts.flatMap((part) => [
      stringToUint8Array("\r\n", "utf-8"),
      stringToUint8Array(encodeHeaders(part.headers), "utf-8"),
      stringToUint8Array("\r\n", "utf-8"),
      part.body,
      stringToUint8Array(`\r
--${boundary}`, "utf-8")
    ]),
    stringToUint8Array("--\r\n\r\n", "utf-8")
  ];
  const contentLength = getTotalLength(sources);
  if (contentLength) {
    request.headers.set("Content-Length", contentLength);
  }
  request.body = await concat(sources);
}
function assertValidBoundary(boundary) {
  if (boundary.length > maxBoundaryLength) {
    throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
  }
  if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
    throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
  }
}
function multipartPolicy() {
  return {
    name: multipartPolicyName,
    async sendRequest(request, next) {
      var _a3;
      if (!request.multipartBody) {
        return next(request);
      }
      if (request.body) {
        throw new Error("multipartBody and regular body cannot be set at the same time");
      }
      let boundary = request.multipartBody.boundary;
      const contentTypeHeader = (_a3 = request.headers.get("Content-Type")) !== null && _a3 !== void 0 ? _a3 : "multipart/mixed";
      const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
      if (!parsedHeader) {
        throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
      }
      const [, contentType, parsedBoundary] = parsedHeader;
      if (parsedBoundary && boundary && parsedBoundary !== boundary) {
        throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
      }
      boundary !== null && boundary !== void 0 ? boundary : boundary = parsedBoundary;
      if (boundary) {
        assertValidBoundary(boundary);
      } else {
        boundary = generateBoundary();
      }
      request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
      await buildRequestBody(request, request.multipartBody.parts, boundary);
      request.multipartBody = void 0;
      return next(request);
    }
  };
}
var multipartPolicyName, maxBoundaryLength, validBoundaryCharacters;
var init_multipartPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/multipartPolicy.js"() {
    init_process();
    init_buffer();
    init_browser4();
    init_concat();
    init_typeGuards2();
    multipartPolicyName = "multipartPolicy";
    maxBoundaryLength = 70;
    validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/decompressResponsePolicy.js
function decompressResponsePolicy() {
  throw new Error("decompressResponsePolicy is not supported in browser environment");
}
var init_decompressResponsePolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/decompressResponsePolicy.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/dist/browser/AbortError.js
var AbortError3;
var init_AbortError2 = __esm({
  "node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/dist/browser/AbortError.js"() {
    init_process();
    init_buffer();
    AbortError3 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/dist/browser/index.js
var init_browser5 = __esm({
  "node_modules/@azure/core-rest-pipeline/node_modules/@azure/abort-controller/dist/browser/index.js"() {
    init_process();
    init_buffer();
    init_AbortError2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/helpers.js
function delay2(delayInMs, value, options) {
  return new Promise((resolve, reject) => {
    let timer = void 0;
    let onAborted = void 0;
    const rejectOnAbort = () => {
      return reject(new AbortError3((options === null || options === void 0 ? void 0 : options.abortErrorMsg) ? options === null || options === void 0 ? void 0 : options.abortErrorMsg : StandardAbortMessage));
    };
    const removeListeners = () => {
      if ((options === null || options === void 0 ? void 0 : options.abortSignal) && onAborted) {
        options.abortSignal.removeEventListener("abort", onAborted);
      }
    };
    onAborted = () => {
      if (timer) {
        clearTimeout(timer);
      }
      removeListeners();
      return rejectOnAbort();
    };
    if ((options === null || options === void 0 ? void 0 : options.abortSignal) && options.abortSignal.aborted) {
      return rejectOnAbort();
    }
    timer = setTimeout(() => {
      removeListeners();
      resolve(value);
    }, delayInMs);
    if (options === null || options === void 0 ? void 0 : options.abortSignal) {
      options.abortSignal.addEventListener("abort", onAborted);
    }
  });
}
function parseHeaderValueAsNumber(response, headerName) {
  const value = response.headers.get(headerName);
  if (!value)
    return;
  const valueAsNum = Number(value);
  if (Number.isNaN(valueAsNum))
    return;
  return valueAsNum;
}
var StandardAbortMessage;
var init_helpers = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/helpers.js"() {
    init_process();
    init_buffer();
    init_browser5();
    StandardAbortMessage = "The operation was aborted.";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/retryStrategies/throttlingRetryStrategy.js
function getRetryAfterInMs(response) {
  if (!(response && [429, 503].includes(response.status)))
    return void 0;
  try {
    for (const header of AllRetryAfterHeaders) {
      const retryAfterValue = parseHeaderValueAsNumber(response, header);
      if (retryAfterValue === 0 || retryAfterValue) {
        const multiplyingFactor = header === RetryAfterHeader ? 1e3 : 1;
        return retryAfterValue * multiplyingFactor;
      }
    }
    const retryAfterHeader = response.headers.get(RetryAfterHeader);
    if (!retryAfterHeader)
      return;
    const date = Date.parse(retryAfterHeader);
    const diff = date - Date.now();
    return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
  } catch (e) {
    return void 0;
  }
}
function isThrottlingRetryResponse(response) {
  return Number.isFinite(getRetryAfterInMs(response));
}
function throttlingRetryStrategy() {
  return {
    name: "throttlingRetryStrategy",
    retry({ response }) {
      const retryAfterInMs = getRetryAfterInMs(response);
      if (!Number.isFinite(retryAfterInMs)) {
        return { skipStrategy: true };
      }
      return {
        retryAfterInMs
      };
    }
  };
}
var RetryAfterHeader, AllRetryAfterHeaders;
var init_throttlingRetryStrategy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/retryStrategies/throttlingRetryStrategy.js"() {
    init_process();
    init_buffer();
    init_helpers();
    RetryAfterHeader = "Retry-After";
    AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/retryStrategies/exponentialRetryStrategy.js
function exponentialRetryStrategy(options = {}) {
  var _a3, _b2;
  const retryInterval = (_a3 = options.retryDelayInMs) !== null && _a3 !== void 0 ? _a3 : DEFAULT_CLIENT_RETRY_INTERVAL;
  const maxRetryInterval = (_b2 = options.maxRetryDelayInMs) !== null && _b2 !== void 0 ? _b2 : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
  let retryAfterInMs = retryInterval;
  return {
    name: "exponentialRetryStrategy",
    retry({ retryCount, response, responseError }) {
      const matchedSystemError = isSystemError(responseError);
      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
      const isExponential = isExponentialRetryResponse(response);
      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);
      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
        return { skipStrategy: true };
      }
      if (responseError && !matchedSystemError && !isExponential) {
        return { errorToThrow: responseError };
      }
      const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);
      const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);
      retryAfterInMs = clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);
      return { retryAfterInMs };
    }
  };
}
function isExponentialRetryResponse(response) {
  return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
}
function isSystemError(err) {
  if (!err) {
    return false;
  }
  return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
}
var DEFAULT_CLIENT_RETRY_INTERVAL, DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
var init_exponentialRetryStrategy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/retryStrategies/exponentialRetryStrategy.js"() {
    init_process();
    init_buffer();
    init_browser4();
    init_throttlingRetryStrategy();
    DEFAULT_CLIENT_RETRY_INTERVAL = 1e3;
    DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1e3 * 64;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/retryPolicy.js
function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {
  const logger21 = options.logger || retryPolicyLogger;
  return {
    name: retryPolicyName,
    async sendRequest(request, next) {
      var _a3, _b2;
      let response;
      let responseError;
      let retryCount = -1;
      retryRequest:
        while (true) {
          retryCount += 1;
          response = void 0;
          responseError = void 0;
          try {
            logger21.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
            response = await next(request);
            logger21.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
          } catch (e) {
            logger21.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
            responseError = e;
            if (!e || responseError.name !== "RestError") {
              throw e;
            }
            response = responseError.response;
          }
          if ((_a3 = request.abortSignal) === null || _a3 === void 0 ? void 0 : _a3.aborted) {
            logger21.error(`Retry ${retryCount}: Request aborted.`);
            const abortError = new AbortError3();
            throw abortError;
          }
          if (retryCount >= ((_b2 = options.maxRetries) !== null && _b2 !== void 0 ? _b2 : DEFAULT_RETRY_POLICY_COUNT)) {
            logger21.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
            if (responseError) {
              throw responseError;
            } else if (response) {
              return response;
            } else {
              throw new Error("Maximum retries reached with no response or error to throw");
            }
          }
          logger21.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
          strategiesLoop:
            for (const strategy of strategies) {
              const strategyLogger = strategy.logger || retryPolicyLogger;
              strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
              const modifiers = strategy.retry({
                retryCount,
                response,
                responseError
              });
              if (modifiers.skipStrategy) {
                strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                continue strategiesLoop;
              }
              const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
              if (errorToThrow) {
                strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
                throw errorToThrow;
              }
              if (retryAfterInMs || retryAfterInMs === 0) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
                await delay2(retryAfterInMs, void 0, { abortSignal: request.abortSignal });
                continue retryRequest;
              }
              if (redirectTo) {
                strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
                request.url = redirectTo;
                continue retryRequest;
              }
            }
          if (responseError) {
            logger21.info(`None of the retry strategies could work with the received error. Throwing it.`);
            throw responseError;
          }
          if (response) {
            logger21.info(`None of the retry strategies could work with the received response. Returning it.`);
            return response;
          }
        }
    }
  };
}
var retryPolicyLogger, retryPolicyName;
var init_retryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/retryPolicy.js"() {
    init_process();
    init_buffer();
    init_helpers();
    init_browser();
    init_browser5();
    init_constants2();
    retryPolicyLogger = createClientLogger("core-rest-pipeline retryPolicy");
    retryPolicyName = "retryPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/defaultRetryPolicy.js
function defaultRetryPolicy(options = {}) {
  var _a3;
  return {
    name: defaultRetryPolicyName,
    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {
      maxRetries: (_a3 = options.maxRetries) !== null && _a3 !== void 0 ? _a3 : DEFAULT_RETRY_POLICY_COUNT
    }).sendRequest
  };
}
var defaultRetryPolicyName;
var init_defaultRetryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/defaultRetryPolicy.js"() {
    init_process();
    init_buffer();
    init_exponentialRetryStrategy();
    init_throttlingRetryStrategy();
    init_retryPolicy();
    init_constants2();
    defaultRetryPolicyName = "defaultRetryPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/httpHeaders.js
function normalizeName(name2) {
  return name2.toLowerCase();
}
function* headerIterator(map) {
  for (const entry of map.values()) {
    yield [entry.name, entry.value];
  }
}
function createHttpHeaders(rawHeaders) {
  return new HttpHeadersImpl(rawHeaders);
}
var HttpHeadersImpl;
var init_httpHeaders = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/httpHeaders.js"() {
    init_process();
    init_buffer();
    HttpHeadersImpl = class {
      constructor(rawHeaders) {
        this._headersMap = /* @__PURE__ */ new Map();
        if (rawHeaders) {
          for (const headerName of Object.keys(rawHeaders)) {
            this.set(headerName, rawHeaders[headerName]);
          }
        }
      }
      /**
       * Set a header in this collection with the provided name and value. The name is
       * case-insensitive.
       * @param name - The name of the header to set. This value is case-insensitive.
       * @param value - The value of the header to set.
       */
      set(name2, value) {
        this._headersMap.set(normalizeName(name2), { name: name2, value: String(value).trim() });
      }
      /**
       * Get the header value for the provided header name, or undefined if no header exists in this
       * collection with the provided name.
       * @param name - The name of the header. This value is case-insensitive.
       */
      get(name2) {
        var _a3;
        return (_a3 = this._headersMap.get(normalizeName(name2))) === null || _a3 === void 0 ? void 0 : _a3.value;
      }
      /**
       * Get whether or not this header collection contains a header entry for the provided header name.
       * @param name - The name of the header to set. This value is case-insensitive.
       */
      has(name2) {
        return this._headersMap.has(normalizeName(name2));
      }
      /**
       * Remove the header with the provided headerName.
       * @param name - The name of the header to remove.
       */
      delete(name2) {
        this._headersMap.delete(normalizeName(name2));
      }
      /**
       * Get the JSON object representation of this HTTP header collection.
       */
      toJSON(options = {}) {
        const result = {};
        if (options.preserveCase) {
          for (const entry of this._headersMap.values()) {
            result[entry.name] = entry.value;
          }
        } else {
          for (const [normalizedName, entry] of this._headersMap) {
            result[normalizedName] = entry.value;
          }
        }
        return result;
      }
      /**
       * Get the string representation of this HTTP header collection.
       */
      toString() {
        return JSON.stringify(this.toJSON({ preserveCase: true }));
      }
      /**
       * Iterate over tuples of header [name, value] pairs.
       */
      [Symbol.iterator]() {
        return headerIterator(this._headersMap);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/formDataPolicy.js
function formDataToFormDataMap(formData) {
  var _a3;
  const formDataMap = {};
  for (const [key, value] of formData.entries()) {
    (_a3 = formDataMap[key]) !== null && _a3 !== void 0 ? _a3 : formDataMap[key] = [];
    formDataMap[key].push(value);
  }
  return formDataMap;
}
function formDataPolicy() {
  return {
    name: formDataPolicyName,
    async sendRequest(request, next) {
      if (isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
        request.formData = formDataToFormDataMap(request.body);
        request.body = void 0;
      }
      if (request.formData) {
        const contentType = request.headers.get("Content-Type");
        if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
          request.body = wwwFormUrlEncode(request.formData);
        } else {
          await prepareFormData(request.formData, request);
        }
        request.formData = void 0;
      }
      return next(request);
    }
  };
}
function wwwFormUrlEncode(formData) {
  const urlSearchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(formData)) {
    if (Array.isArray(value)) {
      for (const subValue of value) {
        urlSearchParams.append(key, subValue.toString());
      }
    } else {
      urlSearchParams.append(key, value.toString());
    }
  }
  return urlSearchParams.toString();
}
async function prepareFormData(formData, request) {
  const contentType = request.headers.get("Content-Type");
  if (contentType && !contentType.startsWith("multipart/form-data")) {
    return;
  }
  request.headers.set("Content-Type", contentType !== null && contentType !== void 0 ? contentType : "multipart/form-data");
  const parts = [];
  for (const [fieldName, values] of Object.entries(formData)) {
    for (const value of Array.isArray(values) ? values : [values]) {
      if (typeof value === "string") {
        parts.push({
          headers: createHttpHeaders({
            "Content-Disposition": `form-data; name="${fieldName}"`
          }),
          body: stringToUint8Array(value, "utf-8")
        });
      } else if (value === void 0 || value === null || typeof value !== "object") {
        throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
      } else {
        const fileName = value.name || "blob";
        const headers = createHttpHeaders();
        headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
        headers.set("Content-Type", value.type || "application/octet-stream");
        parts.push({
          headers,
          body: value
        });
      }
    }
  }
  request.multipartBody = { parts };
}
var formDataPolicyName;
var init_formDataPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/formDataPolicy.js"() {
    init_process();
    init_buffer();
    init_browser4();
    init_httpHeaders();
    formDataPolicyName = "formDataPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/proxyPolicy.js
function proxyPolicy() {
  throw new Error(errorMessage);
}
var errorMessage;
var init_proxyPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/proxyPolicy.js"() {
    init_process();
    init_buffer();
    errorMessage = "proxyPolicy is not supported in browser environment";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/setClientRequestIdPolicy.js
function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
  return {
    name: setClientRequestIdPolicyName,
    async sendRequest(request, next) {
      if (!request.headers.has(requestIdHeaderName)) {
        request.headers.set(requestIdHeaderName, request.requestId);
      }
      return next(request);
    }
  };
}
var setClientRequestIdPolicyName;
var init_setClientRequestIdPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/setClientRequestIdPolicy.js"() {
    init_process();
    init_buffer();
    setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/tlsPolicy.js
function tlsPolicy(tlsSettings) {
  return {
    name: tlsPolicyName,
    sendRequest: async (req, next) => {
      if (!req.tlsSettings) {
        req.tlsSettings = tlsSettings;
      }
      return next(req);
    }
  };
}
var tlsPolicyName;
var init_tlsPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/tlsPolicy.js"() {
    init_process();
    init_buffer();
    tlsPolicyName = "tlsPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/inspect.js
var custom;
var init_inspect = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/inspect.js"() {
    init_process();
    init_buffer();
    custom = {};
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/restError.js
function isRestError(e) {
  if (e instanceof RestError) {
    return true;
  }
  return isError(e) && e.name === "RestError";
}
var errorSanitizer, RestError;
var init_restError = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/restError.js"() {
    init_process();
    init_buffer();
    init_browser4();
    init_inspect();
    init_sanitizer();
    errorSanitizer = new Sanitizer();
    RestError = class _RestError extends Error {
      constructor(message, options = {}) {
        super(message);
        this.name = "RestError";
        this.code = options.code;
        this.statusCode = options.statusCode;
        this.request = options.request;
        this.response = options.response;
        Object.setPrototypeOf(this, _RestError.prototype);
      }
      /**
       * Logging method for util.inspect in Node
       */
      [custom]() {
        return `RestError: ${this.message} 
 ${errorSanitizer.sanitize(this)}`;
      }
    };
    RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    RestError.PARSE_ERROR = "PARSE_ERROR";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/tracingPolicy.js
function tracingPolicy(options = {}) {
  const userAgent = getUserAgentValue(options.userAgentPrefix);
  const tracingClient2 = tryCreateTracingClient();
  return {
    name: tracingPolicyName,
    async sendRequest(request, next) {
      var _a3, _b2;
      if (!tracingClient2 || !((_a3 = request.tracingOptions) === null || _a3 === void 0 ? void 0 : _a3.tracingContext)) {
        return next(request);
      }
      const { span, tracingContext } = (_b2 = tryCreateSpan(tracingClient2, request, userAgent)) !== null && _b2 !== void 0 ? _b2 : {};
      if (!span || !tracingContext) {
        return next(request);
      }
      try {
        const response = await tracingClient2.withContext(tracingContext, next, request);
        tryProcessResponse(span, response);
        return response;
      } catch (err) {
        tryProcessError(span, err);
        throw err;
      }
    }
  };
}
function tryCreateTracingClient() {
  try {
    return createTracingClient({
      namespace: "",
      packageName: "@azure/core-rest-pipeline",
      packageVersion: SDK_VERSION2
    });
  } catch (e) {
    logger4.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryCreateSpan(tracingClient2, request, userAgent) {
  try {
    const { span, updatedOptions } = tracingClient2.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
      spanKind: "client",
      spanAttributes: {
        "http.method": request.method,
        "http.url": request.url,
        requestId: request.requestId
      }
    });
    if (!span.isRecording()) {
      span.end();
      return void 0;
    }
    if (userAgent) {
      span.setAttribute("http.user_agent", userAgent);
    }
    const headers = tracingClient2.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
    for (const [key, value] of Object.entries(headers)) {
      request.headers.set(key, value);
    }
    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
  } catch (e) {
    logger4.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);
    return void 0;
  }
}
function tryProcessError(span, error) {
  try {
    span.setStatus({
      status: "error",
      error: isError(error) ? error : void 0
    });
    if (isRestError(error) && error.statusCode) {
      span.setAttribute("http.status_code", error.statusCode);
    }
    span.end();
  } catch (e) {
    logger4.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
function tryProcessResponse(span, response) {
  try {
    span.setAttribute("http.status_code", response.status);
    const serviceRequestId = response.headers.get("x-ms-request-id");
    if (serviceRequestId) {
      span.setAttribute("serviceRequestId", serviceRequestId);
    }
    span.setStatus({
      status: "success"
    });
    span.end();
  } catch (e) {
    logger4.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);
  }
}
var tracingPolicyName;
var init_tracingPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/tracingPolicy.js"() {
    init_process();
    init_buffer();
    init_browser2();
    init_constants2();
    init_userAgent();
    init_log2();
    init_browser4();
    init_restError();
    tracingPolicyName = "tracingPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/createPipelineFromOptions.js
function createPipelineFromOptions(options) {
  var _a3;
  const pipeline = createEmptyPipeline();
  if (isNodeLike) {
    if (options.tlsOptions) {
      pipeline.addPolicy(tlsPolicy(options.tlsOptions));
    }
    pipeline.addPolicy(proxyPolicy(options.proxyOptions));
    pipeline.addPolicy(decompressResponsePolicy());
  }
  pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });
  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));
  pipeline.addPolicy(setClientRequestIdPolicy((_a3 = options.telemetryOptions) === null || _a3 === void 0 ? void 0 : _a3.clientRequestIdHeaderName));
  pipeline.addPolicy(multipartPolicy(), { afterPhase: "Deserialize" });
  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: "Retry" });
  pipeline.addPolicy(tracingPolicy(options.userAgentOptions), { afterPhase: "Retry" });
  if (isNodeLike) {
    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: "Retry" });
  }
  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: "Sign" });
  return pipeline;
}
var init_createPipelineFromOptions = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/createPipelineFromOptions.js"() {
    init_process();
    init_buffer();
    init_logPolicy();
    init_pipeline();
    init_redirectPolicy();
    init_userAgentPolicy();
    init_multipartPolicy();
    init_decompressResponsePolicy();
    init_defaultRetryPolicy();
    init_formDataPolicy();
    init_browser4();
    init_proxyPolicy();
    init_setClientRequestIdPolicy();
    init_tlsPolicy();
    init_tracingPolicy();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/fetchHttpClient.js
function isBlob2(body) {
  return (typeof Blob === "function" || typeof Blob === "object") && body instanceof Blob;
}
async function makeRequest(request) {
  const { abortController, abortControllerCleanup } = setupAbortSignal(request);
  try {
    const headers = buildFetchHeaders(request.headers);
    const { streaming, body: requestBody } = buildRequestBody2(request);
    const requestInit = Object.assign(Object.assign({ body: requestBody, method: request.method, headers, signal: abortController.signal }, "credentials" in Request.prototype ? { credentials: request.withCredentials ? "include" : "same-origin" } : {}), "cache" in Request.prototype ? { cache: "no-store" } : {});
    if (streaming) {
      requestInit.duplex = "half";
    }
    const response = await fetch(request.url, requestInit);
    if (isBlob2(request.body) && request.onUploadProgress) {
      request.onUploadProgress({ loadedBytes: request.body.size });
    }
    return buildPipelineResponse(response, request, abortControllerCleanup);
  } catch (e) {
    abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
    throw e;
  }
}
async function buildPipelineResponse(httpResponse, request, abortControllerCleanup) {
  var _a3, _b2;
  const headers = buildPipelineHeaders(httpResponse);
  const response = {
    request,
    headers,
    status: httpResponse.status
  };
  const bodyStream = isWebReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, {
    onProgress: request.onDownloadProgress,
    onEnd: abortControllerCleanup
  }) : httpResponse.body;
  if (
    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
    ((_a3 = request.streamResponseStatusCodes) === null || _a3 === void 0 ? void 0 : _a3.has(Number.POSITIVE_INFINITY)) || ((_b2 = request.streamResponseStatusCodes) === null || _b2 === void 0 ? void 0 : _b2.has(response.status))
  ) {
    if (request.enableBrowserStreams) {
      response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : void 0;
    } else {
      const responseStream = new Response(bodyStream);
      response.blobBody = responseStream.blob();
      abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
    }
  } else {
    const responseStream = new Response(bodyStream);
    response.bodyAsText = await responseStream.text();
    abortControllerCleanup === null || abortControllerCleanup === void 0 ? void 0 : abortControllerCleanup();
  }
  return response;
}
function setupAbortSignal(request) {
  const abortController = new AbortController();
  let abortControllerCleanup;
  let abortListener;
  if (request.abortSignal) {
    if (request.abortSignal.aborted) {
      throw new AbortError3("The operation was aborted.");
    }
    abortListener = (event) => {
      if (event.type === "abort") {
        abortController.abort();
      }
    };
    request.abortSignal.addEventListener("abort", abortListener);
    abortControllerCleanup = () => {
      var _a3;
      if (abortListener) {
        (_a3 = request.abortSignal) === null || _a3 === void 0 ? void 0 : _a3.removeEventListener("abort", abortListener);
      }
    };
  }
  if (request.timeout > 0) {
    setTimeout(() => {
      abortController.abort();
    }, request.timeout);
  }
  return { abortController, abortControllerCleanup };
}
function getError(e, request) {
  var _a3;
  if (e && (e === null || e === void 0 ? void 0 : e.name) === "AbortError") {
    return e;
  } else {
    return new RestError(`Error sending request: ${e.message}`, {
      code: (_a3 = e === null || e === void 0 ? void 0 : e.code) !== null && _a3 !== void 0 ? _a3 : RestError.REQUEST_SEND_ERROR,
      request
    });
  }
}
function buildFetchHeaders(pipelineHeaders) {
  const headers = new Headers();
  for (const [name2, value] of pipelineHeaders) {
    headers.append(name2, value);
  }
  return headers;
}
function buildPipelineHeaders(httpResponse) {
  const responseHeaders = createHttpHeaders();
  for (const [name2, value] of httpResponse.headers) {
    responseHeaders.set(name2, value);
  }
  return responseHeaders;
}
function buildRequestBody2(request) {
  const body = typeof request.body === "function" ? request.body() : request.body;
  if (isNodeReadableStream(body)) {
    throw new Error("Node streams are not supported in browser environment.");
  }
  return isWebReadableStream(body) ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) } : { streaming: false, body };
}
function buildBodyStream(readableStream, options = {}) {
  let loadedBytes = 0;
  const { onProgress, onEnd } = options;
  if (isTransformStreamSupported(readableStream)) {
    return readableStream.pipeThrough(new TransformStream({
      transform(chunk, controller) {
        if (chunk === null) {
          controller.terminate();
          return;
        }
        controller.enqueue(chunk);
        loadedBytes += chunk.length;
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      },
      flush() {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      }
    }));
  } else {
    const reader = readableStream.getReader();
    return new ReadableStream({
      async pull(controller) {
        var _a3;
        const { done, value } = await reader.read();
        if (done || !value) {
          onEnd === null || onEnd === void 0 ? void 0 : onEnd();
          controller.close();
          reader.releaseLock();
          return;
        }
        loadedBytes += (_a3 = value === null || value === void 0 ? void 0 : value.length) !== null && _a3 !== void 0 ? _a3 : 0;
        controller.enqueue(value);
        if (onProgress) {
          onProgress({ loadedBytes });
        }
      },
      cancel(reason) {
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
        return reader.cancel(reason);
      }
    });
  }
}
function createFetchHttpClient() {
  return new FetchHttpClient();
}
function isTransformStreamSupported(readableStream) {
  return readableStream.pipeThrough !== void 0 && self.TransformStream !== void 0;
}
var FetchHttpClient;
var init_fetchHttpClient = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/fetchHttpClient.js"() {
    init_process();
    init_buffer();
    init_browser5();
    init_restError();
    init_httpHeaders();
    init_typeGuards2();
    FetchHttpClient = class {
      /**
       * Makes a request over an underlying transport layer and returns the response.
       * @param request - The request to be made.
       */
      async sendRequest(request) {
        const url = new URL(request.url);
        const isInsecure = url.protocol !== "https:";
        if (isInsecure && !request.allowInsecureConnection) {
          throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
        }
        if (request.proxySettings) {
          throw new Error("HTTP proxy is not supported in browser environment");
        }
        try {
          return await makeRequest(request);
        } catch (e) {
          throw getError(e, request);
        }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/defaultHttpClient.js
function createDefaultHttpClient() {
  return createFetchHttpClient();
}
var init_defaultHttpClient = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/defaultHttpClient.js"() {
    init_process();
    init_buffer();
    init_fetchHttpClient();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/pipelineRequest.js
function createPipelineRequest(options) {
  return new PipelineRequestImpl(options);
}
var PipelineRequestImpl;
var init_pipelineRequest = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/pipelineRequest.js"() {
    init_process();
    init_buffer();
    init_httpHeaders();
    init_browser4();
    PipelineRequestImpl = class {
      constructor(options) {
        var _a3, _b2, _c2, _d2, _e, _f, _g;
        this.url = options.url;
        this.body = options.body;
        this.headers = (_a3 = options.headers) !== null && _a3 !== void 0 ? _a3 : createHttpHeaders();
        this.method = (_b2 = options.method) !== null && _b2 !== void 0 ? _b2 : "GET";
        this.timeout = (_c2 = options.timeout) !== null && _c2 !== void 0 ? _c2 : 0;
        this.multipartBody = options.multipartBody;
        this.formData = options.formData;
        this.disableKeepAlive = (_d2 = options.disableKeepAlive) !== null && _d2 !== void 0 ? _d2 : false;
        this.proxySettings = options.proxySettings;
        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
        this.withCredentials = (_e = options.withCredentials) !== null && _e !== void 0 ? _e : false;
        this.abortSignal = options.abortSignal;
        this.tracingOptions = options.tracingOptions;
        this.onUploadProgress = options.onUploadProgress;
        this.onDownloadProgress = options.onDownloadProgress;
        this.requestId = options.requestId || randomUUID();
        this.allowInsecureConnection = (_f = options.allowInsecureConnection) !== null && _f !== void 0 ? _f : false;
        this.enableBrowserStreams = (_g = options.enableBrowserStreams) !== null && _g !== void 0 ? _g : false;
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/exponentialRetryPolicy.js
var init_exponentialRetryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/exponentialRetryPolicy.js"() {
    init_process();
    init_buffer();
    init_exponentialRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/systemErrorRetryPolicy.js
var init_systemErrorRetryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/systemErrorRetryPolicy.js"() {
    init_process();
    init_buffer();
    init_exponentialRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/throttlingRetryPolicy.js
var init_throttlingRetryPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/throttlingRetryPolicy.js"() {
    init_process();
    init_buffer();
    init_throttlingRetryStrategy();
    init_retryPolicy();
    init_constants2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/util/tokenCycler.js
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
  async function tryGetAccessToken() {
    if (Date.now() < refreshTimeout) {
      try {
        return await getAccessToken();
      } catch (_a3) {
        return null;
      }
    } else {
      const finalToken = await getAccessToken();
      if (finalToken === null) {
        throw new Error("Failed to refresh access token.");
      }
      return finalToken;
    }
  }
  let token = await tryGetAccessToken();
  while (token === null) {
    await delay2(retryIntervalInMs);
    token = await tryGetAccessToken();
  }
  return token;
}
function createTokenCycler(credential, tokenCyclerOptions) {
  let refreshWorker = null;
  let token = null;
  let tenantId;
  const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
  const cycler = {
    /**
     * Produces true if a refresh job is currently in progress.
     */
    get isRefreshing() {
      return refreshWorker !== null;
    },
    /**
     * Produces true if the cycler SHOULD refresh (we are within the refresh
     * window and not already refreshing)
     */
    get shouldRefresh() {
      var _a3;
      return !cycler.isRefreshing && ((_a3 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a3 !== void 0 ? _a3 : 0) - options.refreshWindowInMs < Date.now();
    },
    /**
     * Produces true if the cycler MUST refresh (null or nearly-expired
     * token).
     */
    get mustRefresh() {
      return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
    }
  };
  function refresh(scopes, getTokenOptions) {
    var _a3;
    if (!cycler.isRefreshing) {
      const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
      refreshWorker = beginRefresh(
        tryGetAccessToken,
        options.retryIntervalInMs,
        // If we don't have a token, then we should timeout immediately
        (_a3 = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a3 !== void 0 ? _a3 : Date.now()
      ).then((_token) => {
        refreshWorker = null;
        token = _token;
        tenantId = getTokenOptions.tenantId;
        return token;
      }).catch((reason) => {
        refreshWorker = null;
        token = null;
        tenantId = void 0;
        throw reason;
      });
    }
    return refreshWorker;
  }
  return async (scopes, tokenOptions) => {
    const mustRefresh = tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;
    if (mustRefresh)
      return refresh(scopes, tokenOptions);
    if (cycler.shouldRefresh) {
      refresh(scopes, tokenOptions);
    }
    return token;
  };
}
var DEFAULT_CYCLER_OPTIONS;
var init_tokenCycler = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/util/tokenCycler.js"() {
    init_process();
    init_buffer();
    init_helpers();
    DEFAULT_CYCLER_OPTIONS = {
      forcedRefreshWindowInMs: 1e3,
      // Force waiting for a refresh 1s before the token expires
      retryIntervalInMs: 3e3,
      // Allow refresh attempts every 3s
      refreshWindowInMs: 1e3 * 60 * 2
      // Start refreshing 2m before expiry
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/bearerTokenAuthenticationPolicy.js
async function defaultAuthorizeRequest(options) {
  const { scopes, getAccessToken, request } = options;
  const getTokenOptions = {
    abortSignal: request.abortSignal,
    tracingOptions: request.tracingOptions
  };
  const accessToken = await getAccessToken(scopes, getTokenOptions);
  if (accessToken) {
    options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
}
function getChallenge(response) {
  const challenge = response.headers.get("WWW-Authenticate");
  if (response.status === 401 && challenge) {
    return challenge;
  }
  return;
}
function bearerTokenAuthenticationPolicy(options) {
  var _a3;
  const { credential, scopes, challengeCallbacks } = options;
  const logger21 = options.logger || logger4;
  const callbacks = Object.assign({ authorizeRequest: (_a3 = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a3 !== void 0 ? _a3 : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);
  const getAccessToken = credential ? createTokenCycler(
    credential
    /* , options */
  ) : () => Promise.resolve(null);
  return {
    name: bearerTokenAuthenticationPolicyName,
    /**
     * If there's no challenge parameter:
     * - It will try to retrieve the token using the cache, or the credential's getToken.
     * - Then it will try the next policy with or without the retrieved token.
     *
     * It uses the challenge parameters to:
     * - Skip a first attempt to get the token from the credential if there's no cached token,
     *   since it expects the token to be retrievable only after the challenge.
     * - Prepare the outgoing request if the `prepareRequest` method has been provided.
     * - Send an initial request to receive the challenge if it fails.
     * - Process a challenge if the response contains it.
     * - Retrieve a token with the challenge information, then re-send the request.
     */
    async sendRequest(request, next) {
      if (!request.url.toLowerCase().startsWith("https://")) {
        throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
      }
      await callbacks.authorizeRequest({
        scopes: Array.isArray(scopes) ? scopes : [scopes],
        request,
        getAccessToken,
        logger: logger21
      });
      let response;
      let error;
      try {
        response = await next(request);
      } catch (err) {
        error = err;
        response = err.response;
      }
      if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {
        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request,
          response,
          getAccessToken,
          logger: logger21
        });
        if (shouldSendRequest) {
          return next(request);
        }
      }
      if (error) {
        throw error;
      } else {
        return response;
      }
    }
  };
}
var bearerTokenAuthenticationPolicyName;
var init_bearerTokenAuthenticationPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/bearerTokenAuthenticationPolicy.js"() {
    init_process();
    init_buffer();
    init_tokenCycler();
    init_log2();
    bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/ndJsonPolicy.js
var init_ndJsonPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/ndJsonPolicy.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/policies/auxiliaryAuthenticationHeaderPolicy.js
var init_auxiliaryAuthenticationHeaderPolicy = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/policies/auxiliaryAuthenticationHeaderPolicy.js"() {
    init_process();
    init_buffer();
    init_tokenCycler();
    init_log2();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/browser/index.js
var init_browser6 = __esm({
  "node_modules/@azure/core-rest-pipeline/dist/browser/index.js"() {
    init_process();
    init_buffer();
    init_pipeline();
    init_createPipelineFromOptions();
    init_defaultHttpClient();
    init_httpHeaders();
    init_pipelineRequest();
    init_restError();
    init_decompressResponsePolicy();
    init_exponentialRetryPolicy();
    init_setClientRequestIdPolicy();
    init_logPolicy();
    init_multipartPolicy();
    init_proxyPolicy();
    init_redirectPolicy();
    init_systemErrorRetryPolicy();
    init_throttlingRetryPolicy();
    init_retryPolicy();
    init_tracingPolicy();
    init_defaultRetryPolicy();
    init_userAgentPolicy();
    init_tlsPolicy();
    init_formDataPolicy();
    init_bearerTokenAuthenticationPolicy();
    init_ndJsonPolicy();
    init_auxiliaryAuthenticationHeaderPolicy();
    init_file();
  }
});

// node_modules/@azure/identity/dist-esm/src/util/processMultiTenantRequest.browser.js
function createConfigurationErrorMessage(tenantId) {
  return `The current credential is not configured to acquire tokens for tenant ${tenantId}. To enable acquiring tokens for this tenant add it to the AdditionallyAllowedTenants on the credential options, or add "*" to AdditionallyAllowedTenants to allow acquiring tokens for any tenant.`;
}
function processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds = []) {
  var _a3;
  let resolvedTenantId;
  if (tenantId === "adfs") {
    resolvedTenantId = tenantId;
  } else {
    resolvedTenantId = (_a3 = getTokenOptions === null || getTokenOptions === void 0 ? void 0 : getTokenOptions.tenantId) !== null && _a3 !== void 0 ? _a3 : tenantId;
  }
  if (tenantId && resolvedTenantId !== tenantId && !additionallyAllowedTenantIds.includes("*") && !additionallyAllowedTenantIds.some((t) => t.localeCompare(resolvedTenantId) === 0)) {
    throw new Error(createConfigurationErrorMessage(tenantId));
  }
  return resolvedTenantId;
}
var init_processMultiTenantRequest_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/processMultiTenantRequest.browser.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/identity/dist-esm/src/util/tenantIdUtils.js
function checkTenantId(logger21, tenantId) {
  if (!tenantId.match(/^[0-9a-zA-Z-.]+$/)) {
    const error = new Error("Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://learn.microsoft.com/partner-center/find-ids-and-domain-names.");
    logger21.info(formatError("", error));
    throw error;
  }
}
function resolveTenantId(logger21, tenantId, clientId) {
  if (tenantId) {
    checkTenantId(logger21, tenantId);
    return tenantId;
  }
  if (!clientId) {
    clientId = DeveloperSignOnClientId;
  }
  if (clientId !== DeveloperSignOnClientId) {
    return "common";
  }
  return "organizations";
}
function resolveAdditionallyAllowedTenantIds(additionallyAllowedTenants) {
  if (!additionallyAllowedTenants || additionallyAllowedTenants.length === 0) {
    return [];
  }
  if (additionallyAllowedTenants.includes("*")) {
    return ALL_TENANTS;
  }
  return additionallyAllowedTenants;
}
var init_tenantIdUtils = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/tenantIdUtils.js"() {
    init_process();
    init_buffer();
    init_constants();
    init_logging();
    init_processMultiTenantRequest_browser();
  }
});

// node_modules/@azure/core-client/dist/browser/base64.js
var init_base64 = __esm({
  "node_modules/@azure/core-client/dist/browser/base64.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-client/dist/browser/interfaces.js
var XML_ATTRKEY, XML_CHARKEY;
var init_interfaces = __esm({
  "node_modules/@azure/core-client/dist/browser/interfaces.js"() {
    init_process();
    init_buffer();
    XML_ATTRKEY = "$";
    XML_CHARKEY = "_";
  }
});

// node_modules/@azure/core-client/dist/browser/utils.js
function isPrimitiveBody(value, mapperTypeName) {
  return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === void 0 || value === null);
}
function handleNullableResponseAndWrappableBody(responseObject) {
  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
    return responseObject.shouldWrapBody ? { body: null } : null;
  } else {
    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
  }
}
function flattenResponse(fullResponse, responseSpec) {
  var _a3, _b2;
  const parsedHeaders = fullResponse.parsedHeaders;
  if (fullResponse.request.method === "HEAD") {
    return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
  }
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
  if (expectedBodyTypeName === "Stream") {
    return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
  }
  const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
  const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
  if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
    const arrayResponse = (_a3 = fullResponse.parsedBody) !== null && _a3 !== void 0 ? _a3 : [];
    for (const key of Object.keys(modelProperties)) {
      if (modelProperties[key].serializedName) {
        arrayResponse[key] = (_b2 = fullResponse.parsedBody) === null || _b2 === void 0 ? void 0 : _b2[key];
      }
    }
    if (parsedHeaders) {
      for (const key of Object.keys(parsedHeaders)) {
        arrayResponse[key] = parsedHeaders[key];
      }
    }
    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
  }
  return handleNullableResponseAndWrappableBody({
    body: fullResponse.parsedBody,
    headers: parsedHeaders,
    hasNullableType: isNullable,
    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
  });
}
var init_utils = __esm({
  "node_modules/@azure/core-client/dist/browser/utils.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-client/dist/browser/serializer.js
var MapperTypeNames;
var init_serializer = __esm({
  "node_modules/@azure/core-client/dist/browser/serializer.js"() {
    init_process();
    init_buffer();
    init_base64();
    init_interfaces();
    init_utils();
    MapperTypeNames = {
      Base64Url: "Base64Url",
      Boolean: "Boolean",
      ByteArray: "ByteArray",
      Composite: "Composite",
      Date: "Date",
      DateTime: "DateTime",
      DateTimeRfc1123: "DateTimeRfc1123",
      Dictionary: "Dictionary",
      Enum: "Enum",
      Number: "Number",
      Object: "Object",
      Sequence: "Sequence",
      String: "String",
      Stream: "Stream",
      TimeSpan: "TimeSpan",
      UnixTime: "UnixTime"
    };
  }
});

// node_modules/@azure/core-client/dist/browser/state.js
var state2;
var init_state2 = __esm({
  "node_modules/@azure/core-client/dist/browser/state.js"() {
    init_process();
    init_buffer();
    state2 = {
      operationRequestMap: /* @__PURE__ */ new WeakMap()
    };
  }
});

// node_modules/@azure/core-client/dist/browser/operationHelpers.js
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
  let parameterPath = parameter.parameterPath;
  const parameterMapper = parameter.mapper;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound && fallbackObject) {
          propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
        parameterPath: propertyPath,
        mapper: propertyMapper
      }, fallbackObject);
      if (propertyValue !== void 0) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
function hasOriginalRequest(request) {
  return originalRequestSymbol in request;
}
function getOperationRequestInfo(request) {
  if (hasOriginalRequest(request)) {
    return getOperationRequestInfo(request[originalRequestSymbol]);
  }
  let info = state2.operationRequestMap.get(request);
  if (!info) {
    info = {};
    state2.operationRequestMap.set(request, info);
  }
  return info;
}
var originalRequestSymbol;
var init_operationHelpers = __esm({
  "node_modules/@azure/core-client/dist/browser/operationHelpers.js"() {
    init_process();
    init_buffer();
    init_state2();
    originalRequestSymbol = Symbol.for("@azure/core-client original request");
  }
});

// node_modules/@azure/core-client/dist/browser/deserializationPolicy.js
function deserializationPolicy(options = {}) {
  var _a3, _b2, _c2, _d2, _e, _f, _g;
  const jsonContentTypes = (_b2 = (_a3 = options.expectedContentTypes) === null || _a3 === void 0 ? void 0 : _a3.json) !== null && _b2 !== void 0 ? _b2 : defaultJsonContentTypes;
  const xmlContentTypes = (_d2 = (_c2 = options.expectedContentTypes) === null || _c2 === void 0 ? void 0 : _c2.xml) !== null && _d2 !== void 0 ? _d2 : defaultXmlContentTypes;
  const parseXML = options.parseXML;
  const serializerOptions = options.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY
    }
  };
  return {
    name: deserializationPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
    }
  };
}
function getOperationResponseMap(parsedResponse) {
  let result;
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (operationSpec) {
    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse(parsedResponse) {
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
  const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
  if (!shouldDeserializeResponse(parsedResponse)) {
    return parsedResponse;
  }
  const operationInfo = getOperationRequestInfo(parsedResponse.request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (!operationSpec || !operationSpec.responses) {
    return parsedResponse;
  }
  const responseSpec = getOperationResponseMap(parsedResponse);
  const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
  if (error) {
    throw error;
  } else if (shouldReturnResponse) {
    return parsedResponse;
  }
  if (responseSpec) {
    if (responseSpec.bodyMapper) {
      let valueToDeserialize = parsedResponse.parsedBody;
      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {
        valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
      }
      try {
        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
      } catch (deserializeError) {
        const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
          statusCode: parsedResponse.status,
          request: parsedResponse.request,
          response: parsedResponse
        });
        throw restError;
      }
    } else if (operationSpec.httpMethod === "HEAD") {
      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
    }
    if (responseSpec.headersMapper) {
      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
    }
  }
  return parsedResponse;
}
function isOperationSpecEmpty(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
  var _a3;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  const initialErrorMessage = ((_a3 = parsedResponse.request.streamResponseStatusCodes) === null || _a3 === void 0 ? void 0 : _a3.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error = new RestError(initialErrorMessage, {
    statusCode: parsedResponse.status,
    request: parsedResponse.request,
    response: parsedResponse
  });
  if (!errorResponseSpec) {
    throw error;
  }
  const defaultBodyMapper = errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let deserializedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {
          valueToDeserialize = [];
          const elementName = defaultBodyMapper.xmlElementName;
          if (typeof parsedBody === "object" && elementName) {
            valueToDeserialize = parsedBody[elementName];
          }
        }
        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
      }
      const internalError = parsedBody.error || deserializedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = deserializedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error, shouldReturnResponse: false };
}
async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
  var _a3;
  if (!((_a3 = operationResponse.request.streamResponseStatusCodes) === null || _a3 === void 0 ? void 0 : _a3.has(operationResponse.status)) && operationResponse.bodyAsText) {
    const text = operationResponse.bodyAsText;
    const contentType = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
    try {
      if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
        operationResponse.parsedBody = JSON.parse(text);
        return operationResponse;
      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
        if (!parseXML) {
          throw new Error("Parsing XML not supported.");
        }
        const body = await parseXML(text, opts.xml);
        operationResponse.parsedBody = body;
        return operationResponse;
      }
    } catch (err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
      const errCode = err.code || RestError.PARSE_ERROR;
      const e = new RestError(msg, {
        code: errCode,
        statusCode: operationResponse.status,
        request: operationResponse.request,
        response: operationResponse
      });
      throw e;
    }
  }
  return operationResponse;
}
var defaultJsonContentTypes, defaultXmlContentTypes, deserializationPolicyName;
var init_deserializationPolicy = __esm({
  "node_modules/@azure/core-client/dist/browser/deserializationPolicy.js"() {
    init_process();
    init_buffer();
    init_interfaces();
    init_browser6();
    init_serializer();
    init_operationHelpers();
    defaultJsonContentTypes = ["application/json", "text/json"];
    defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
    deserializationPolicyName = "deserializationPolicy";
  }
});

// node_modules/@azure/core-client/dist/browser/interfaceHelpers.js
function getStreamingResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
function getPathStringFromParameter(parameter) {
  const { parameterPath, mapper } = parameter;
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}
var init_interfaceHelpers = __esm({
  "node_modules/@azure/core-client/dist/browser/interfaceHelpers.js"() {
    init_process();
    init_buffer();
    init_serializer();
  }
});

// node_modules/@azure/core-client/dist/browser/serializationPolicy.js
function serializationPolicy(options = {}) {
  const stringifyXML = options.stringifyXML;
  return {
    name: serializationPolicyName,
    async sendRequest(request, next) {
      const operationInfo = getOperationRequestInfo(request);
      const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
      const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
      if (operationSpec && operationArguments) {
        serializeHeaders(request, operationArguments, operationSpec);
        serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
      }
      return next(request);
    }
  };
}
function serializeHeaders(request, operationArguments, operationSpec) {
  var _a3, _b2;
  if (operationSpec.headerParameters) {
    for (const headerParameter of operationSpec.headerParameters) {
      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);
      if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));
        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          for (const key of Object.keys(headerValue)) {
            request.headers.set(headerCollectionPrefix + key, headerValue[key]);
          }
        } else {
          request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
        }
      }
    }
  }
  const customHeaders = (_b2 = (_a3 = operationArguments.options) === null || _a3 === void 0 ? void 0 : _a3.requestOptions) === null || _b2 === void 0 ? void 0 : _b2.customHeaders;
  if (customHeaders) {
    for (const customHeaderName of Object.keys(customHeaders)) {
      request.headers.set(customHeaderName, customHeaders[customHeaderName]);
    }
  }
}
function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function() {
  throw new Error("XML serialization unsupported!");
}) {
  var _a3, _b2, _c2, _d2, _e;
  const serializerOptions = (_a3 = operationArguments.options) === null || _a3 === void 0 ? void 0 : _a3.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_b2 = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b2 !== void 0 ? _b2 : "",
      includeRoot: (_c2 = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c2 !== void 0 ? _c2 : false,
      xmlCharKey: (_d2 = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d2 !== void 0 ? _d2 : XML_CHARKEY
    }
  };
  const xmlCharKey = updatedOptions.xml.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (request.body !== void 0 && request.body !== null || nullable && request.body === null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperTypeNames.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
          if (typeName === MapperTypeNames.Sequence) {
            request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
          } else if (!isStream) {
            request.body = stringifyXML(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          request.body = JSON.stringify(request.body);
        }
      }
    } catch (error) {
      throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    request.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj };
  }
  const result = { [elementName]: obj };
  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}
var serializationPolicyName;
var init_serializationPolicy = __esm({
  "node_modules/@azure/core-client/dist/browser/serializationPolicy.js"() {
    init_process();
    init_buffer();
    init_interfaces();
    init_operationHelpers();
    init_serializer();
    init_interfaceHelpers();
    serializationPolicyName = "serializationPolicy";
  }
});

// node_modules/@azure/core-client/dist/browser/pipeline.js
function createClientPipeline(options = {}) {
  const pipeline = createPipelineFromOptions(options !== null && options !== void 0 ? options : {});
  if (options.credentialOptions) {
    pipeline.addPolicy(bearerTokenAuthenticationPolicy({
      credential: options.credentialOptions.credential,
      scopes: options.credentialOptions.credentialScopes
    }));
  }
  pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: "Serialize" });
  pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {
    phase: "Deserialize"
  });
  return pipeline;
}
var init_pipeline2 = __esm({
  "node_modules/@azure/core-client/dist/browser/pipeline.js"() {
    init_process();
    init_buffer();
    init_deserializationPolicy();
    init_browser6();
    init_serializationPolicy();
  }
});

// node_modules/@azure/core-client/dist/browser/httpClientCache.js
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}
var cachedHttpClient;
var init_httpClientCache = __esm({
  "node_modules/@azure/core-client/dist/browser/httpClientCache.js"() {
    init_process();
    init_buffer();
    init_browser6();
  }
});

// node_modules/@azure/core-client/dist/browser/urlHelpers.js
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
  let isAbsolutePath = false;
  let requestUrl = replaceAll(baseUri, urlReplacements);
  if (operationSpec.path) {
    let path = replaceAll(operationSpec.path, urlReplacements);
    if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
      path = path.substring(1);
    }
    if (isAbsoluteUrl(path)) {
      requestUrl = path;
      isAbsolutePath = true;
    } else {
      requestUrl = appendPath(requestUrl, path);
    }
  }
  const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
  return requestUrl;
}
function replaceAll(input, replacements) {
  let result = input;
  for (const [searchValue, replaceValue] of replacements) {
    result = result.split(searchValue).join(replaceValue);
  }
  return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
  var _a3;
  const result = /* @__PURE__ */ new Map();
  if ((_a3 = operationSpec.urlParameters) === null || _a3 === void 0 ? void 0 : _a3.length) {
    for (const urlParameter of operationSpec.urlParameters) {
      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);
      const parameterPathString = getPathStringFromParameter(urlParameter);
      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
      if (!urlParameter.skipEncoding) {
        urlParameterValue = encodeURIComponent(urlParameterValue);
      }
      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
    }
  }
  return result;
}
function isAbsoluteUrl(url) {
  return url.includes("://");
}
function appendPath(url, pathToAppend) {
  if (!pathToAppend) {
    return url;
  }
  const parsedUrl = new URL(url);
  let newPath = parsedUrl.pathname;
  if (!newPath.endsWith("/")) {
    newPath = `${newPath}/`;
  }
  if (pathToAppend.startsWith("/")) {
    pathToAppend = pathToAppend.substring(1);
  }
  const searchStart = pathToAppend.indexOf("?");
  if (searchStart !== -1) {
    const path = pathToAppend.substring(0, searchStart);
    const search = pathToAppend.substring(searchStart + 1);
    newPath = newPath + path;
    if (search) {
      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    }
  } else {
    newPath = newPath + pathToAppend;
  }
  parsedUrl.pathname = newPath;
  return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
  var _a3;
  const result = /* @__PURE__ */ new Map();
  const sequenceParams = /* @__PURE__ */ new Set();
  if ((_a3 = operationSpec.queryParameters) === null || _a3 === void 0 ? void 0 : _a3.length) {
    for (const queryParameter of operationSpec.queryParameters) {
      if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
        sequenceParams.add(queryParameter.mapper.serializedName);
      }
      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);
      if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));
        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
        if (Array.isArray(queryParameterValue)) {
          queryParameterValue = queryParameterValue.map((item) => {
            if (item === null || item === void 0) {
              return "";
            }
            return item;
          });
        }
        if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
          continue;
        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        if (!queryParameter.skipEncoding) {
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              return encodeURIComponent(item);
            });
          } else {
            queryParameterValue = encodeURIComponent(queryParameterValue);
          }
        }
        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
      }
    }
  }
  return {
    queryParams: result,
    sequenceParams
  };
}
function simpleParseQueryParams(queryString) {
  const result = /* @__PURE__ */ new Map();
  if (!queryString || queryString[0] !== "?") {
    return result;
  }
  queryString = queryString.slice(1);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [name2, value] = pair.split("=", 2);
    const existingValue = result.get(name2);
    if (existingValue) {
      if (Array.isArray(existingValue)) {
        existingValue.push(value);
      } else {
        result.set(name2, [existingValue, value]);
      }
    } else {
      result.set(name2, value);
    }
  }
  return result;
}
function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
  if (queryParams.size === 0) {
    return url;
  }
  const parsedUrl = new URL(url);
  const combinedParams = simpleParseQueryParams(parsedUrl.search);
  for (const [name2, value] of queryParams) {
    const existingValue = combinedParams.get(name2);
    if (Array.isArray(existingValue)) {
      if (Array.isArray(value)) {
        existingValue.push(...value);
        const valueSet = new Set(existingValue);
        combinedParams.set(name2, Array.from(valueSet));
      } else {
        existingValue.push(value);
      }
    } else if (existingValue) {
      if (Array.isArray(value)) {
        value.unshift(existingValue);
      } else if (sequenceParams.has(name2)) {
        combinedParams.set(name2, [existingValue, value]);
      }
      if (!noOverwrite) {
        combinedParams.set(name2, value);
      }
    } else {
      combinedParams.set(name2, value);
    }
  }
  const searchPieces = [];
  for (const [name2, value] of combinedParams) {
    if (typeof value === "string") {
      searchPieces.push(`${name2}=${value}`);
    } else if (Array.isArray(value)) {
      for (const subValue of value) {
        searchPieces.push(`${name2}=${subValue}`);
      }
    } else {
      searchPieces.push(`${name2}=${value}`);
    }
  }
  parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return parsedUrl.toString();
}
var CollectionFormatToDelimiterMap;
var init_urlHelpers = __esm({
  "node_modules/@azure/core-client/dist/browser/urlHelpers.js"() {
    init_process();
    init_buffer();
    init_operationHelpers();
    init_interfaceHelpers();
    CollectionFormatToDelimiterMap = {
      CSV: ",",
      SSV: " ",
      Multi: "Multi",
      TSV: "	",
      Pipes: "|"
    };
  }
});

// node_modules/@azure/core-client/dist/browser/log.js
var logger5;
var init_log3 = __esm({
  "node_modules/@azure/core-client/dist/browser/log.js"() {
    init_process();
    init_buffer();
    init_browser();
    logger5 = createClientLogger("core-client");
  }
});

// node_modules/@azure/core-client/dist/browser/serviceClient.js
function createDefaultPipeline(options) {
  const credentialScopes = getCredentialScopes(options);
  const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
  return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));
}
function getCredentialScopes(options) {
  if (options.credentialScopes) {
    return options.credentialScopes;
  }
  if (options.endpoint) {
    return `${options.endpoint}/.default`;
  }
  if (options.baseUri) {
    return `${options.baseUri}/.default`;
  }
  if (options.credential && !options.credentialScopes) {
    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
  }
  return void 0;
}
var ServiceClient;
var init_serviceClient = __esm({
  "node_modules/@azure/core-client/dist/browser/serviceClient.js"() {
    init_process();
    init_buffer();
    init_browser6();
    init_pipeline2();
    init_utils();
    init_httpClientCache();
    init_operationHelpers();
    init_urlHelpers();
    init_interfaceHelpers();
    init_log3();
    ServiceClient = class {
      /**
       * The ServiceClient constructor
       * @param credential - The credentials used for authentication with the service.
       * @param options - The service client options that govern the behavior of the client.
       */
      constructor(options = {}) {
        var _a3, _b2;
        this._requestContentType = options.requestContentType;
        this._endpoint = (_a3 = options.endpoint) !== null && _a3 !== void 0 ? _a3 : options.baseUri;
        if (options.baseUri) {
          logger5.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
        }
        this._allowInsecureConnection = options.allowInsecureConnection;
        this._httpClient = options.httpClient || getCachedDefaultHttpClient();
        this.pipeline = options.pipeline || createDefaultPipeline(options);
        if ((_b2 = options.additionalPolicies) === null || _b2 === void 0 ? void 0 : _b2.length) {
          for (const { policy, position } of options.additionalPolicies) {
            const afterPhase = position === "perRetry" ? "Sign" : void 0;
            this.pipeline.addPolicy(policy, {
              afterPhase
            });
          }
        }
      }
      /**
       * Send the provided httpRequest.
       */
      async sendRequest(request) {
        return this.pipeline.sendRequest(this._httpClient, request);
      }
      /**
       * Send an HTTP request that is populated using the provided OperationSpec.
       * @typeParam T - The typed result of the request, based on the OperationSpec.
       * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
       * @param operationSpec - The OperationSpec to use to populate the httpRequest.
       */
      async sendOperationRequest(operationArguments, operationSpec) {
        const endpoint = operationSpec.baseUrl || this._endpoint;
        if (!endpoint) {
          throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
        }
        const url = getRequestUrl(endpoint, operationSpec, operationArguments, this);
        const request = createPipelineRequest({
          url
        });
        request.method = operationSpec.httpMethod;
        const operationInfo = getOperationRequestInfo(request);
        operationInfo.operationSpec = operationSpec;
        operationInfo.operationArguments = operationArguments;
        const contentType = operationSpec.contentType || this._requestContentType;
        if (contentType && operationSpec.requestBody) {
          request.headers.set("Content-Type", contentType);
        }
        const options = operationArguments.options;
        if (options) {
          const requestOptions = options.requestOptions;
          if (requestOptions) {
            if (requestOptions.timeout) {
              request.timeout = requestOptions.timeout;
            }
            if (requestOptions.onUploadProgress) {
              request.onUploadProgress = requestOptions.onUploadProgress;
            }
            if (requestOptions.onDownloadProgress) {
              request.onDownloadProgress = requestOptions.onDownloadProgress;
            }
            if (requestOptions.shouldDeserialize !== void 0) {
              operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
            }
            if (requestOptions.allowInsecureConnection) {
              request.allowInsecureConnection = true;
            }
          }
          if (options.abortSignal) {
            request.abortSignal = options.abortSignal;
          }
          if (options.tracingOptions) {
            request.tracingOptions = options.tracingOptions;
          }
        }
        if (this._allowInsecureConnection) {
          request.allowInsecureConnection = true;
        }
        if (request.streamResponseStatusCodes === void 0) {
          request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);
        }
        try {
          const rawResponse = await this.sendRequest(request);
          const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);
          if (options === null || options === void 0 ? void 0 : options.onResponse) {
            options.onResponse(rawResponse, flatResponse);
          }
          return flatResponse;
        } catch (error) {
          if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
            const rawResponse = error.response;
            const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
            error.details = flatResponse;
            if (options === null || options === void 0 ? void 0 : options.onResponse) {
              options.onResponse(rawResponse, flatResponse, error);
            }
          }
          throw error;
        }
      }
    };
  }
});

// node_modules/@azure/core-client/dist/browser/authorizeRequestOnClaimChallenge.js
var init_authorizeRequestOnClaimChallenge = __esm({
  "node_modules/@azure/core-client/dist/browser/authorizeRequestOnClaimChallenge.js"() {
    init_process();
    init_buffer();
    init_log3();
    init_base64();
  }
});

// node_modules/@azure/core-client/dist/browser/authorizeRequestOnTenantChallenge.js
var init_authorizeRequestOnTenantChallenge = __esm({
  "node_modules/@azure/core-client/dist/browser/authorizeRequestOnTenantChallenge.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/core-client/dist/browser/index.js
var init_browser7 = __esm({
  "node_modules/@azure/core-client/dist/browser/index.js"() {
    init_process();
    init_buffer();
    init_serializer();
    init_serviceClient();
    init_pipeline2();
    init_interfaces();
    init_deserializationPolicy();
    init_serializationPolicy();
    init_authorizeRequestOnClaimChallenge();
    init_authorizeRequestOnTenantChallenge();
  }
});

// node_modules/@azure/identity/dist-esm/src/util/identityTokenEndpoint.js
function getIdentityTokenEndpointSuffix(tenantId) {
  if (tenantId === "adfs") {
    return "oauth2/token";
  } else {
    return "oauth2/v2.0/token";
  }
}
var init_identityTokenEndpoint = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/identityTokenEndpoint.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/constants.js
var init_constants3 = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/constants.js"() {
    init_process();
    init_buffer();
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/utils.js
function parseExpirationTimestamp(body) {
  if (typeof body.expires_on === "number") {
    return body.expires_on * 1e3;
  }
  if (typeof body.expires_on === "string") {
    const asNumber = +body.expires_on;
    if (!isNaN(asNumber)) {
      return asNumber * 1e3;
    }
    const asDate = Date.parse(body.expires_on);
    if (!isNaN(asDate)) {
      return asDate;
    }
  }
  if (typeof body.expires_in === "number") {
    return Date.now() + body.expires_in * 1e3;
  }
  throw new Error(`Failed to parse token expiration from body. expires_in="${body.expires_in}", expires_on="${body.expires_on}"`);
}
var init_utils2 = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/utils.js"() {
    init_process();
    init_buffer();
    init_constants3();
  }
});

// node_modules/@azure/identity/dist-esm/src/client/identityClient.js
function getIdentityClientAuthorityHost(options) {
  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;
  if (isNode) {
    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;
  }
  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;
}
var noCorrelationId, IdentityClient;
var init_identityClient = __esm({
  "node_modules/@azure/identity/dist-esm/src/client/identityClient.js"() {
    init_process();
    init_buffer();
    init_browser7();
    init_browser4();
    init_browser6();
    init_src();
    init_errors();
    init_identityTokenEndpoint();
    init_constants();
    init_tracing();
    init_logging();
    init_utils2();
    noCorrelationId = "noCorrelationId";
    IdentityClient = class extends ServiceClient {
      constructor(options) {
        var _a3, _b2;
        const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;
        const userAgentPrefix = ((_a3 = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a3 === void 0 ? void 0 : _a3.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
        const baseUri = getIdentityClientAuthorityHost(options);
        if (!baseUri.startsWith("https:")) {
          throw new Error("The authorityHost address must use the 'https' protocol.");
        }
        super(Object.assign(Object.assign({ requestContentType: "application/json; charset=utf-8", retryOptions: {
          maxRetries: 3
        } }, options), { userAgentOptions: {
          userAgentPrefix
        }, baseUri }));
        this.authorityHost = baseUri;
        this.abortControllers = /* @__PURE__ */ new Map();
        this.allowLoggingAccountIdentifiers = (_b2 = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b2 === void 0 ? void 0 : _b2.allowLoggingAccountIdentifiers;
        this.tokenCredentialOptions = Object.assign({}, options);
      }
      async sendTokenRequest(request) {
        logger.info(`IdentityClient: sending token request to [${request.url}]`);
        const response = await this.sendRequest(request);
        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {
          const parsedBody = JSON.parse(response.bodyAsText);
          if (!parsedBody.access_token) {
            return null;
          }
          this.logIdentifiers(response);
          const token = {
            accessToken: {
              token: parsedBody.access_token,
              expiresOnTimestamp: parseExpirationTimestamp(parsedBody)
            },
            refreshToken: parsedBody.refresh_token
          };
          logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
          return token;
        } else {
          const error = new AuthenticationError(response.status, response.bodyAsText);
          logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
          throw error;
        }
      }
      async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, options = {}) {
        if (refreshToken === void 0) {
          return null;
        }
        logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
        const refreshParams = {
          grant_type: "refresh_token",
          client_id: clientId,
          refresh_token: refreshToken,
          scope: scopes
        };
        if (clientSecret !== void 0) {
          refreshParams.client_secret = clientSecret;
        }
        const query = new URLSearchParams(refreshParams);
        return tracingClient.withSpan("IdentityClient.refreshAccessToken", options, async (updatedOptions) => {
          try {
            const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);
            const request = createPipelineRequest({
              url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,
              method: "POST",
              body: query.toString(),
              abortSignal: options.abortSignal,
              headers: createHttpHeaders({
                Accept: "application/json",
                "Content-Type": "application/x-www-form-urlencoded"
              }),
              tracingOptions: updatedOptions.tracingOptions
            });
            const response = await this.sendTokenRequest(request);
            logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
            return response;
          } catch (err) {
            if (err.name === AuthenticationErrorName && err.errorResponse.error === "interaction_required") {
              logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);
              return null;
            } else {
              logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
              throw err;
            }
          }
        });
      }
      // Here is a custom layer that allows us to abort requests that go through MSAL,
      // since MSAL doesn't allow us to pass options all the way through.
      generateAbortSignal(correlationId) {
        const controller = new AbortController2();
        const controllers = this.abortControllers.get(correlationId) || [];
        controllers.push(controller);
        this.abortControllers.set(correlationId, controllers);
        const existingOnAbort = controller.signal.onabort;
        controller.signal.onabort = (...params) => {
          this.abortControllers.set(correlationId, void 0);
          if (existingOnAbort) {
            existingOnAbort(...params);
          }
        };
        return controller.signal;
      }
      abortRequests(correlationId) {
        const key = correlationId || noCorrelationId;
        const controllers = [
          ...this.abortControllers.get(key) || [],
          // MSAL passes no correlation ID to the get requests...
          ...this.abortControllers.get(noCorrelationId) || []
        ];
        if (!controllers.length) {
          return;
        }
        for (const controller of controllers) {
          controller.abort();
        }
        this.abortControllers.set(key, void 0);
      }
      getCorrelationId(options) {
        var _a3;
        const parameter = (_a3 = options === null || options === void 0 ? void 0 : options.body) === null || _a3 === void 0 ? void 0 : _a3.split("&").map((part) => part.split("=")).find(([key]) => key === "client-request-id");
        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;
      }
      // The MSAL network module methods follow
      async sendGetRequestAsync(url, options) {
        const request = createPipelineRequest({
          url,
          method: "GET",
          body: options === null || options === void 0 ? void 0 : options.body,
          headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
          abortSignal: this.generateAbortSignal(noCorrelationId)
        });
        const response = await this.sendRequest(request);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      async sendPostRequestAsync(url, options) {
        const request = createPipelineRequest({
          url,
          method: "POST",
          body: options === null || options === void 0 ? void 0 : options.body,
          headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),
          // MSAL doesn't send the correlation ID on the get requests.
          abortSignal: this.generateAbortSignal(this.getCorrelationId(options))
        });
        const response = await this.sendRequest(request);
        this.logIdentifiers(response);
        return {
          body: response.bodyAsText ? JSON.parse(response.bodyAsText) : void 0,
          headers: response.headers.toJSON(),
          status: response.status
        };
      }
      /**
       *
       * @internal
       */
      getTokenCredentialOptions() {
        return this.tokenCredentialOptions;
      }
      /**
       * If allowLoggingAccountIdentifiers was set on the constructor options
       * we try to log the account identifiers by parsing the received access token.
       *
       * The account identifiers we try to log are:
       * - `appid`: The application or Client Identifier.
       * - `upn`: User Principal Name.
       *   - It might not be available in some authentication scenarios.
       *   - If it's not available, we put a placeholder: "No User Principal Name available".
       * - `tid`: Tenant Identifier.
       * - `oid`: Object Identifier of the authenticated user.
       */
      logIdentifiers(response) {
        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {
          return;
        }
        const unavailableUpn = "No User Principal Name available";
        try {
          const parsed = response.parsedBody || JSON.parse(response.bodyAsText);
          const accessToken = parsed.access_token;
          if (!accessToken) {
            return;
          }
          const base64Metadata = accessToken.split(".")[1];
          const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, "base64").toString("utf8"));
          logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);
        } catch (e) {
          logger.warning("allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:", e.message);
        }
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/clientSecretCredential.browser.js
var logger6, ClientSecretCredential;
var init_clientSecretCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/clientSecretCredential.browser.js"() {
    init_process();
    init_buffer();
    init_browser6();
    init_logging();
    init_tenantIdUtils();
    init_identityClient();
    init_identityTokenEndpoint();
    init_tracing();
    logger6 = credentialLogger("ClientSecretCredential");
    ClientSecretCredential = class {
      /**
       * Creates an instance of the ClientSecretCredential with the details
       * needed to authenticate against Azure Active Directory with a client
       * secret.
       *
       * @param tenantId - The Azure Active Directory tenant (directory) ID.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param clientSecret - A client secret that was generated for the App Registration.
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantId, clientId, clientSecret, options) {
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.clientId = clientId;
        this.clientSecret = clientSecret;
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if
       * successful.  If authentication cannot be performed at this time, this method may
       * return null.  If an error occurs during authentication, an {@link AuthenticationError}
       * containing failure details will be thrown.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);
          const query = new URLSearchParams({
            response_type: "token",
            grant_type: "client_credentials",
            client_id: this.clientId,
            client_secret: this.clientSecret,
            scope: typeof scopes === "string" ? scopes : scopes.join(" ")
          });
          try {
            const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);
            const request = createPipelineRequest({
              url: `${this.identityClient.authorityHost}/${tenantId}/${urlSuffix}`,
              method: "POST",
              body: query.toString(),
              headers: createHttpHeaders({
                Accept: "application/json",
                "Content-Type": "application/x-www-form-urlencoded"
              }),
              abortSignal: options && options.abortSignal,
              tracingOptions: newOptions === null || newOptions === void 0 ? void 0 : newOptions.tracingOptions
            });
            const tokenResponse = await this.identityClient.sendTokenRequest(request);
            logger6.getToken.info(formatSuccess(scopes));
            return tokenResponse && tokenResponse.accessToken || null;
          } catch (err) {
            logger6.getToken.info(formatError(scopes, err));
            throw err;
          }
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/environmentCredential.browser.js
var BrowserNotSupportedError2, logger7, EnvironmentCredential;
var init_environmentCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/environmentCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError2 = new Error("EnvironmentCredential is not supported in the browser.");
    logger7 = credentialLogger("EnvironmentCredential");
    EnvironmentCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger7.info(formatError("", BrowserNotSupportedError2));
        throw BrowserNotSupportedError2;
      }
      getToken() {
        logger7.getToken.info(formatError("", BrowserNotSupportedError2));
        throw BrowserNotSupportedError2;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/clientCertificateCredential.browser.js
var BrowserNotSupportedError3, logger8, ClientCertificateCredential;
var init_clientCertificateCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/clientCertificateCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError3 = new Error("ClientCertificateCredential is not supported in the browser.");
    logger8 = credentialLogger("ClientCertificateCredential");
    ClientCertificateCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger8.info(formatError("", BrowserNotSupportedError3));
        throw BrowserNotSupportedError3;
      }
      getToken() {
        logger8.getToken.info(formatError("", BrowserNotSupportedError3));
        throw BrowserNotSupportedError3;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/clientAssertionCredential.browser.js
var BrowserNotSupportedError4, logger9, ClientAssertionCredential;
var init_clientAssertionCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/clientAssertionCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError4 = new Error("ClientAssertionCredential is not supported in the browser.");
    logger9 = credentialLogger("ClientAssertionCredential");
    ClientAssertionCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger9.info(formatError("", BrowserNotSupportedError4));
        throw BrowserNotSupportedError4;
      }
      getToken() {
        logger9.getToken.info(formatError("", BrowserNotSupportedError4));
        throw BrowserNotSupportedError4;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/azureCliCredential.browser.js
var BrowserNotSupportedError5, logger10, AzureCliCredential;
var init_azureCliCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/azureCliCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError5 = new Error("AzureCliCredential is not supported in the browser.");
    logger10 = credentialLogger("AzureCliCredential");
    AzureCliCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger10.info(formatError("", BrowserNotSupportedError5));
        throw BrowserNotSupportedError5;
      }
      getToken() {
        logger10.getToken.info(formatError("", BrowserNotSupportedError5));
        throw BrowserNotSupportedError5;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/azureDeveloperCliCredential.browser.js
var BrowserNotSupportedError6, logger11, AzureDeveloperCliCredential;
var init_azureDeveloperCliCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/azureDeveloperCliCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError6 = new Error("AzureDeveloperCliCredential is not supported in the browser.");
    logger11 = credentialLogger("AzureDeveloperCliCredential");
    AzureDeveloperCliCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger11.info(formatError("", BrowserNotSupportedError6));
        throw BrowserNotSupportedError6;
      }
      getToken() {
        logger11.getToken.info(formatError("", BrowserNotSupportedError6));
        throw BrowserNotSupportedError6;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/msal/browserFlows/msalBrowserCommon.js
function defaultBrowserMsalConfig(options) {
  const tenantId = options.tenantId || DefaultTenantId;
  const authority = getAuthority(tenantId, options.authorityHost);
  return {
    auth: {
      clientId: options.clientId,
      authority,
      knownAuthorities: getKnownAuthorities(tenantId, authority, options.disableInstanceDiscovery),
      // If the users picked redirect as their login style,
      // but they didn't provide a redirectUri,
      // we can try to use the current page we're in as a default value.
      redirectUri: options.redirectUri || self.location.origin
    }
  };
}
var MsalBrowser;
var init_msalBrowserCommon = __esm({
  "node_modules/@azure/identity/dist-esm/src/msal/browserFlows/msalBrowserCommon.js"() {
    init_process();
    init_buffer();
    init_errors();
    init_utils_browser();
    init_tenantIdUtils();
    init_constants();
    MsalBrowser = class extends MsalBaseUtilities {
      constructor(options) {
        var _a3;
        super(options);
        this.logger = options.logger;
        this.loginStyle = options.loginStyle;
        if (!options.clientId) {
          throw new CredentialUnavailableError("A client ID is required in browsers");
        }
        this.clientId = options.clientId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds((_a3 = options === null || options === void 0 ? void 0 : options.tokenCredentialOptions) === null || _a3 === void 0 ? void 0 : _a3.additionallyAllowedTenants);
        this.tenantId = resolveTenantId(this.logger, options.tenantId, options.clientId);
        this.authorityHost = options.authorityHost;
        this.msalConfig = defaultBrowserMsalConfig(options);
        this.disableAutomaticAuthentication = options.disableAutomaticAuthentication;
        if (options.authenticationRecord) {
          this.account = Object.assign(Object.assign({}, options.authenticationRecord), { tenantId: this.tenantId });
        }
      }
      /**
       * In the browsers we don't need to init()
       */
      async init() {
      }
      /**
       * Clears MSAL's cache.
       */
      async logout() {
        var _a3;
        (_a3 = this.app) === null || _a3 === void 0 ? void 0 : _a3.logout();
      }
      /**
       * Attempts to retrieve an authenticated token from MSAL.
       */
      async getToken(scopes, options = {}) {
        const tenantId = processMultiTenantRequest(this.tenantId, options, this.additionallyAllowedTenantIds) || this.tenantId;
        if (!options.authority) {
          options.authority = getAuthority(tenantId, this.authorityHost);
        }
        await this.handleRedirect();
        if (!await this.getActiveAccount() && !this.disableAutomaticAuthentication) {
          await this.login(scopes);
        }
        return this.getTokenSilent(scopes).catch((err) => {
          if (err.name !== "AuthenticationRequiredError") {
            throw err;
          }
          if (options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication) {
            throw new AuthenticationRequiredError({
              scopes,
              getTokenOptions: options,
              message: "Automatic authentication has been disabled. You may call the authentication() method."
            });
          }
          this.logger.info(`Silent authentication failed, falling back to interactive method ${this.loginStyle}`);
          return this.doGetToken(scopes);
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/msal/browserFlows/msalAuthCode.js
var redirectHash, MSALAuthCode;
var init_msalAuthCode = __esm({
  "node_modules/@azure/identity/dist-esm/src/msal/browserFlows/msalAuthCode.js"() {
    init_process();
    init_buffer();
    init_dist2();
    init_msalBrowserCommon();
    init_utils_browser();
    init_errors();
    init_browser();
    redirectHash = self.location.hash;
    MSALAuthCode = class extends MsalBrowser {
      /**
       * Sets up an MSAL object based on the given parameters.
       * MSAL with Auth Code allows sending a previously obtained `authenticationRecord` through the optional parameters,
       * which is set to be the active account.
       * @param options - Parameters necessary and otherwise used to create the MSAL object.
       */
      constructor(options) {
        var _a3;
        super(options);
        this.loginHint = options.loginHint;
        this.msalConfig.cache = {
          cacheLocation: "sessionStorage",
          storeAuthStateInCookie: true
          // Set to true to improve the experience on IE11 and Edge.
        };
        this.msalConfig.system = {
          loggerOptions: {
            loggerCallback: defaultLoggerCallback(this.logger, "Browser"),
            logLevel: getMSALLogLevel(getLogLevel()),
            piiLoggingEnabled: (_a3 = options.loggingOptions) === null || _a3 === void 0 ? void 0 : _a3.enableUnsafeSupportLogging
          }
        };
      }
      async getApp() {
        if (!this.app) {
          this.app = await PublicClientApplication.createPublicClientApplication(this.msalConfig);
          if (this.account) {
            this.app.setActiveAccount(publicToMsal(this.account));
          }
        }
        return this.app;
      }
      /**
       * Loads the account based on the result of the authentication.
       * If no result was received, tries to load the account from the cache.
       * @param result - Result object received from MSAL.
       */
      async handleBrowserResult(result) {
        try {
          const app = await this.getApp();
          if (result && result.account) {
            this.logger.info(`MSAL Browser V2 authentication successful.`);
            app.setActiveAccount(result.account);
            return msalToPublic(this.clientId, result.account);
          }
          const activeAccount = await this.app.getActiveAccount();
          if (activeAccount) {
            return msalToPublic(this.clientId, activeAccount);
          }
          const accounts = app.getAllAccounts();
          if (accounts.length > 1) {
            this.logger.info(`More than one account was found authenticated for this Client ID and Tenant ID.
However, no "authenticationRecord" has been provided for this credential,
therefore we're unable to pick between these accounts.
A new login attempt will be requested, to ensure the correct account is picked.
To work with multiple accounts for the same Client ID and Tenant ID, please provide an "authenticationRecord" when initializing "InteractiveBrowserCredential".`);
            await app.logout({
              onRedirectNavigate: () => false
            });
            return;
          }
          if (accounts.length === 1) {
            const account = accounts[0];
            app.setActiveAccount(account);
            return msalToPublic(this.clientId, account);
          }
          this.logger.info(`No accounts were found through MSAL.`);
        } catch (e) {
          this.logger.info(`Failed to acquire token through MSAL. ${e.message}`);
        }
        return;
      }
      /**
       * Uses MSAL to handle the redirect.
       */
      async handleRedirect() {
        const app = await this.getApp();
        return this.handleBrowserResult(await app.handleRedirectPromise(redirectHash) || void 0);
      }
      /**
       * Uses MSAL to trigger a redirect or a popup login.
       */
      async login(scopes = []) {
        const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
        const loginRequest = {
          scopes: arrayScopes,
          loginHint: this.loginHint
        };
        const app = await this.getApp();
        switch (this.loginStyle) {
          case "redirect": {
            await app.loginRedirect(loginRequest);
            return;
          }
          case "popup":
            return this.handleBrowserResult(await app.loginPopup(loginRequest));
        }
      }
      /**
       * Uses MSAL to retrieve the active account.
       */
      async getActiveAccount() {
        const app = await this.getApp();
        const account = app.getActiveAccount();
        if (!account) {
          return;
        }
        return msalToPublic(this.clientId, account);
      }
      /**
       * Attempts to retrieve a token from cache.
       */
      async getTokenSilent(scopes, options) {
        const account = await this.getActiveAccount();
        if (!account) {
          throw new AuthenticationRequiredError({
            scopes,
            getTokenOptions: options,
            message: "Silent authentication failed. We couldn't retrieve an active account from the cache."
          });
        }
        const parameters = {
          authority: (options === null || options === void 0 ? void 0 : options.authority) || this.msalConfig.auth.authority,
          correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
          claims: options === null || options === void 0 ? void 0 : options.claims,
          account: publicToMsal(account),
          forceRefresh: false,
          scopes
        };
        try {
          this.logger.info("Attempting to acquire token silently");
          const app = await this.getApp();
          const response = await app.acquireTokenSilent(parameters);
          return this.handleResult(scopes, this.clientId, response);
        } catch (err) {
          throw this.handleError(scopes, err, options);
        }
      }
      /**
       * Attempts to retrieve the token in the browser.
       */
      async doGetToken(scopes, options) {
        const account = await this.getActiveAccount();
        if (!account) {
          throw new AuthenticationRequiredError({
            scopes,
            getTokenOptions: options,
            message: "Silent authentication failed. We couldn't retrieve an active account from the cache."
          });
        }
        const parameters = {
          authority: (options === null || options === void 0 ? void 0 : options.authority) || this.msalConfig.auth.authority,
          correlationId: options === null || options === void 0 ? void 0 : options.correlationId,
          claims: options === null || options === void 0 ? void 0 : options.claims,
          account: publicToMsal(account),
          loginHint: this.loginHint,
          scopes
        };
        const app = await this.getApp();
        switch (this.loginStyle) {
          case "redirect":
            await app.acquireTokenRedirect(parameters);
            return { token: "", expiresOnTimestamp: 0 };
          case "popup":
            return this.handleResult(scopes, this.clientId, await app.acquireTokenPopup(parameters));
        }
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/util/scopeUtils.js
function ensureScopes(scopes) {
  return Array.isArray(scopes) ? scopes : [scopes];
}
var init_scopeUtils = __esm({
  "node_modules/@azure/identity/dist-esm/src/util/scopeUtils.js"() {
    init_process();
    init_buffer();
    init_logging();
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/interactiveBrowserCredential.browser.js
var logger12, InteractiveBrowserCredential;
var init_interactiveBrowserCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/interactiveBrowserCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    init_tenantIdUtils();
    init_msalAuthCode();
    init_scopeUtils();
    init_tracing();
    logger12 = credentialLogger("InteractiveBrowserCredential");
    InteractiveBrowserCredential = class {
      /**
       * Creates an instance of the InteractiveBrowserCredential with the
       * details needed to authenticate against Azure Active Directory with
       * a user identity.
       *
       * This credential uses the [Authorization Code Flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow).
       * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.
       * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.
       *
       * It's recommended that the Microsoft Entra Applications used are configured to authenticate using Single Page Applications.
       * More information here: [link](https://learn.microsoft.com/en-us/azure/active-directory/develop/scenario-spa-app-registration#redirect-uri-msaljs-20-with-auth-code-flow).
       *
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(options) {
        if (!(options === null || options === void 0 ? void 0 : options.clientId)) {
          const error = new Error("The parameter `clientId` cannot be left undefined for the `InteractiveBrowserCredential`");
          logger12.info(formatError("", error));
          throw error;
        }
        this.tenantId = options === null || options === void 0 ? void 0 : options.tenantId;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        const browserOptions = options;
        const loginStyle = browserOptions.loginStyle || "popup";
        const loginStyles = ["redirect", "popup"];
        if (loginStyles.indexOf(loginStyle) === -1) {
          const error = new Error(`Invalid loginStyle: ${browserOptions.loginStyle}. Should be any of the following: ${loginStyles.join(", ")}.`);
          logger12.info(formatError("", error));
          throw error;
        }
        const msalOptions = Object.assign(Object.assign({}, options), { tokenCredentialOptions: options, logger: logger12, loginStyle, redirectUri: typeof options.redirectUri === "function" ? options.redirectUri() : options.redirectUri });
        this.msalFlow = new MSALAuthCode(msalOptions);
        this.disableAutomaticAuthentication = options === null || options === void 0 ? void 0 : options.disableAutomaticAuthentication;
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the user provided the option `disableAutomaticAuthentication`,
       * once the token can't be retrieved silently,
       * this method won't attempt to request user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
          const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);
          newOptions.tenantId = tenantId;
          const arrayScopes = ensureScopes(scopes);
          return this.msalFlow.getToken(arrayScopes, Object.assign(Object.assign({}, newOptions), { disableAutomaticAuthentication: this.disableAutomaticAuthentication }));
        });
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if successful.
       * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
       *
       * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                  TokenCredential implementation might make.
       */
      async authenticate(scopes, options = {}) {
        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
          const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
          await this.msalFlow.getToken(arrayScopes, newOptions);
          return this.msalFlow.getActiveAccount();
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/index.browser.js
var BrowserNotSupportedError7, logger13, ManagedIdentityCredential;
var init_index_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/managedIdentityCredential/index.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError7 = new Error("ManagedIdentityCredential is not supported in the browser.");
    logger13 = credentialLogger("ManagedIdentityCredential");
    ManagedIdentityCredential = class {
      constructor() {
        logger13.info(formatError("", BrowserNotSupportedError7));
        throw BrowserNotSupportedError7;
      }
      async getToken() {
        logger13.getToken.info(formatError("", BrowserNotSupportedError7));
        throw BrowserNotSupportedError7;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/deviceCodeCredential.browser.js
var BrowserNotSupportedError8, logger14, DeviceCodeCredential;
var init_deviceCodeCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/deviceCodeCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError8 = new Error("DeviceCodeCredential is not supported in the browser.");
    logger14 = credentialLogger("DeviceCodeCredential");
    DeviceCodeCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger14.info(formatError("", BrowserNotSupportedError8));
        throw BrowserNotSupportedError8;
      }
      getToken() {
        logger14.getToken.info(formatError("", BrowserNotSupportedError8));
        throw BrowserNotSupportedError8;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/authorizationCodeCredential.browser.js
var BrowserNotSupportedError9, logger15, AuthorizationCodeCredential;
var init_authorizationCodeCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/authorizationCodeCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError9 = new Error("AuthorizationCodeCredential is not supported in the browser. InteractiveBrowserCredential is more appropriate for this use case.");
    logger15 = credentialLogger("AuthorizationCodeCredential");
    AuthorizationCodeCredential = class {
      constructor() {
        logger15.info(formatError("", BrowserNotSupportedError9));
        throw BrowserNotSupportedError9;
      }
      getToken() {
        logger15.getToken.info(formatError("", BrowserNotSupportedError9));
        throw BrowserNotSupportedError9;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/azurePowerShellCredential.browser.js
var BrowserNotSupportedError10, logger16, AzurePowerShellCredential;
var init_azurePowerShellCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/azurePowerShellCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError10 = new Error("AzurePowerShellCredential is not supported in the browser.");
    logger16 = credentialLogger("AzurePowerShellCredential");
    AzurePowerShellCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger16.info(formatError("", BrowserNotSupportedError10));
        throw BrowserNotSupportedError10;
      }
      getToken() {
        logger16.getToken.info(formatError("", BrowserNotSupportedError10));
        throw BrowserNotSupportedError10;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/usernamePasswordCredential.browser.js
var logger17, UsernamePasswordCredential;
var init_usernamePasswordCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/usernamePasswordCredential.browser.js"() {
    init_process();
    init_buffer();
    init_tenantIdUtils();
    init_browser6();
    init_logging();
    init_identityClient();
    init_identityTokenEndpoint();
    init_tracing();
    logger17 = credentialLogger("UsernamePasswordCredential");
    UsernamePasswordCredential = class {
      /**
       * Creates an instance of the UsernamePasswordCredential with the details
       * needed to authenticate against Azure Active Directory with a username
       * and password.
       *
       * @param tenantIdOrName - The Azure Active Directory tenant (directory) ID or name.
       * @param clientId - The client (application) ID of an App Registration in the tenant.
       * @param username - The user account's e-mail address (user name).
       * @param password - The user account's account password
       * @param options - Options for configuring the client which makes the authentication request.
       */
      constructor(tenantIdOrName, clientId, username, password, options) {
        checkTenantId(logger17, tenantIdOrName);
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantIdOrName;
        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options === null || options === void 0 ? void 0 : options.additionallyAllowedTenants);
        this.clientId = clientId;
        this.username = username;
        this.password = password;
      }
      /**
       * Authenticates with Azure Active Directory and returns an access token if
       * successful.  If authentication cannot be performed at this time, this method may
       * return null.  If an error occurs during authentication, an {@link AuthenticationError}
       * containing failure details will be thrown.
       *
       * @param scopes - The list of scopes for which the token will have access.
       * @param options - The options used to configure any requests this
       *                TokenCredential implementation might make.
       */
      async getToken(scopes, options = {}) {
        return tracingClient.withSpan("UsernamePasswordCredential.getToken", options, async (newOptions) => {
          const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);
          newOptions.tenantId = tenantId;
          const urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);
          const params = new URLSearchParams({
            response_type: "token",
            grant_type: "password",
            client_id: this.clientId,
            username: this.username,
            password: this.password,
            scope: typeof scopes === "string" ? scopes : scopes.join(" ")
          });
          const webResource = createPipelineRequest({
            url: `${this.identityClient.authorityHost}/${this.tenantId}/${urlSuffix}`,
            method: "POST",
            body: params.toString(),
            headers: createHttpHeaders({
              Accept: "application/json",
              "Content-Type": "application/x-www-form-urlencoded"
            }),
            abortSignal: options && options.abortSignal,
            tracingOptions: newOptions.tracingOptions
          });
          const tokenResponse = await this.identityClient.sendTokenRequest(webResource);
          logger17.getToken.info(formatSuccess(scopes));
          return tokenResponse && tokenResponse.accessToken || null;
        });
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/visualStudioCodeCredential.browser.js
var BrowserNotSupportedError11, logger18, VisualStudioCodeCredential;
var init_visualStudioCodeCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/visualStudioCodeCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError11 = new Error("VisualStudioCodeCredential is not supported in the browser.");
    logger18 = credentialLogger("VisualStudioCodeCredential");
    VisualStudioCodeCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger18.info(formatError("", BrowserNotSupportedError11));
        throw BrowserNotSupportedError11;
      }
      getToken() {
        logger18.getToken.info(formatError("", BrowserNotSupportedError11));
        throw BrowserNotSupportedError11;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/onBehalfOfCredential.browser.js
var credentialName, BrowserNotSupportedError12, logger19, OnBehalfOfCredential;
var init_onBehalfOfCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/onBehalfOfCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    credentialName = "OnBehalfOfCredential";
    BrowserNotSupportedError12 = new Error(`${credentialName}: Not supported in the browser.`);
    logger19 = credentialLogger(credentialName);
    OnBehalfOfCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger19.info(formatError("", BrowserNotSupportedError12));
        throw BrowserNotSupportedError12;
      }
      getToken() {
        logger19.getToken.info(formatError("", BrowserNotSupportedError12));
        throw BrowserNotSupportedError12;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/credentials/workloadIdentityCredential.browser.js
var BrowserNotSupportedError13, logger20, WorkloadIdentityCredential;
var init_workloadIdentityCredential_browser = __esm({
  "node_modules/@azure/identity/dist-esm/src/credentials/workloadIdentityCredential.browser.js"() {
    init_process();
    init_buffer();
    init_logging();
    BrowserNotSupportedError13 = new Error("WorkloadIdentityCredential is not supported in the browser.");
    logger20 = credentialLogger("WorkloadIdentityCredential");
    WorkloadIdentityCredential = class {
      /**
       * Only available in Node.js
       */
      constructor() {
        logger20.info(formatError("", BrowserNotSupportedError13));
        throw BrowserNotSupportedError13;
      }
      /**
       * Only available in Node.js
       */
      getToken() {
        logger20.getToken.info(formatError("", BrowserNotSupportedError13));
        throw BrowserNotSupportedError13;
      }
    };
  }
});

// node_modules/@azure/identity/dist-esm/src/index.js
var src_exports = {};
__export(src_exports, {
  AggregateAuthenticationError: () => AggregateAuthenticationError,
  AggregateAuthenticationErrorName: () => AggregateAuthenticationErrorName,
  AuthenticationError: () => AuthenticationError,
  AuthenticationErrorName: () => AuthenticationErrorName,
  AuthenticationRequiredError: () => AuthenticationRequiredError,
  AuthorizationCodeCredential: () => AuthorizationCodeCredential,
  AzureAuthorityHosts: () => AzureAuthorityHosts,
  AzureCliCredential: () => AzureCliCredential,
  AzureDeveloperCliCredential: () => AzureDeveloperCliCredential,
  AzurePowerShellCredential: () => AzurePowerShellCredential,
  ChainedTokenCredential: () => ChainedTokenCredential,
  ClientAssertionCredential: () => ClientAssertionCredential,
  ClientCertificateCredential: () => ClientCertificateCredential,
  ClientSecretCredential: () => ClientSecretCredential,
  CredentialUnavailableError: () => CredentialUnavailableError,
  CredentialUnavailableErrorName: () => CredentialUnavailableErrorName,
  DefaultAzureCredential: () => DefaultAzureCredential,
  DeviceCodeCredential: () => DeviceCodeCredential,
  EnvironmentCredential: () => EnvironmentCredential,
  InteractiveBrowserCredential: () => InteractiveBrowserCredential,
  ManagedIdentityCredential: () => ManagedIdentityCredential,
  OnBehalfOfCredential: () => OnBehalfOfCredential,
  UsernamePasswordCredential: () => UsernamePasswordCredential,
  VisualStudioCodeCredential: () => VisualStudioCodeCredential,
  WorkloadIdentityCredential: () => WorkloadIdentityCredential,
  deserializeAuthenticationRecord: () => deserializeAuthenticationRecord,
  getDefaultAzureCredential: () => getDefaultAzureCredential,
  logger: () => logger,
  serializeAuthenticationRecord: () => serializeAuthenticationRecord,
  useIdentityPlugin: () => useIdentityPlugin
});
function getDefaultAzureCredential() {
  return new DefaultAzureCredential();
}
var init_src2 = __esm({
  "node_modules/@azure/identity/dist-esm/src/index.js"() {
    init_process();
    init_buffer();
    init_consumer_browser();
    init_defaultAzureCredential_browser();
    init_errors();
    init_utils_browser();
    init_chainedTokenCredential();
    init_clientSecretCredential_browser();
    init_defaultAzureCredential_browser();
    init_environmentCredential_browser();
    init_clientCertificateCredential_browser();
    init_clientAssertionCredential_browser();
    init_azureCliCredential_browser();
    init_azureDeveloperCliCredential_browser();
    init_interactiveBrowserCredential_browser();
    init_index_browser();
    init_deviceCodeCredential_browser();
    init_authorizationCodeCredential_browser();
    init_azurePowerShellCredential_browser();
    init_usernamePasswordCredential_browser();
    init_visualStudioCodeCredential_browser();
    init_onBehalfOfCredential_browser();
    init_workloadIdentityCredential_browser();
    init_logging();
    init_constants();
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tedious/lib/debug.js
var require_debug = __commonJS({
  "node_modules/tedious/lib/debug.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _events = require_events();
    var util = _interopRequireWildcard(require_util());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    var Debug = class extends _events.EventEmitter {
      /*
        @options    Which debug details should be sent.
                    data    - dump of packet data
                    payload - details of decoded payload
      */
      constructor({
        data = false,
        payload = false,
        packet = false,
        token = false
      } = {}) {
        super();
        this.options = {
          data,
          payload,
          packet,
          token
        };
        this.indent = "  ";
      }
      packet(direction, packet) {
        if (this.haveListeners() && this.options.packet) {
          this.log("");
          this.log(direction);
          this.log(packet.headerToString(this.indent));
        }
      }
      data(packet) {
        if (this.haveListeners() && this.options.data) {
          this.log(packet.dataToString(this.indent));
        }
      }
      payload(generatePayloadText) {
        if (this.haveListeners() && this.options.payload) {
          this.log(generatePayloadText());
        }
      }
      token(token) {
        if (this.haveListeners() && this.options.token) {
          this.log(util.inspect(token, {
            showHidden: false,
            depth: 5,
            colors: true
          }));
        }
      }
      haveListeners() {
        return this.listeners("debug").length > 0;
      }
      log(text) {
        this.emit("debug", text);
      }
    };
    var _default = exports.default = Debug;
    module.exports = Debug;
  }
});

// node_modules/tedious/lib/errors/abort-error.js
var require_abort_error = __commonJS({
  "node_modules/tedious/lib/errors/abort-error.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var AbortError4 = class extends Error {
      constructor() {
        super("The operation was aborted");
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    exports.default = AbortError4;
  }
});

// browser-external:dgram
var require_dgram = __commonJS({
  "browser-external:dgram"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "dgram" has been externalized for browser compatibility. Cannot access "dgram.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:url
var require_node_url = __commonJS({
  "browser-external:node:url"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:url" has been externalized for browser compatibility. Cannot access "node:url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tedious/lib/sender.js
var require_sender = __commonJS({
  "node_modules/tedious/lib/sender.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.sendInParallel = sendInParallel;
    exports.sendMessage = sendMessage;
    var _dgram = _interopRequireDefault(require_dgram());
    var _net = _interopRequireDefault(require_net());
    var _nodeUrl = _interopRequireDefault(require_node_url());
    var _abortError = _interopRequireDefault(require_abort_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function sendInParallel(addresses, port, request, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      return await new Promise((resolve, reject) => {
        const sockets = [];
        let errorCount = 0;
        const onError = (err) => {
          errorCount++;
          if (errorCount === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            clearSockets();
            reject(err);
          }
        };
        const onMessage = (message) => {
          signal.removeEventListener("abort", onAbort);
          clearSockets();
          resolve(message);
        };
        const onAbort = () => {
          clearSockets();
          reject(new _abortError.default());
        };
        const clearSockets = () => {
          for (const socket of sockets) {
            socket.removeListener("error", onError);
            socket.removeListener("message", onMessage);
            socket.close();
          }
        };
        signal.addEventListener("abort", onAbort, {
          once: true
        });
        for (let j = 0; j < addresses.length; j++) {
          const udpType = addresses[j].family === 6 ? "udp6" : "udp4";
          const socket = _dgram.default.createSocket(udpType);
          sockets.push(socket);
          socket.on("error", onError);
          socket.on("message", onMessage);
          socket.send(request, 0, request.length, port, addresses[j].address);
        }
      });
    }
    async function sendMessage(host, port, lookup, signal, request) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let addresses;
      if (_net.default.isIP(host)) {
        addresses = [{
          address: host,
          family: _net.default.isIPv6(host) ? 6 : 4
        }];
      } else {
        addresses = await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          signal.addEventListener("abort", onAbort);
          lookup(_nodeUrl.default.domainToASCII(host), {
            all: true
          }, (err, addresses2) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses2);
          });
        });
      }
      return await sendInParallel(addresses, port, request, signal);
    }
  }
});

// node_modules/tedious/lib/errors/timeout-error.js
var require_timeout_error = __commonJS({
  "node_modules/tedious/lib/errors/timeout-error.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var TimeoutError = class extends Error {
      constructor() {
        super("The operation was aborted due to timeout");
        this.code = "TIMEOUT_ERR";
        this.name = "TimeoutError";
      }
    };
    exports.default = TimeoutError;
  }
});

// node_modules/tedious/lib/utils/with-timeout.js
var require_with_timeout = __commonJS({
  "node_modules/tedious/lib/utils/with-timeout.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.withTimeout = withTimeout;
    var _timeoutError = _interopRequireDefault(require_timeout_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function withTimeout(timeout, func, signal) {
      const timeoutController = new AbortController();
      const abortCurrentAttempt = () => {
        timeoutController.abort();
      };
      const timer = setTimeout(abortCurrentAttempt, timeout);
      signal == null ? void 0 : signal.addEventListener("abort", abortCurrentAttempt, {
        once: true
      });
      try {
        return await func(timeoutController.signal);
      } catch (err) {
        if (err instanceof Error && err.name === "AbortError" && !(signal && signal.aborted)) {
          throw new _timeoutError.default();
        }
        throw err;
      } finally {
        signal == null ? void 0 : signal.removeEventListener("abort", abortCurrentAttempt);
        clearTimeout(timer);
      }
    }
  }
});

// node_modules/tedious/lib/instance-lookup.js
var require_instance_lookup = __commonJS({
  "node_modules/tedious/lib/instance-lookup.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.instanceLookup = instanceLookup;
    exports.parseBrowserResponse = parseBrowserResponse;
    var _dns = _interopRequireDefault(require_dns());
    var _abortError = _interopRequireDefault(require_abort_error());
    var _sender = require_sender();
    var _withTimeout = require_with_timeout();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SQL_SERVER_BROWSER_PORT = 1434;
    var TIMEOUT = 2 * 1e3;
    var RETRIES = 3;
    var MYSTERY_HEADER_LENGTH = 3;
    async function instanceLookup(options) {
      const server = options.server;
      if (typeof server !== "string") {
        throw new TypeError('Invalid arguments: "server" must be a string');
      }
      const instanceName = options.instanceName;
      if (typeof instanceName !== "string") {
        throw new TypeError('Invalid arguments: "instanceName" must be a string');
      }
      const timeout = options.timeout === void 0 ? TIMEOUT : options.timeout;
      if (typeof timeout !== "number") {
        throw new TypeError('Invalid arguments: "timeout" must be a number');
      }
      const retries = options.retries === void 0 ? RETRIES : options.retries;
      if (typeof retries !== "number") {
        throw new TypeError('Invalid arguments: "retries" must be a number');
      }
      if (options.lookup !== void 0 && typeof options.lookup !== "function") {
        throw new TypeError('Invalid arguments: "lookup" must be a function');
      }
      const lookup = options.lookup ?? _dns.default.lookup;
      if (options.port !== void 0 && typeof options.port !== "number") {
        throw new TypeError('Invalid arguments: "port" must be a number');
      }
      const port = options.port ?? SQL_SERVER_BROWSER_PORT;
      const signal = options.signal;
      if (signal.aborted) {
        throw new _abortError.default();
      }
      let response;
      for (let i = 0; i <= retries; i++) {
        try {
          response = await (0, _withTimeout.withTimeout)(timeout, async (signal2) => {
            const request = Buffer.from([2]);
            return await (0, _sender.sendMessage)(options.server, port, lookup, signal2, request);
          }, signal);
        } catch (err) {
          if (!signal.aborted && err instanceof Error && err.name === "TimeoutError") {
            continue;
          }
          throw err;
        }
      }
      if (!response) {
        throw new Error("Failed to get response from SQL Server Browser on " + server);
      }
      const message = response.toString("ascii", MYSTERY_HEADER_LENGTH);
      const foundPort = parseBrowserResponse(message, instanceName);
      if (!foundPort) {
        throw new Error("Port for " + instanceName + " not found in " + options.server);
      }
      return foundPort;
    }
    function parseBrowserResponse(response, instanceName) {
      let getPort;
      const instances = response.split(";;");
      for (let i = 0, len = instances.length; i < len; i++) {
        const instance = instances[i];
        const parts = instance.split(";");
        for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {
          const name2 = parts[p];
          const value = parts[p + 1];
          if (name2 === "tcp" && getPort) {
            const port = parseInt(value, 10);
            return port;
          }
          if (name2 === "InstanceName") {
            if (value.toUpperCase() === instanceName.toUpperCase()) {
              getPort = true;
            } else {
              getPort = false;
            }
          }
        }
      }
    }
  }
});

// node_modules/tedious/lib/transient-error-lookup.js
var require_transient_error_lookup = __commonJS({
  "node_modules/tedious/lib/transient-error-lookup.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransientErrorLookup = void 0;
    var TransientErrorLookup = class {
      isTransientError(error) {
        const transientErrors = [4060, 10928, 10929, 40197, 40501, 40613];
        return transientErrors.indexOf(error) !== -1;
      }
    };
    exports.TransientErrorLookup = TransientErrorLookup;
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports) {
    init_process();
    init_buffer();
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = /* @__PURE__ */ Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push(
              {
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              }
            );
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports !== "undefined") {
        exports["sprintf"] = sprintf;
        exports["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/tedious/lib/packet.js
var require_packet = __commonJS({
  "node_modules/tedious/lib/packet.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TYPE = exports.Packet = exports.OFFSET = exports.HEADER_LENGTH = void 0;
    exports.isPacketComplete = isPacketComplete;
    exports.packetLength = packetLength;
    var _sprintfJs = require_sprintf();
    var HEADER_LENGTH = exports.HEADER_LENGTH = 8;
    var TYPE = exports.TYPE = {
      SQL_BATCH: 1,
      RPC_REQUEST: 3,
      TABULAR_RESULT: 4,
      ATTENTION: 6,
      BULK_LOAD: 7,
      TRANSACTION_MANAGER: 14,
      LOGIN7: 16,
      NTLMAUTH_PKT: 17,
      PRELOGIN: 18,
      FEDAUTH_TOKEN: 8
    };
    var typeByValue = {};
    for (const name2 in TYPE) {
      typeByValue[TYPE[name2]] = name2;
    }
    var STATUS = {
      NORMAL: 0,
      EOM: 1,
      IGNORE: 2,
      RESETCONNECTION: 8,
      RESETCONNECTIONSKIPTRAN: 16
    };
    var OFFSET = exports.OFFSET = {
      Type: 0,
      Status: 1,
      Length: 2,
      SPID: 4,
      PacketID: 6,
      Window: 7
    };
    var DEFAULT_SPID = 0;
    var DEFAULT_PACKETID = 1;
    var DEFAULT_WINDOW = 0;
    var NL = "\n";
    var Packet = class {
      constructor(typeOrBuffer) {
        if (typeOrBuffer instanceof Buffer) {
          this.buffer = typeOrBuffer;
        } else {
          const type = typeOrBuffer;
          this.buffer = Buffer.alloc(HEADER_LENGTH, 0);
          this.buffer.writeUInt8(type, OFFSET.Type);
          this.buffer.writeUInt8(STATUS.NORMAL, OFFSET.Status);
          this.buffer.writeUInt16BE(DEFAULT_SPID, OFFSET.SPID);
          this.buffer.writeUInt8(DEFAULT_PACKETID, OFFSET.PacketID);
          this.buffer.writeUInt8(DEFAULT_WINDOW, OFFSET.Window);
          this.setLength();
        }
      }
      setLength() {
        this.buffer.writeUInt16BE(this.buffer.length, OFFSET.Length);
      }
      length() {
        return this.buffer.readUInt16BE(OFFSET.Length);
      }
      resetConnection(reset) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (reset) {
          status |= STATUS.RESETCONNECTION;
        } else {
          status &= 255 - STATUS.RESETCONNECTION;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      last(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (arguments.length > 0) {
          if (last) {
            status |= STATUS.EOM;
          } else {
            status &= 255 - STATUS.EOM;
          }
          this.buffer.writeUInt8(status, OFFSET.Status);
        }
        return this.isLast();
      }
      ignore(last) {
        let status = this.buffer.readUInt8(OFFSET.Status);
        if (last) {
          status |= STATUS.IGNORE;
        } else {
          status &= 255 - STATUS.IGNORE;
        }
        this.buffer.writeUInt8(status, OFFSET.Status);
      }
      isLast() {
        return !!(this.buffer.readUInt8(OFFSET.Status) & STATUS.EOM);
      }
      packetId(packetId) {
        if (packetId) {
          this.buffer.writeUInt8(packetId % 256, OFFSET.PacketID);
        }
        return this.buffer.readUInt8(OFFSET.PacketID);
      }
      addData(data) {
        this.buffer = Buffer.concat([this.buffer, data]);
        this.setLength();
        return this;
      }
      data() {
        return this.buffer.slice(HEADER_LENGTH);
      }
      type() {
        return this.buffer.readUInt8(OFFSET.Type);
      }
      statusAsString() {
        const status = this.buffer.readUInt8(OFFSET.Status);
        const statuses = [];
        for (const name2 in STATUS) {
          const value = STATUS[name2];
          if (status & value) {
            statuses.push(name2);
          } else {
            statuses.push(void 0);
          }
        }
        return statuses.join(" ").trim();
      }
      headerToString(indent = "") {
        const text = (0, _sprintfJs.sprintf)("type:0x%02X(%s), status:0x%02X(%s), length:0x%04X, spid:0x%04X, packetId:0x%02X, window:0x%02X", this.buffer.readUInt8(OFFSET.Type), typeByValue[this.buffer.readUInt8(OFFSET.Type)], this.buffer.readUInt8(OFFSET.Status), this.statusAsString(), this.buffer.readUInt16BE(OFFSET.Length), this.buffer.readUInt16BE(OFFSET.SPID), this.buffer.readUInt8(OFFSET.PacketID), this.buffer.readUInt8(OFFSET.Window));
        return indent + text;
      }
      dataToString(indent = "") {
        const BYTES_PER_GROUP = 4;
        const CHARS_PER_GROUP = 8;
        const BYTES_PER_LINE = 32;
        const data = this.data();
        let dataDump = "";
        let chars = "";
        for (let offset = 0; offset < data.length; offset++) {
          if (offset % BYTES_PER_LINE === 0) {
            dataDump += indent;
            dataDump += (0, _sprintfJs.sprintf)("%04X  ", offset);
          }
          if (data[offset] < 32 || data[offset] > 126) {
            chars += ".";
            if ((offset + 1) % CHARS_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
              chars += " ";
            }
          } else {
            chars += String.fromCharCode(data[offset]);
          }
          if (data[offset] != null) {
            dataDump += (0, _sprintfJs.sprintf)("%02X", data[offset]);
          }
          if ((offset + 1) % BYTES_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
            dataDump += " ";
          }
          if ((offset + 1) % BYTES_PER_LINE === 0) {
            dataDump += "  " + chars;
            chars = "";
            if (offset < data.length - 1) {
              dataDump += NL;
            }
          }
        }
        if (chars.length) {
          dataDump += "  " + chars;
        }
        return dataDump;
      }
      toString(indent = "") {
        return this.headerToString(indent) + "\n" + this.dataToString(indent + indent);
      }
      payloadString() {
        return "";
      }
    };
    exports.Packet = Packet;
    function isPacketComplete(potentialPacketBuffer) {
      if (potentialPacketBuffer.length < HEADER_LENGTH) {
        return false;
      } else {
        return potentialPacketBuffer.length >= potentialPacketBuffer.readUInt16BE(OFFSET.Length);
      }
    }
    function packetLength(potentialPacketBuffer) {
      return potentialPacketBuffer.readUInt16BE(OFFSET.Length);
    }
  }
});

// node_modules/tedious/lib/prelogin-payload.js
var require_prelogin_payload = __commonJS({
  "node_modules/tedious/lib/prelogin-payload.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _sprintfJs = require_sprintf();
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var optionBufferSize = 20;
    var TOKEN = {
      VERSION: 0,
      ENCRYPTION: 1,
      INSTOPT: 2,
      THREADID: 3,
      MARS: 4,
      FEDAUTHREQUIRED: 6,
      TERMINATOR: 255
    };
    var ENCRYPT = {
      OFF: 0,
      ON: 1,
      NOT_SUP: 2,
      REQ: 3
    };
    var encryptByValue = {};
    for (const name2 in ENCRYPT) {
      const value = ENCRYPT[name2];
      encryptByValue[value] = name2;
    }
    var MARS = {
      OFF: 0,
      ON: 1
    };
    var marsByValue = {};
    for (const name2 in MARS) {
      const value = MARS[name2];
      marsByValue[value] = name2;
    }
    var PreloginPayload = class {
      constructor(bufferOrOptions = {
        encrypt: false,
        version: {
          major: 0,
          minor: 0,
          build: 0,
          subbuild: 0
        }
      }) {
        if (bufferOrOptions instanceof Buffer) {
          this.data = bufferOrOptions;
          this.options = {
            encrypt: false,
            version: {
              major: 0,
              minor: 0,
              build: 0,
              subbuild: 0
            }
          };
        } else {
          this.options = bufferOrOptions;
          this.createOptions();
        }
        this.extractOptions();
      }
      createOptions() {
        const options = [this.createVersionOption(), this.createEncryptionOption(), this.createInstanceOption(), this.createThreadIdOption(), this.createMarsOption(), this.createFedAuthOption()];
        let length = 0;
        for (let i = 0, len = options.length; i < len; i++) {
          const option = options[i];
          length += 5 + option.data.length;
        }
        length++;
        this.data = Buffer.alloc(length, 0);
        let optionOffset = 0;
        let optionDataOffset = 5 * options.length + 1;
        for (let j = 0, len = options.length; j < len; j++) {
          const option = options[j];
          this.data.writeUInt8(option.token, optionOffset + 0);
          this.data.writeUInt16BE(optionDataOffset, optionOffset + 1);
          this.data.writeUInt16BE(option.data.length, optionOffset + 3);
          optionOffset += 5;
          option.data.copy(this.data, optionDataOffset);
          optionDataOffset += option.data.length;
        }
        this.data.writeUInt8(TOKEN.TERMINATOR, optionOffset);
      }
      createVersionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(this.options.version.major);
        buffer.writeUInt8(this.options.version.minor);
        buffer.writeUInt16BE(this.options.version.build);
        buffer.writeUInt16BE(this.options.version.subbuild);
        return {
          token: TOKEN.VERSION,
          data: buffer.data
        };
      }
      createEncryptionOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        if (this.options.encrypt) {
          buffer.writeUInt8(ENCRYPT.ON);
        } else {
          buffer.writeUInt8(ENCRYPT.NOT_SUP);
        }
        return {
          token: TOKEN.ENCRYPTION,
          data: buffer.data
        };
      }
      createInstanceOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(0);
        return {
          token: TOKEN.INSTOPT,
          data: buffer.data
        };
      }
      createThreadIdOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt32BE(0);
        return {
          token: TOKEN.THREADID,
          data: buffer.data
        };
      }
      createMarsOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(MARS.OFF);
        return {
          token: TOKEN.MARS,
          data: buffer.data
        };
      }
      createFedAuthOption() {
        const buffer = new _writableTrackingBuffer.default(optionBufferSize);
        buffer.writeUInt8(1);
        return {
          token: TOKEN.FEDAUTHREQUIRED,
          data: buffer.data
        };
      }
      extractOptions() {
        let offset = 0;
        while (this.data[offset] !== TOKEN.TERMINATOR) {
          let dataOffset = this.data.readUInt16BE(offset + 1);
          const dataLength = this.data.readUInt16BE(offset + 3);
          switch (this.data[offset]) {
            case TOKEN.VERSION:
              this.extractVersion(dataOffset);
              break;
            case TOKEN.ENCRYPTION:
              this.extractEncryption(dataOffset);
              break;
            case TOKEN.INSTOPT:
              this.extractInstance(dataOffset);
              break;
            case TOKEN.THREADID:
              if (dataLength > 0) {
                this.extractThreadId(dataOffset);
              }
              break;
            case TOKEN.MARS:
              this.extractMars(dataOffset);
              break;
            case TOKEN.FEDAUTHREQUIRED:
              this.extractFedAuth(dataOffset);
              break;
          }
          offset += 5;
          dataOffset += dataLength;
        }
      }
      extractVersion(offset) {
        this.version = {
          major: this.data.readUInt8(offset + 0),
          minor: this.data.readUInt8(offset + 1),
          build: this.data.readUInt16BE(offset + 2),
          subbuild: this.data.readUInt16BE(offset + 4)
        };
      }
      extractEncryption(offset) {
        this.encryption = this.data.readUInt8(offset);
        this.encryptionString = encryptByValue[this.encryption];
      }
      extractInstance(offset) {
        this.instance = this.data.readUInt8(offset);
      }
      extractThreadId(offset) {
        this.threadId = this.data.readUInt32BE(offset);
      }
      extractMars(offset) {
        this.mars = this.data.readUInt8(offset);
        this.marsString = marsByValue[this.mars];
      }
      extractFedAuth(offset) {
        this.fedAuthRequired = this.data.readUInt8(offset);
      }
      toString(indent = "") {
        return indent + "PreLogin - " + (0, _sprintfJs.sprintf)("version:%d.%d.%d.%d, encryption:0x%02X(%s), instopt:0x%02X, threadId:0x%08X, mars:0x%02X(%s)", this.version.major, this.version.minor, this.version.build, this.version.subbuild, this.encryption ? this.encryption : 0, this.encryptionString ? this.encryptionString : "", this.instance ? this.instance : 0, this.threadId ? this.threadId : 0, this.mars ? this.mars : 0, this.marsString ? this.marsString : "");
      }
    };
    var _default = exports.default = PreloginPayload;
    module.exports = PreloginPayload;
  }
});

// node_modules/tedious/lib/tds-versions.js
var require_tds_versions = __commonJS({
  "node_modules/tedious/lib/tds-versions.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.versionsByValue = exports.versions = void 0;
    var versions = exports.versions = {
      "7_1": 1895825409,
      "7_2": 1913192450,
      "7_3_A": 1930035203,
      "7_3_B": 1930100739,
      "7_4": 1946157060,
      "8_0": 134217728
    };
    var versionsByValue = exports.versionsByValue = {};
    for (const name2 in versions) {
      versionsByValue[versions[name2]] = name2;
    }
  }
});

// node_modules/tedious/lib/login7-payload.js
var require_login7_payload = __commonJS({
  "node_modules/tedious/lib/login7-payload.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _sprintfJs = require_sprintf();
    var _tdsVersions = require_tds_versions();
    var FLAGS_1 = {
      ENDIAN_LITTLE: 0,
      ENDIAN_BIG: 1,
      CHARSET_ASCII: 0,
      CHARSET_EBCDIC: 2,
      FLOAT_IEEE_754: 0,
      FLOAT_VAX: 4,
      FLOAT_ND5000: 8,
      BCP_DUMPLOAD_ON: 0,
      BCP_DUMPLOAD_OFF: 16,
      USE_DB_ON: 0,
      USE_DB_OFF: 32,
      INIT_DB_WARN: 0,
      INIT_DB_FATAL: 64,
      SET_LANG_WARN_OFF: 0,
      SET_LANG_WARN_ON: 128
    };
    var FLAGS_2 = {
      INIT_LANG_WARN: 0,
      INIT_LANG_FATAL: 1,
      ODBC_OFF: 0,
      ODBC_ON: 2,
      F_TRAN_BOUNDARY: 4,
      F_CACHE_CONNECT: 8,
      USER_NORMAL: 0,
      USER_SERVER: 16,
      USER_REMUSER: 32,
      USER_SQLREPL: 64,
      INTEGRATED_SECURITY_OFF: 0,
      INTEGRATED_SECURITY_ON: 128
    };
    var TYPE_FLAGS = {
      SQL_DFLT: 0,
      SQL_TSQL: 8,
      OLEDB_OFF: 0,
      OLEDB_ON: 16,
      READ_WRITE_INTENT: 0,
      READ_ONLY_INTENT: 32
    };
    var FLAGS_3 = {
      CHANGE_PASSWORD_NO: 0,
      CHANGE_PASSWORD_YES: 1,
      BINARY_XML: 2,
      SPAWN_USER_INSTANCE: 4,
      UNKNOWN_COLLATION_HANDLING: 8,
      EXTENSION_USED: 16
    };
    var FEDAUTH_OPTIONS = {
      FEATURE_ID: 2,
      LIBRARY_SECURITYTOKEN: 1,
      LIBRARY_ADAL: 2,
      FEDAUTH_YES_ECHO: 1,
      FEDAUTH_NO_ECHO: 0,
      ADAL_WORKFLOW_USER_PASS: 1,
      ADAL_WORKFLOW_INTEGRATED: 2
    };
    var FEATURE_EXT_TERMINATOR = 255;
    var Login7Payload = class {
      constructor({
        tdsVersion,
        packetSize,
        clientProgVer,
        clientPid,
        connectionId,
        clientTimeZone,
        clientLcid
      }) {
        this.tdsVersion = tdsVersion;
        this.packetSize = packetSize;
        this.clientProgVer = clientProgVer;
        this.clientPid = clientPid;
        this.connectionId = connectionId;
        this.clientTimeZone = clientTimeZone;
        this.clientLcid = clientLcid;
        this.readOnlyIntent = false;
        this.initDbFatal = false;
        this.fedAuth = void 0;
        this.userName = void 0;
        this.password = void 0;
        this.serverName = void 0;
        this.appName = void 0;
        this.hostname = void 0;
        this.libraryName = void 0;
        this.language = void 0;
        this.database = void 0;
        this.clientId = void 0;
        this.sspi = void 0;
        this.attachDbFile = void 0;
        this.changePassword = void 0;
      }
      toBuffer() {
        const fixedData = Buffer.alloc(94);
        const buffers = [fixedData];
        let offset = 0;
        let dataOffset = fixedData.length;
        offset = fixedData.writeUInt32LE(0, offset);
        offset = fixedData.writeUInt32LE(this.tdsVersion, offset);
        offset = fixedData.writeUInt32LE(this.packetSize, offset);
        offset = fixedData.writeUInt32LE(this.clientProgVer, offset);
        offset = fixedData.writeUInt32LE(this.clientPid, offset);
        offset = fixedData.writeUInt32LE(this.connectionId, offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags1(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags2(), offset);
        offset = fixedData.writeUInt8(this.buildTypeFlags(), offset);
        offset = fixedData.writeUInt8(this.buildOptionFlags3(), offset);
        offset = fixedData.writeInt32LE(this.clientTimeZone, offset);
        offset = fixedData.writeUInt32LE(this.clientLcid, offset);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.hostname) {
          const buffer = Buffer.from(this.hostname, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(dataOffset, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.userName) {
          const buffer = Buffer.from(this.userName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.password) {
          const buffer = Buffer.from(this.password, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(this.scramblePassword(buffer));
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.appName) {
          const buffer = Buffer.from(this.appName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.serverName) {
          const buffer = Buffer.from(this.serverName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        const extensions = this.buildFeatureExt();
        offset = fixedData.writeUInt16LE(4, offset);
        const extensionOffset = Buffer.alloc(4);
        extensionOffset.writeUInt32LE(dataOffset += 4, 0);
        dataOffset += extensions.length;
        buffers.push(extensionOffset, extensions);
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.libraryName) {
          const buffer = Buffer.from(this.libraryName, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.language) {
          const buffer = Buffer.from(this.language, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.database) {
          const buffer = Buffer.from(this.database, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.clientId) {
          this.clientId.copy(fixedData, offset, 0, 6);
        }
        offset += 6;
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.sspi) {
          if (this.sspi.length > 65535) {
            offset = fixedData.writeUInt16LE(65535, offset);
          } else {
            offset = fixedData.writeUInt16LE(this.sspi.length, offset);
          }
          buffers.push(this.sspi);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.attachDbFile) {
          const buffer = Buffer.from(this.attachDbFile, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        offset = fixedData.writeUInt16LE(dataOffset, offset);
        if (this.changePassword) {
          const buffer = Buffer.from(this.changePassword, "ucs2");
          offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
          dataOffset += buffer.length;
          buffers.push(buffer);
        } else {
          offset = fixedData.writeUInt16LE(0, offset);
        }
        if (this.sspi && this.sspi.length > 65535) {
          fixedData.writeUInt32LE(this.sspi.length, offset);
        } else {
          fixedData.writeUInt32LE(0, offset);
        }
        const data = Buffer.concat(buffers);
        data.writeUInt32LE(data.length, 0);
        return data;
      }
      buildOptionFlags1() {
        let flags1 = FLAGS_1.ENDIAN_LITTLE | FLAGS_1.CHARSET_ASCII | FLAGS_1.FLOAT_IEEE_754 | FLAGS_1.BCP_DUMPLOAD_OFF | FLAGS_1.USE_DB_OFF | FLAGS_1.SET_LANG_WARN_ON;
        if (this.initDbFatal) {
          flags1 |= FLAGS_1.INIT_DB_FATAL;
        } else {
          flags1 |= FLAGS_1.INIT_DB_WARN;
        }
        return flags1;
      }
      buildFeatureExt() {
        const buffers = [];
        const fedAuth = this.fedAuth;
        if (fedAuth) {
          switch (fedAuth.type) {
            case "ADAL":
              const buffer = Buffer.alloc(7);
              buffer.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, 0);
              buffer.writeUInt32LE(2, 1);
              buffer.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_ADAL << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), 5);
              buffer.writeUInt8(fedAuth.workflow === "integrated" ? 2 : FEDAUTH_OPTIONS.ADAL_WORKFLOW_USER_PASS, 6);
              buffers.push(buffer);
              break;
            case "SECURITYTOKEN":
              const token = Buffer.from(fedAuth.fedAuthToken, "ucs2");
              const buf = Buffer.alloc(10);
              let offset = 0;
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, offset);
              offset = buf.writeUInt32LE(token.length + 4 + 1, offset);
              offset = buf.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_SECURITYTOKEN << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), offset);
              buf.writeInt32LE(token.length, offset);
              buffers.push(buf);
              buffers.push(token);
              break;
          }
        }
        if (this.tdsVersion >= _tdsVersions.versions["7_4"]) {
          const UTF8_SUPPORT_FEATURE_ID = 10;
          const UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8 = 1;
          const buf = Buffer.alloc(6);
          buf.writeUInt8(UTF8_SUPPORT_FEATURE_ID, 0);
          buf.writeUInt32LE(1, 1);
          buf.writeUInt8(UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8, 5);
          buffers.push(buf);
        }
        buffers.push(Buffer.from([FEATURE_EXT_TERMINATOR]));
        return Buffer.concat(buffers);
      }
      buildOptionFlags2() {
        let flags2 = FLAGS_2.INIT_LANG_WARN | FLAGS_2.ODBC_OFF | FLAGS_2.USER_NORMAL;
        if (this.sspi) {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_ON;
        } else {
          flags2 |= FLAGS_2.INTEGRATED_SECURITY_OFF;
        }
        return flags2;
      }
      buildTypeFlags() {
        let typeFlags = TYPE_FLAGS.SQL_DFLT | TYPE_FLAGS.OLEDB_OFF;
        if (this.readOnlyIntent) {
          typeFlags |= TYPE_FLAGS.READ_ONLY_INTENT;
        } else {
          typeFlags |= TYPE_FLAGS.READ_WRITE_INTENT;
        }
        return typeFlags;
      }
      buildOptionFlags3() {
        return FLAGS_3.CHANGE_PASSWORD_NO | FLAGS_3.UNKNOWN_COLLATION_HANDLING | FLAGS_3.EXTENSION_USED;
      }
      scramblePassword(password) {
        for (let b = 0, len = password.length; b < len; b++) {
          let byte = password[b];
          const lowNibble = byte & 15;
          const highNibble = byte >> 4;
          byte = lowNibble << 4 | highNibble;
          byte = byte ^ 165;
          password[b] = byte;
        }
        return password;
      }
      toString(indent = "") {
        return indent + "Login7 - " + (0, _sprintfJs.sprintf)("TDS:0x%08X, PacketSize:0x%08X, ClientProgVer:0x%08X, ClientPID:0x%08X, ConnectionID:0x%08X", this.tdsVersion, this.packetSize, this.clientProgVer, this.clientPid, this.connectionId) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Flags1:0x%02X, Flags2:0x%02X, TypeFlags:0x%02X, Flags3:0x%02X, ClientTimezone:%d, ClientLCID:0x%08X", this.buildOptionFlags1(), this.buildOptionFlags2(), this.buildTypeFlags(), this.buildOptionFlags3(), this.clientTimeZone, this.clientLcid) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Hostname:'%s', Username:'%s', Password:'%s', AppName:'%s', ServerName:'%s', LibraryName:'%s'", this.hostname, this.userName, this.password, this.appName, this.serverName, this.libraryName) + "\n" + indent + "         " + (0, _sprintfJs.sprintf)("Language:'%s', Database:'%s', SSPI:'%s', AttachDbFile:'%s', ChangePassword:'%s'", this.language, this.database, this.sspi, this.attachDbFile, this.changePassword);
      }
    };
    var _default = exports.default = Login7Payload;
    module.exports = Login7Payload;
  }
});

// node_modules/js-md4/src/md4.js
var require_md4 = __commonJS({
  "node_modules/js-md4/src/md4.js"(exports, module) {
    init_process();
    init_buffer();
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.JS_MD4_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = globalThis;
      }
      var COMMON_JS = !root.JS_MD4_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_MD4_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer"];
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer);
        blocks = new Uint32Array(buffer);
      }
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Md4(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md4();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto = require_crypto();
        var Buffer2 = require_buffer().Buffer;
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash("md4").update(message, "utf8").digest("hex");
          } else if (ARRAY_BUFFER && message instanceof ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (message.length === void 0) {
            return method(message);
          }
          return crypto.createHash("md4").update(new Buffer2(message)).digest("hex");
        };
        return nodeMethod;
      };
      function Md4(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer2 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer2);
            this.blocks = new Uint32Array(buffer2);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md4.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString = typeof message !== "string";
        if (notString && ARRAY_BUFFER && message instanceof ArrayBuffer) {
          message = new Uint8Array(message);
        }
        var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                buffer82[i++] = message[index];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  buffer82[i++] = code;
                } else if (code < 2048) {
                  buffer82[i++] = 192 | code >> 6;
                  buffer82[i++] = 128 | code & 63;
                } else if (code < 55296 || code >= 57344) {
                  buffer82[i++] = 224 | code >> 12;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  buffer82[i++] = 240 | code >> 18;
                  buffer82[i++] = 128 | code >> 12 & 63;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                }
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        return this;
      };
      Md4.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        this.hash();
      };
      Md4.prototype.hash = function() {
        var a, b, c, d, ab, bc, cd, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 1;
          a = a << 3 | a >>> 29;
          d = (a & 4023233417 | ~a & 2562383102) + blocks2[1] + 271733878;
          d = d << 7 | d >>> 25;
          c = (d & a | ~d & 4023233417) + blocks2[2] - 1732584194;
          c = c << 11 | c >>> 21;
          b = (c & d | ~c & a) + blocks2[3] - 271733879;
          b = b << 19 | b >>> 13;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (b & c | ~b & d) + blocks2[0];
          a = a << 3 | a >>> 29;
          d += (a & b | ~a & c) + blocks2[1];
          d = d << 7 | d >>> 25;
          c += (d & a | ~d & b) + blocks2[2];
          c = c << 11 | c >>> 21;
          b += (c & d | ~c & a) + blocks2[3];
          b = b << 19 | b >>> 13;
        }
        a += (b & c | ~b & d) + blocks2[4];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[5];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[6];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[7];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[8];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[9];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[10];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[11];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[12];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[13];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[14];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[15];
        b = b << 19 | b >>> 13;
        bc = b & c;
        a += (bc | b & d | c & d) + blocks2[0] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[4] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[8] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[12] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[1] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[5] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[9] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[13] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[2] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[6] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[10] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[14] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[3] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[7] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[11] + 1518500249;
        c = c << 9 | c >>> 23;
        b += (c & d | c & a | da) + blocks2[15] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[0] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[8] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[4] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[12] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[2] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[10] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[6] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[14] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[1] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[9] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[5] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[13] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[3] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[11] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[7] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[15] + 1859775393;
        b = b << 15 | b >>> 17;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md4.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
      };
      Md4.prototype.toString = Md4.prototype.hex;
      Md4.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >> 8 & 255,
          h0 >> 16 & 255,
          h0 >> 24 & 255,
          h1 & 255,
          h1 >> 8 & 255,
          h1 >> 16 & 255,
          h1 >> 24 & 255,
          h2 & 255,
          h2 >> 8 & 255,
          h2 >> 16 & 255,
          h2 >> 24 & 255,
          h3 & 255,
          h3 >> 8 & 255,
          h3 >> 16 & 255,
          h3 >> 24 & 255
        ];
      };
      Md4.prototype.array = Md4.prototype.digest;
      Md4.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer2);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer2;
      };
      Md4.prototype.buffer = Md4.prototype.arrayBuffer;
      var exports2 = createMethod();
      if (COMMON_JS) {
        module.exports = exports2;
      } else {
        root.md4 = exports2;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});

// node_modules/tedious/lib/ntlm-payload.js
var require_ntlm_payload = __commonJS({
  "node_modules/tedious/lib/ntlm-payload.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var crypto = _interopRequireWildcard(require_crypto());
    var _jsMd = _interopRequireDefault(require_md4());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NTLMResponsePayload = class {
      constructor(loginData) {
        this.data = this.createResponse(loginData);
      }
      toString(indent = "") {
        return indent + "NTLM Auth";
      }
      createResponse(challenge) {
        const client_nonce = this.createClientNonce();
        const lmv2len = 24;
        const ntlmv2len = 16;
        const domain = challenge.domain;
        const username = challenge.userName;
        const password = challenge.password;
        const ntlmData = challenge.ntlmpacket;
        const server_data = ntlmData.target;
        const server_nonce = ntlmData.nonce;
        const bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;
        const data = new _writableTrackingBuffer.default(bufferLength);
        data.position = 0;
        data.writeString("NTLMSSP\0", "utf8");
        data.writeUInt32LE(3);
        const baseIdx = 64;
        const dnIdx = baseIdx;
        const unIdx = dnIdx + domain.length * 2;
        const l2Idx = unIdx + username.length * 2;
        const ntIdx = l2Idx + lmv2len;
        data.writeUInt16LE(lmv2len);
        data.writeUInt16LE(lmv2len);
        data.writeUInt32LE(l2Idx);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt16LE(ntlmv2len);
        data.writeUInt32LE(ntIdx);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt16LE(domain.length * 2);
        data.writeUInt32LE(dnIdx);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt16LE(username.length * 2);
        data.writeUInt32LE(unIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(0);
        data.writeUInt16LE(0);
        data.writeUInt32LE(baseIdx);
        data.writeUInt16LE(33281);
        data.writeUInt16LE(8);
        data.writeString(domain, "ucs2");
        data.writeString(username, "ucs2");
        const lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);
        data.copyFrom(lmv2Data);
        const genTime = (/* @__PURE__ */ new Date()).getTime();
        const ntlmDataBuffer = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);
        data.copyFrom(ntlmDataBuffer);
        data.writeUInt32LE(257);
        data.writeUInt32LE(0);
        const timestamp = this.createTimestamp(genTime);
        data.copyFrom(timestamp);
        data.copyFrom(client_nonce);
        data.writeUInt32LE(0);
        data.copyFrom(server_data);
        data.writeUInt32LE(0);
        return data.data;
      }
      createClientNonce() {
        const client_nonce = Buffer.alloc(8, 0);
        let nidx = 0;
        while (nidx < 8) {
          client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);
          nidx++;
        }
        return client_nonce;
      }
      ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {
        const timestamp = this.createTimestamp(mytime);
        const hash = this.ntv2Hash(domain, user, password);
        const dataLength = 40 + targetInfo.length;
        const data = Buffer.alloc(dataLength, 0);
        serverNonce.copy(data, 0, 0, 8);
        data.writeUInt32LE(257, 8);
        data.writeUInt32LE(0, 12);
        timestamp.copy(data, 16, 0, 8);
        clientNonce.copy(data, 24, 0, 8);
        data.writeUInt32LE(0, 32);
        targetInfo.copy(data, 36, 0, targetInfo.length);
        data.writeUInt32LE(0, 36 + targetInfo.length);
        return this.hmacMD5(data, hash);
      }
      createTimestamp(time) {
        const tenthsOfAMicrosecond = (BigInt(time) + BigInt(11644473600)) * BigInt(1e7);
        const lo = Number(tenthsOfAMicrosecond & BigInt(4294967295));
        const hi = Number(tenthsOfAMicrosecond >> BigInt(32) & BigInt(4294967295));
        const result = Buffer.alloc(8);
        result.writeUInt32LE(lo, 0);
        result.writeUInt32LE(hi, 4);
        return result;
      }
      lmv2Response(domain, user, password, serverNonce, clientNonce) {
        const hash = this.ntv2Hash(domain, user, password);
        const data = Buffer.alloc(serverNonce.length + clientNonce.length, 0);
        serverNonce.copy(data);
        clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);
        const newhash = this.hmacMD5(data, hash);
        const response = Buffer.alloc(newhash.length + clientNonce.length, 0);
        newhash.copy(response);
        clientNonce.copy(response, newhash.length, 0, clientNonce.length);
        return response;
      }
      ntv2Hash(domain, user, password) {
        const hash = this.ntHash(password);
        const identity = Buffer.from(user.toUpperCase() + domain.toUpperCase(), "ucs2");
        return this.hmacMD5(identity, hash);
      }
      ntHash(text) {
        const unicodeString = Buffer.from(text, "ucs2");
        return Buffer.from(_jsMd.default.arrayBuffer(unicodeString));
      }
      hmacMD5(data, key) {
        return crypto.createHmac("MD5", key).update(data).digest();
      }
    };
    var _default = exports.default = NTLMResponsePayload;
    module.exports = NTLMResponsePayload;
  }
});

// node_modules/tedious/lib/errors.js
var require_errors = __commonJS({
  "node_modules/tedious/lib/errors.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RequestError = exports.ConnectionError = void 0;
    var ConnectionError = class extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
      }
    };
    exports.ConnectionError = ConnectionError;
    var RequestError = class extends Error {
      constructor(message, code) {
        super(message);
        this.code = code;
      }
    };
    exports.RequestError = RequestError;
  }
});

// node_modules/tedious/lib/always-encrypted/types.js
var require_types = __commonJS({
  "node_modules/tedious/lib/always-encrypted/types.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SQLServerStatementColumnEncryptionSetting = exports.SQLServerEncryptionType = exports.DescribeParameterEncryptionResultSet2 = exports.DescribeParameterEncryptionResultSet1 = void 0;
    var SQLServerEncryptionType = exports.SQLServerEncryptionType = function(SQLServerEncryptionType2) {
      SQLServerEncryptionType2[SQLServerEncryptionType2["Deterministic"] = 1] = "Deterministic";
      SQLServerEncryptionType2[SQLServerEncryptionType2["Randomized"] = 2] = "Randomized";
      SQLServerEncryptionType2[SQLServerEncryptionType2["PlainText"] = 0] = "PlainText";
      return SQLServerEncryptionType2;
    }({});
    var DescribeParameterEncryptionResultSet1 = exports.DescribeParameterEncryptionResultSet1 = function(DescribeParameterEncryptionResultSet12) {
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyOrdinal"] = 0] = "KeyOrdinal";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["DbId"] = 1] = "DbId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyId"] = 2] = "KeyId";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyVersion"] = 3] = "KeyVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyMdVersion"] = 4] = "KeyMdVersion";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["EncryptedKey"] = 5] = "EncryptedKey";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["ProviderName"] = 6] = "ProviderName";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyPath"] = 7] = "KeyPath";
      DescribeParameterEncryptionResultSet12[DescribeParameterEncryptionResultSet12["KeyEncryptionAlgorithm"] = 8] = "KeyEncryptionAlgorithm";
      return DescribeParameterEncryptionResultSet12;
    }({});
    var DescribeParameterEncryptionResultSet2 = exports.DescribeParameterEncryptionResultSet2 = function(DescribeParameterEncryptionResultSet22) {
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterOrdinal"] = 0] = "ParameterOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ParameterName"] = 1] = "ParameterName";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionAlgorithm"] = 2] = "ColumnEncryptionAlgorithm";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncrytionType"] = 3] = "ColumnEncrytionType";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["ColumnEncryptionKeyOrdinal"] = 4] = "ColumnEncryptionKeyOrdinal";
      DescribeParameterEncryptionResultSet22[DescribeParameterEncryptionResultSet22["NormalizationRuleVersion"] = 5] = "NormalizationRuleVersion";
      return DescribeParameterEncryptionResultSet22;
    }({});
    var SQLServerStatementColumnEncryptionSetting = exports.SQLServerStatementColumnEncryptionSetting = function(SQLServerStatementColumnEncryptionSetting2) {
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["UseConnectionSetting"] = 0] = "UseConnectionSetting";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Enabled"] = 1] = "Enabled";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["ResultSetOnly"] = 2] = "ResultSetOnly";
      SQLServerStatementColumnEncryptionSetting2[SQLServerStatementColumnEncryptionSetting2["Disabled"] = 3] = "Disabled";
      return SQLServerStatementColumnEncryptionSetting2;
    }({});
  }
});

// node_modules/tedious/lib/request.js
var require_request = __commonJS({
  "node_modules/tedious/lib/request.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _events = require_events();
    var _errors = require_errors();
    var _types = require_types();
    var Request2 = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * This event, describing result set columns, will be emitted before row
       * events are emitted. This event may be emitted multiple times when more
       * than one recordset is produced by the statement.
       *
       * An array like object, where the columns can be accessed either by index
       * or name. Columns with a name that is an integer are not accessible by name,
       * as it would be interpreted as an array index.
       */
      /**
       * The request has been prepared and can be used in subsequent calls to execute and unprepare.
       */
      /**
       * The request encountered an error and has not been prepared.
       */
      /**
       * A row resulting from execution of the SQL statement.
       */
      /**
       * All rows from a result set have been provided (through `row` events).
       *
       * This token is used to indicate the completion of a SQL statement.
       * As multiple SQL statements can be sent to the server in a single SQL batch, multiple `done` can be generated.
       * An `done` event is emitted for each SQL statement in the SQL batch except variable declarations.
       * For execution of SQL statements within stored procedures, `doneProc` and `doneInProc` events are used in place of `done`.
       *
       * If you are using [[Connection.execSql]] then SQL server may treat the multiple calls with the same query as a stored procedure.
       * When this occurs, the `doneProc` and `doneInProc` events may be emitted instead. You must handle both events to ensure complete coverage.
       */
      /**
       * `request.on('doneInProc', function (rowCount, more, rows) { });`
       *
       * Indicates the completion status of a SQL statement within a stored procedure. All rows from a statement
       * in a stored procedure have been provided (through `row` events).
       *
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * Indicates the completion status of a stored procedure. This is also generated for stored procedures
       * executed through SQL statements.\
       * This event may also occur when executing multiple calls with the same query using [[execSql]].
       */
      /**
       * A value for an output parameter (that was added to the request with [[addOutputParameter]]).
       * See also `Using Parameters`.
       */
      /**
       * This event gives the columns by which data is ordered, if `ORDER BY` clause is executed in SQL Server.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * @param sqlTextOrProcedure
       *   The SQL statement to be executed
       *
       * @param callback
       *   The callback to execute once the request has been fully completed.
       */
      constructor(sqlTextOrProcedure, callback, options) {
        super();
        this.sqlTextOrProcedure = sqlTextOrProcedure;
        this.parameters = [];
        this.parametersByName = {};
        this.preparing = false;
        this.handle = void 0;
        this.canceled = false;
        this.paused = false;
        this.error = void 0;
        this.connection = void 0;
        this.timeout = void 0;
        this.userCallback = callback;
        this.statementColumnEncryptionSetting = options && options.statementColumnEncryptionSetting || _types.SQLServerStatementColumnEncryptionSetting.UseConnectionSetting;
        this.cryptoMetadataLoaded = false;
        this.callback = function(err, rowCount, rows) {
          if (this.preparing) {
            this.preparing = false;
            if (err) {
              this.emit("error", err);
            } else {
              this.emit("prepared");
            }
          } else {
            this.userCallback(err, rowCount, rows);
            this.emit("requestCompleted");
          }
        };
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects. The name should not start with `@`.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types.
       *
       * @param options
       *   Additional type options. Optional.
       */
      // TODO: `type` must be a valid TDS value type
      addParameter(name2, type, value, options) {
        const {
          output = false,
          length,
          precision,
          scale
        } = options ?? {};
        const parameter = {
          type,
          name: name2,
          value,
          output,
          length,
          precision,
          scale
        };
        this.parameters.push(parameter);
        this.parametersByName[name2] = parameter;
      }
      /**
       * @param name
       *   The parameter name. This should correspond to a parameter in the SQL,
       *   or a parameter that a called procedure expects.
       *
       * @param type
       *   One of the supported data types.
       *
       * @param value
       *   The value that the parameter is to be given. The Javascript type of the
       *   argument should match that documented for data types
       *
       * @param options
       *   Additional type options. Optional.
       */
      addOutputParameter(name2, type, value, options) {
        this.addParameter(name2, type, value, {
          ...options,
          output: true
        });
      }
      /**
       * @private
       */
      makeParamsParameter(parameters) {
        let paramsParameter = "";
        for (let i = 0, len = parameters.length; i < len; i++) {
          const parameter = parameters[i];
          if (paramsParameter.length > 0) {
            paramsParameter += ", ";
          }
          paramsParameter += "@" + parameter.name + " ";
          paramsParameter += parameter.type.declaration(parameter);
          if (parameter.output) {
            paramsParameter += " OUTPUT";
          }
        }
        return paramsParameter;
      }
      /**
       * @private
       */
      validateParameters(collation) {
        for (let i = 0, len = this.parameters.length; i < len; i++) {
          const parameter = this.parameters[i];
          try {
            parameter.value = parameter.type.validate(parameter.value, collation);
          } catch (error) {
            throw new _errors.RequestError("Validation failed for parameter '" + parameter.name + "'. " + error.message, "EPARAM");
          }
        }
      }
      /**
       * Temporarily suspends the flow of data from the database. No more `row` events will be emitted until [[resume] is called.
       * If this request is already in a paused state, calling [[pause]] has no effect.
       */
      pause() {
        if (this.paused) {
          return;
        }
        this.emit("pause");
        this.paused = true;
      }
      /**
       * Resumes the flow of data from the database.
       * If this request is not in a paused state, calling [[resume]] has no effect.
       */
      resume() {
        if (!this.paused) {
          return;
        }
        this.paused = false;
        this.emit("resume");
      }
      /**
       * Cancels a request while waiting for a server response.
       */
      cancel() {
        if (this.canceled) {
          return;
        }
        this.canceled = true;
        this.emit("cancel");
      }
      /**
       * Sets a timeout for this request.
       *
       * @param timeout
       *   The number of milliseconds before the request is considered failed,
       *   or `0` for no timeout. When no timeout is set for the request,
       *   the [[ConnectionOptions.requestTimeout]] of the [[Connection]] is used.
       */
      setTimeout(timeout) {
        this.timeout = timeout;
      }
    };
    var _default = exports.default = Request2;
    module.exports = Request2;
  }
});

// node_modules/tedious/lib/all-headers.js
var require_all_headers = __commonJS({
  "node_modules/tedious/lib/all-headers.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.writeToTrackingBuffer = writeToTrackingBuffer;
    var TYPE = {
      QUERY_NOTIFICATIONS: 1,
      TXN_DESCRIPTOR: 2,
      TRACE_ACTIVITY: 3
    };
    var TXNDESCRIPTOR_HEADER_DATA_LEN = 4 + 8;
    var TXNDESCRIPTOR_HEADER_LEN = 4 + 2 + TXNDESCRIPTOR_HEADER_DATA_LEN;
    function writeToTrackingBuffer(buffer, txnDescriptor, outstandingRequestCount) {
      buffer.writeUInt32LE(0);
      buffer.writeUInt32LE(TXNDESCRIPTOR_HEADER_LEN);
      buffer.writeUInt16LE(TYPE.TXN_DESCRIPTOR);
      buffer.writeBuffer(txnDescriptor);
      buffer.writeUInt32LE(outstandingRequestCount);
      const data = buffer.data;
      data.writeUInt32LE(data.length, 0);
      return buffer;
    }
  }
});

// node_modules/tedious/lib/rpcrequest-payload.js
var require_rpcrequest_payload = __commonJS({
  "node_modules/tedious/lib/rpcrequest-payload.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var STATUS = {
      BY_REF_VALUE: 1,
      DEFAULT_VALUE: 2
    };
    var RpcRequestPayload = class {
      constructor(procedure, parameters, txnDescriptor, options, collation) {
        this.procedure = procedure;
        this.parameters = parameters;
        this.options = options;
        this.txnDescriptor = txnDescriptor;
        this.collation = collation;
      }
      [Symbol.iterator]() {
        return this.generateData();
      }
      *generateData() {
        const buffer = new _writableTrackingBuffer.default(500);
        if (this.options.tdsVersion >= "7_2") {
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
        }
        if (typeof this.procedure === "string") {
          buffer.writeUsVarchar(this.procedure);
        } else {
          buffer.writeUShort(65535);
          buffer.writeUShort(this.procedure);
        }
        const optionFlags = 0;
        buffer.writeUInt16LE(optionFlags);
        yield buffer.data;
        const parametersLength = this.parameters.length;
        for (let i = 0; i < parametersLength; i++) {
          yield* this.generateParameterData(this.parameters[i]);
        }
      }
      toString(indent = "") {
        return indent + ("RPC Request - " + this.procedure);
      }
      *generateParameterData(parameter) {
        const buffer = new _writableTrackingBuffer.default(1 + 2 + Buffer.byteLength(parameter.name, "ucs-2") + 1);
        if (parameter.name) {
          buffer.writeBVarchar("@" + parameter.name);
        } else {
          buffer.writeBVarchar("");
        }
        let statusFlags = 0;
        if (parameter.output) {
          statusFlags |= STATUS.BY_REF_VALUE;
        }
        buffer.writeUInt8(statusFlags);
        yield buffer.data;
        const param = {
          value: parameter.value
        };
        const type = parameter.type;
        if ((type.id & 48) === 32) {
          if (parameter.length) {
            param.length = parameter.length;
          } else if (type.resolveLength) {
            param.length = type.resolveLength(parameter);
          }
        }
        if (parameter.precision) {
          param.precision = parameter.precision;
        } else if (type.resolvePrecision) {
          param.precision = type.resolvePrecision(parameter);
        }
        if (parameter.scale) {
          param.scale = parameter.scale;
        } else if (type.resolveScale) {
          param.scale = type.resolveScale(parameter);
        }
        if (this.collation) {
          param.collation = this.collation;
        }
        yield type.generateTypeInfo(param, this.options);
        yield type.generateParameterLength(param, this.options);
        yield* type.generateParameterData(param, this.options);
      }
    };
    var _default = exports.default = RpcRequestPayload;
    module.exports = RpcRequestPayload;
  }
});

// node_modules/tedious/lib/sqlbatch-payload.js
var require_sqlbatch_payload = __commonJS({
  "node_modules/tedious/lib/sqlbatch-payload.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SqlBatchPayload = class {
      constructor(sqlText, txnDescriptor, options) {
        this.sqlText = sqlText;
        this.txnDescriptor = txnDescriptor;
        this.options = options;
      }
      *[Symbol.iterator]() {
        if (this.options.tdsVersion >= "7_2") {
          const buffer = new _writableTrackingBuffer.default(18, "ucs2");
          const outstandingRequestCount = 1;
          (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
          yield buffer.data;
        }
        yield Buffer.from(this.sqlText, "ucs2");
      }
      toString(indent = "") {
        return indent + ("SQL Batch - " + this.sqlText);
      }
    };
    var _default = exports.default = SqlBatchPayload;
    module.exports = SqlBatchPayload;
  }
});

// node_modules/native-duplexpair/index.js
var require_native_duplexpair = __commonJS({
  "node_modules/native-duplexpair/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var Duplex = require_stream().Duplex;
    var kCallback = Symbol("Callback");
    var kOtherSide = Symbol("Other");
    var DuplexSocket = class extends Duplex {
      constructor(options) {
        super(options);
        this[kCallback] = null;
        this[kOtherSide] = null;
      }
      _read() {
        const callback = this[kCallback];
        if (callback) {
          this[kCallback] = null;
          callback();
        }
      }
      _write(chunk, encoding, callback) {
        this[kOtherSide][kCallback] = callback;
        this[kOtherSide].push(chunk);
      }
      _final(callback) {
        this[kOtherSide].on("end", callback);
        this[kOtherSide].push(null);
      }
    };
    var DuplexPair = class {
      constructor(options) {
        this.socket1 = new DuplexSocket(options);
        this.socket2 = new DuplexSocket(options);
        this.socket1[kOtherSide] = this.socket2;
        this.socket2[kOtherSide] = this.socket1;
      }
    };
    module.exports = DuplexPair;
  }
});

// node_modules/tedious/lib/message.js
var require_message = __commonJS({
  "node_modules/tedious/lib/message.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _stream = require_stream();
    var Message = class extends _stream.PassThrough {
      constructor({
        type,
        resetConnection = false
      }) {
        super();
        this.type = type;
        this.resetConnection = resetConnection;
        this.ignore = false;
      }
    };
    var _default = exports.default = Message;
    module.exports = Message;
  }
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/readable-stream/lib/ours/primordials.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = {
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name2, prop) {
        return Object.defineProperty(self2, name2, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name2) {
        return Object.getOwnPropertyDescriptor(self2, name2);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/abort-controller/browser.js
var require_browser2 = __commonJS({
  "node_modules/abort-controller/browser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { AbortController: AbortController3, AbortSignal: AbortSignal2 } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module.exports = AbortController3;
    module.exports.AbortSignal = AbortSignal2;
    module.exports.default = AbortController3;
  }
});

// node_modules/readable-stream/lib/ours/util.js
var require_util2 = __commonJS({
  "node_modules/readable-stream/lib/ours/util.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var bufferModule = require_buffer();
    var { kResistStopPropagation, SymbolDispose } = require_primordials();
    var AbortSignal2 = globalThis.AbortSignal || require_browser2().AbortSignal;
    var AbortController3 = globalThis.AbortController || require_browser2().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob3 = typeof Blob2 !== "undefined" ? function isBlob4(b) {
      return b instanceof Blob2;
    } : function isBlob4(b) {
      return false;
    };
    var validateAbortSignal = (signal, name2) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name2, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name2) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE(name2, "Function", value);
    };
    var AggregateError2 = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module.exports = {
      AggregateError: AggregateError2,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      },
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob: isBlob3,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: require_events().addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal2.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController3();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors2 = __commonJS({
  "node_modules/readable-stream/lib/ours/errors.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { format, inspect, AggregateError: CustomAggregateError } = require_util2();
    var AggregateError2 = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert2(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert2(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert2(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError2([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError4 = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name2, expected, actual) => {
        assert2(typeof name2 === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name2.endsWith(" argument")) {
          msg += `${name2} `;
        } else {
          msg += `"${name2}" ${name2.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert2(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert2(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name2, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name2.includes(".") ? "property" : "argument";
        return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name2, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name2}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert2(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert2(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > 2n ** 32n || input < -(2n ** 32n)) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module.exports = {
      AbortError: AbortError4,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/readable-stream/lib/internal/validators.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors2();
    var { normalizeEncoding } = require_util2();
    var { isAsyncFunction, isArrayBufferView } = require_util2().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name2, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name2, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name2);
      return value;
    }
    var validateInteger = hideStackFrames((value, name2, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      if (!NumberIsInteger(value))
        throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
      if (value < min || value > max)
        throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name2, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name2, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name2, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name2, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name2) {
      if (typeof value !== "string")
        throw new ERR_INVALID_ARG_TYPE2(name2, "string", value);
    }
    function validateNumber(value, name2, min = void 0, max) {
      if (typeof value !== "number")
        throw new ERR_INVALID_ARG_TYPE2(name2, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name2,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name2, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
      }
    });
    function validateBoolean(value, name2) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE2(name2, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name2, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name2) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE2(name2, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name2, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name2, value, reason);
      }
    });
    function validateStringArray(value, name2) {
      validateArray(value, name2);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name2}[${i}]`);
      }
    }
    function validateBooleanArray(value, name2) {
      validateArray(value, name2);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name2}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name2) {
      validateArray(value, name2);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name2}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name2 = "signal") {
      validateString(signal, name2);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name2 = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name2 = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name2, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name2) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name2) => {
      if (typeof value !== "function")
        throw new ERR_INVALID_ARG_TYPE2(name2, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name2) => {
      if (typeof value !== "function" || isAsyncFunction(value))
        throw new ERR_INVALID_ARG_TYPE2(name2, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name2) => {
      if (value !== void 0)
        throw new ERR_INVALID_ARG_TYPE2(name2, "undefined", value);
    });
    function validateUnion(value, name2, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name2) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name2,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null)
        return false;
      if (isAsync === true)
        return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false)
        return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state3 = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state3 !== null && state3 !== void 0 && state3.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableEnded === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
        return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream))
        return null;
      if (stream.writableFinished === true)
        return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored)
        return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
        return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream))
        return null;
      if (stream.readableEnded === true)
        return true;
      const rState = stream._readableState;
      if (!rState || rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
        return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream))
        return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored)
        return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
        return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null)
        return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null)
        return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
        return null;
      if (isDestroyed(stream))
        return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream))
        return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state3 = wState || rState;
      return !state3 && isServerResponse(stream) || !!(state3 && state3.autoDestroy && state3.emitClose && state3.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module) {
    init_process();
    init_buffer();
    var process2 = require_browser();
    var { AbortError: AbortError4, codes } = require_errors2();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util2();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false))
            return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process2.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process2.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process2.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process2.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError4(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util2().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError4(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process2.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util2().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process2.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module.exports = eos;
    module.exports.finished = finished;
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var process2 = require_browser();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError: AbortError4
    } = require_errors2();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy2(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process2.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process2.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process2.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process2.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process2.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process2.nextTick(onConstruct, err);
        });
      } catch (err) {
        process2.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process2.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError4();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process2.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process2.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module.exports = {
      construct,
      destroyer,
      destroy: destroy2,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require_events();
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    module.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { SymbolDispose } = require_primordials();
    var { AbortError: AbortError4, codes } = require_errors2();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name2) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE2(name2, "AbortSignal", signal);
      }
    };
    module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module.exports.addAbortSignalNoValidate(signal, stream);
    };
    module.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError4(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError4(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util2().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { inspect } = require_util2();
    module.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        const ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0)
          return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null)
          ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors2().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state3, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name2 = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name2, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state3.objectMode);
    }
    module.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    init_process();
    init_buffer();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var process2 = require_browser();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors2().codes;
    function from(Readable, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process2.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process2.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module.exports = from;
  }
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module) {
    init_process();
    init_buffer();
    var process2 = require_browser();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module.exports = Readable;
    Readable.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = require_buffer();
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util2().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError: AbortError4
    } = require_errors2();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value)
            this.state |= bit;
          else
            this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode)
        this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode)
        this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false)
        this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false)
        this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal && !isDuplex)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError4();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state3 = stream._readableState;
      let err;
      if ((state3.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state3.defaultEncoding;
          if (state3.encoding !== encoding) {
            if (addToFront && state3.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state3.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state3.state &= ~kReading;
        onEofChunk(stream, state3);
      } else if ((state3.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state3.state & kEndEmitted) !== 0)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state3.destroyed || state3.errored)
            return false;
          else
            addChunk(stream, state3, chunk, true);
        } else if (state3.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state3.destroyed || state3.errored) {
          return false;
        } else {
          state3.state &= ~kReading;
          if (state3.decoder && !encoding) {
            chunk = state3.decoder.write(chunk);
            if (state3.objectMode || chunk.length !== 0)
              addChunk(stream, state3, chunk, false);
            else
              maybeReadMore(stream, state3);
          } else {
            addChunk(stream, state3, chunk, false);
          }
        }
      } else if (!addToFront) {
        state3.state &= ~kReading;
        maybeReadMore(stream, state3);
      }
      return !state3.ended && (state3.length < state3.highWaterMark || state3.length === 0);
    }
    function addChunk(stream, state3, chunk, addToFront) {
      if (state3.flowing && state3.length === 0 && !state3.sync && stream.listenerCount("data") > 0) {
        if ((state3.state & kMultiAwaitDrain) !== 0) {
          state3.awaitDrainWriters.clear();
        } else {
          state3.awaitDrainWriters = null;
        }
        state3.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state3.length += state3.objectMode ? 1 : chunk.length;
        if (addToFront)
          state3.buffer.unshift(chunk);
        else
          state3.buffer.push(chunk);
        if ((state3.state & kNeedReadable) !== 0)
          emitReadable(stream);
      }
      maybeReadMore(stream, state3);
    }
    Readable.prototype.isPaused = function() {
      const state3 = this._readableState;
      return state3[kPaused] === true || state3.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "")
        buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state3) {
      if (n <= 0 || state3.length === 0 && state3.ended)
        return 0;
      if ((state3.state & kObjectMode) !== 0)
        return 1;
      if (NumberIsNaN(n)) {
        if (state3.flowing && state3.length)
          return state3.buffer.first().length;
        return state3.length;
      }
      if (n <= state3.length)
        return n;
      return state3.ended ? state3.length : 0;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state3 = this._readableState;
      const nOrig = n;
      if (n > state3.highWaterMark)
        state3.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0)
        state3.state &= ~kEmittedReadable;
      if (n === 0 && state3.needReadable && ((state3.highWaterMark !== 0 ? state3.length >= state3.highWaterMark : state3.length > 0) || state3.ended)) {
        debug("read: emitReadable", state3.length, state3.ended);
        if (state3.length === 0 && state3.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state3);
      if (n === 0 && state3.ended) {
        if (state3.length === 0)
          endReadable(this);
        return null;
      }
      let doRead = (state3.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state3.length === 0 || state3.length - n < state3.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state3.ended || state3.reading || state3.destroyed || state3.errored || !state3.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state3.state |= kReading | kSync;
        if (state3.length === 0)
          state3.state |= kNeedReadable;
        try {
          this._read(state3.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state3.state &= ~kSync;
        if (!state3.reading)
          n = howMuchToRead(nOrig, state3);
      }
      let ret;
      if (n > 0)
        ret = fromList(n, state3);
      else
        ret = null;
      if (ret === null) {
        state3.needReadable = state3.length <= state3.highWaterMark;
        n = 0;
      } else {
        state3.length -= n;
        if (state3.multiAwaitDrain) {
          state3.awaitDrainWriters.clear();
        } else {
          state3.awaitDrainWriters = null;
        }
      }
      if (state3.length === 0) {
        if (!state3.ended)
          state3.needReadable = true;
        if (nOrig !== n && state3.ended)
          endReadable(this);
      }
      if (ret !== null && !state3.errorEmitted && !state3.closeEmitted) {
        state3.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state3) {
      debug("onEofChunk");
      if (state3.ended)
        return;
      if (state3.decoder) {
        const chunk = state3.decoder.end();
        if (chunk && chunk.length) {
          state3.buffer.push(chunk);
          state3.length += state3.objectMode ? 1 : chunk.length;
        }
      }
      state3.ended = true;
      if (state3.sync) {
        emitReadable(stream);
      } else {
        state3.needReadable = false;
        state3.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state3 = stream._readableState;
      debug("emitReadable", state3.needReadable, state3.emittedReadable);
      state3.needReadable = false;
      if (!state3.emittedReadable) {
        debug("emitReadable", state3.flowing);
        state3.emittedReadable = true;
        process2.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state3 = stream._readableState;
      debug("emitReadable_", state3.destroyed, state3.length, state3.ended);
      if (!state3.destroyed && !state3.errored && (state3.length || state3.ended)) {
        stream.emit("readable");
        state3.emittedReadable = false;
      }
      state3.needReadable = !state3.flowing && !state3.ended && state3.length <= state3.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state3) {
      if (!state3.readingMore && state3.constructed) {
        state3.readingMore = true;
        process2.nextTick(maybeReadMore_, stream, state3);
      }
    }
    function maybeReadMore_(stream, state3) {
      while (!state3.reading && !state3.ended && (state3.length < state3.highWaterMark || state3.flowing && state3.length === 0)) {
        const len = state3.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state3.length)
          break;
      }
      state3.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state3 = this._readableState;
      if (state3.pipes.length === 1) {
        if (!state3.multiAwaitDrain) {
          state3.multiAwaitDrain = true;
          state3.awaitDrainWriters = new SafeSet(state3.awaitDrainWriters ? [state3.awaitDrainWriters] : []);
        }
      }
      state3.pipes.push(dest);
      debug("pipe count=%d opts=%j", state3.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process2.stdout && dest !== process2.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state3.endEmitted)
        process2.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state3.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state3.pipes.length === 1 && state3.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state3.awaitDrainWriters = dest;
            state3.multiAwaitDrain = false;
          } else if (state3.pipes.length > 1 && state3.pipes.includes(dest)) {
            debug("false write response, pause", state3.awaitDrainWriters.size);
            state3.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state3.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state3 = src._readableState;
        if (state3.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state3.awaitDrainWriters = null;
        } else if (state3.multiAwaitDrain) {
          debug("pipeOnDrain", state3.awaitDrainWriters.size);
          state3.awaitDrainWriters.delete(dest);
        }
        if ((!state3.awaitDrainWriters || state3.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      const state3 = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state3.pipes.length === 0)
        return this;
      if (!dest) {
        const dests = state3.pipes;
        state3.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state3.pipes, dest);
      if (index === -1)
        return this;
      state3.pipes.splice(index, 1);
      if (state3.pipes.length === 0)
        this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state3 = this._readableState;
      if (ev === "data") {
        state3.readableListening = this.listenerCount("readable") > 0;
        if (state3.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state3.endEmitted && !state3.readableListening) {
          state3.readableListening = state3.needReadable = true;
          state3.flowing = false;
          state3.emittedReadable = false;
          debug("on readable", state3.length, state3.reading);
          if (state3.length) {
            emitReadable(this);
          } else if (!state3.reading) {
            process2.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.off = Readable.prototype.removeListener;
    Readable.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process2.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state3 = self2._readableState;
      state3.readableListening = self2.listenerCount("readable") > 0;
      if (state3.resumeScheduled && state3[kPaused] === false) {
        state3.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state3.readableListening) {
        state3.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      const state3 = this._readableState;
      if (!state3.flowing) {
        debug("resume");
        state3.flowing = !state3.readableListening;
        resume(this, state3);
      }
      state3[kPaused] = false;
      return this;
    };
    function resume(stream, state3) {
      if (!state3.resumeScheduled) {
        state3.resumeScheduled = true;
        process2.nextTick(resume_, stream, state3);
      }
    }
    function resume_(stream, state3) {
      debug("resume", state3.reading);
      if (!state3.reading) {
        stream.read(0);
      }
      state3.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state3.flowing && !state3.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state3 = stream._readableState;
      debug("flow", state3.flowing);
      while (state3.flowing && stream.read() !== null)
        ;
    }
    Readable.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state3) {
          if (this._readableState) {
            this._readableState.flowing = state3;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state3) {
      if (state3.length === 0)
        return null;
      let ret;
      if (state3.objectMode)
        ret = state3.buffer.shift();
      else if (!n || n >= state3.length) {
        if (state3.decoder)
          ret = state3.buffer.join("");
        else if (state3.buffer.length === 1)
          ret = state3.buffer.first();
        else
          ret = state3.buffer.concat(state3.length);
        state3.buffer.clear();
      } else {
        ret = state3.buffer.consume(n, state3.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state3 = stream._readableState;
      debug("endReadable", state3.endEmitted);
      if (!state3.endEmitted) {
        state3.ended = true;
        process2.nextTick(endReadableNT, state3, stream);
      }
    }
    function endReadableNT(state3, stream) {
      debug("endReadableNT", state3.endEmitted, state3.length);
      if (!state3.errored && !state3.closeEmitted && !state3.endEmitted && state3.length === 0) {
        state3.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process2.nextTick(endWritableNT, stream);
        } else if (state3.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable.from = function(iterable, opts) {
      return from(Readable, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module) {
    init_process();
    init_buffer();
    var process2 = require_browser();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = require_buffer();
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors2().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex)
        this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state3) {
      state3.buffered = [];
      state3.bufferedIndex = 0;
      state3.allBuffers = true;
      state3.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
        if (typeof options.construct === "function")
          this._construct = options.construct;
        if (options.signal)
          addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state3 = this._writableState;
        if (!state3.writing) {
          clearBuffer(this, state3);
        }
        finishMaybe(this, state3);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state3 = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state3.defaultEncoding;
      } else {
        if (!encoding)
          encoding = state3.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
          throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function")
          cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state3.objectMode) {
        if (typeof chunk === "string") {
          if (state3.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state3.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state3.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process2.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state3.pendingcb++;
      return writeOrBuffer(stream, state3, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state3 = this._writableState;
      if (state3.corked) {
        state3.corked--;
        if (!state3.writing)
          clearBuffer(this, state3);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state3, chunk, encoding, callback) {
      const len = state3.objectMode ? 1 : chunk.length;
      state3.length += len;
      const ret = state3.length < state3.highWaterMark;
      if (!ret)
        state3.needDrain = true;
      if (state3.writing || state3.corked || state3.errored || !state3.constructed) {
        state3.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state3.allBuffers && encoding !== "buffer") {
          state3.allBuffers = false;
        }
        if (state3.allNoop && callback !== nop) {
          state3.allNoop = false;
        }
      } else {
        state3.writelen = len;
        state3.writecb = callback;
        state3.writing = true;
        state3.sync = true;
        stream._write(chunk, encoding, state3.onwrite);
        state3.sync = false;
      }
      return ret && !state3.errored && !state3.destroyed;
    }
    function doWrite(stream, state3, writev, len, chunk, encoding, cb) {
      state3.writelen = len;
      state3.writecb = cb;
      state3.writing = true;
      state3.sync = true;
      if (state3.destroyed)
        state3.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state3.onwrite);
      else
        stream._write(chunk, encoding, state3.onwrite);
      state3.sync = false;
    }
    function onwriteError(stream, state3, er, cb) {
      --state3.pendingcb;
      cb(er);
      errorBuffer(state3);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state3 = stream._writableState;
      const sync = state3.sync;
      const cb = state3.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state3.writing = false;
      state3.writecb = null;
      state3.length -= state3.writelen;
      state3.writelen = 0;
      if (er) {
        er.stack;
        if (!state3.errored) {
          state3.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process2.nextTick(onwriteError, stream, state3, er, cb);
        } else {
          onwriteError(stream, state3, er, cb);
        }
      } else {
        if (state3.buffered.length > state3.bufferedIndex) {
          clearBuffer(stream, state3);
        }
        if (sync) {
          if (state3.afterWriteTickInfo !== null && state3.afterWriteTickInfo.cb === cb) {
            state3.afterWriteTickInfo.count++;
          } else {
            state3.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state: state3
            };
            process2.nextTick(afterWriteTick, state3.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state3, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state: state3, count, cb }) {
      state3.afterWriteTickInfo = null;
      return afterWrite(stream, state3, count, cb);
    }
    function afterWrite(stream, state3, count, cb) {
      const needDrain = !state3.ending && !stream.destroyed && state3.length === 0 && state3.needDrain;
      if (needDrain) {
        state3.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state3.pendingcb--;
        cb();
      }
      if (state3.destroyed) {
        errorBuffer(state3);
      }
      finishMaybe(stream, state3);
    }
    function errorBuffer(state3) {
      if (state3.writing) {
        return;
      }
      for (let n = state3.bufferedIndex; n < state3.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state3.buffered[n];
        const len = state3.objectMode ? 1 : chunk.length;
        state3.length -= len;
        callback(
          (_state$errored = state3.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state3[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state3.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state3);
    }
    function clearBuffer(stream, state3) {
      if (state3.corked || state3.bufferProcessing || state3.destroyed || !state3.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state3;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state3.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state3.pendingcb -= bufferedLength - 1;
        const callback = state3.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state3.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state3.allBuffers;
        doWrite(stream, state3, true, state3.length, chunks, "", callback);
        resetBuffer(state3);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state3, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state3.writing);
        if (i === buffered.length) {
          resetBuffer(state3);
        } else if (i > 256) {
          buffered.splice(0, i);
          state3.bufferedIndex = 0;
        } else {
          state3.bufferedIndex = i;
        }
      }
      state3.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state3 = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state3.corked) {
        state3.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state3.errored && !state3.ending) {
        state3.ending = true;
        finishMaybe(this, state3, true);
        state3.ended = true;
      } else if (state3.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state3.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state3.finished) {
          process2.nextTick(cb, err);
        } else {
          state3[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state3) {
      return state3.ending && !state3.destroyed && state3.constructed && state3.length === 0 && !state3.errored && state3.buffered.length === 0 && !state3.finished && !state3.writing && !state3.errorEmitted && !state3.closeEmitted;
    }
    function callFinal(stream, state3) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state3.pendingcb--;
        if (err) {
          const onfinishCallbacks = state3[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state3.sync);
        } else if (needFinish(state3)) {
          state3.prefinished = true;
          stream.emit("prefinish");
          state3.pendingcb++;
          process2.nextTick(finish, stream, state3);
        }
      }
      state3.sync = true;
      state3.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state3.sync = false;
    }
    function prefinish(stream, state3) {
      if (!state3.prefinished && !state3.finalCalled) {
        if (typeof stream._final === "function" && !state3.destroyed) {
          state3.finalCalled = true;
          callFinal(stream, state3);
        } else {
          state3.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state3, sync) {
      if (needFinish(state3)) {
        prefinish(stream, state3);
        if (state3.pendingcb === 0) {
          if (sync) {
            state3.pendingcb++;
            process2.nextTick(
              (stream2, state4) => {
                if (needFinish(state4)) {
                  finish(stream2, state4);
                } else {
                  state4.pendingcb--;
                }
              },
              stream,
              state3
            );
          } else if (needFinish(state3)) {
            state3.pendingcb++;
            finish(stream, state3);
          }
        }
      }
    }
    function finish(stream, state3) {
      state3.pendingcb--;
      state3.finished = true;
      const onfinishCallbacks = state3[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state3.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState)
            return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy2 = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state3 = this._writableState;
      if (!state3.destroyed && (state3.bufferedIndex < state3.buffered.length || state3[kOnFinished].length)) {
        process2.nextTick(errorBuffer, state3);
      }
      destroy2.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module) {
    init_process();
    init_buffer();
    var process2 = require_browser();
    var bufferModule = require_buffer();
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils();
    var eos = require_end_of_stream();
    var {
      AbortError: AbortError4,
      codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }
    } = require_errors2();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util2();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob3 = typeof Blob2 !== "undefined" ? function isBlob4(b) {
      return b instanceof Blob2;
    } : function isBlob4(b) {
      return false;
    };
    var AbortController3 = globalThis.AbortController || require_browser2().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module.exports = function duplexify(body, name2) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy: destroy2 } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy: destroy2
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process2.nextTick(cb, null);
                } catch (err) {
                  process2.nextTick(cb, err);
                }
              });
            },
            destroy: destroy2
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name2, value);
      }
      if (isBlob3(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE2(
        name2,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController3();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process2.nextTick(cb);
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError4(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError4();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module.exports = Duplex;
    var Readable = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
    ObjectSetPrototypeOf(Duplex, Readable);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0)
        webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module.exports = Transform;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors2().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform.prototype._final = final;
    Transform.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { ObjectSetPrototypeOf } = require_primordials();
    module.exports = PassThrough;
    var Transform = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module) {
    init_process();
    init_buffer();
    var process2 = require_browser();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util2();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError: AbortError4
    } = require_errors2();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils();
    var AbortController3 = globalThis.AbortController || require_browser2().AbortController;
    var PassThrough;
    var Readable;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished)
            return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable) {
        Readable = require_readable();
      }
      yield* Readable.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController3();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError4());
      }
      addAbortListener = addAbortListener || require_util2().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process2.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy: destroy2, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy2);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process2.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process2.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy: destroy2, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy2);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE2(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process2.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process2.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils();
    var {
      AbortError: AbortError4,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors2();
    var eos = require_end_of_stream();
    module.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError4();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var AbortController3 = globalThis.AbortController || require_browser2().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError: AbortError4
    } = require_errors2();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils();
    var { deprecate } = require_util2();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return (async function* map2() {
        const signal = require_util2().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError4();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError4();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }).call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return (async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError4({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }).call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options))
        ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError4(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController3();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError4();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError4(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return (async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }).call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError4();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError4();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }).call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError4();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError4();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }).call(this);
    }
    module.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/readable-stream/lib/stream/promises.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream2();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/stream.js
var require_stream2 = __commonJS({
  "node_modules/readable-stream/lib/stream.js"(exports, module) {
    init_process();
    init_buffer();
    var { Buffer: Buffer2 } = require_buffer();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util2();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors2();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils();
    var Stream = module.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      fn = fn2;
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn2 = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      fn = fn2;
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn2, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn2, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn2,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    var fn;
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/readable-stream/lib/ours/browser.js
var require_browser3 = __commonJS({
  "node_modules/readable-stream/lib/ours/browser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var CustomStream = require_stream2();
    var promises = require_promises();
    var originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable;
    module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module.exports._isUint8Array = CustomStream._isUint8Array;
    module.exports.isDisturbed = CustomStream.isDisturbed;
    module.exports.isErrored = CustomStream.isErrored;
    module.exports.isReadable = CustomStream.isReadable;
    module.exports.Readable = CustomStream.Readable;
    module.exports.Writable = CustomStream.Writable;
    module.exports.Duplex = CustomStream.Duplex;
    module.exports.Transform = CustomStream.Transform;
    module.exports.PassThrough = CustomStream.PassThrough;
    module.exports.addAbortSignal = CustomStream.addAbortSignal;
    module.exports.finished = CustomStream.finished;
    module.exports.destroy = CustomStream.destroy;
    module.exports.destroy = originalDestroy;
    module.exports.pipeline = CustomStream.pipeline;
    module.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module.exports.Stream = CustomStream.Stream;
    module.exports.default = module.exports;
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    init_process();
    init_buffer();
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var { Buffer: Buffer2 } = require_buffer();
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init2(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readBigInt64BE: 8,
        readBigInt64LE: 8,
        readBigUInt64BE: 8,
        readBigUInt64LE: 8,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var DuplexStream = require_browser3().Duplex;
    var inherits = require_inherits_browser();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = (function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }).bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module.exports = BufferListStream;
    module.exports.BufferListStream = BufferListStream;
    module.exports.BufferList = BufferList;
  }
});

// node_modules/tedious/lib/incoming-message-stream.js
var require_incoming_message_stream = __commonJS({
  "node_modules/tedious/lib/incoming-message-stream.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = require_stream();
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _errors = require_errors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var IncomingMessageStream = class extends _stream.Transform {
      constructor(debug) {
        super({
          readableObjectMode: true
        });
        this.debug = debug;
        this.currentMessage = void 0;
        this.bl = new _bl.default();
      }
      pause() {
        super.pause();
        if (this.currentMessage) {
          this.currentMessage.pause();
        }
        return this;
      }
      resume() {
        super.resume();
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
        return this;
      }
      processBufferedData(callback) {
        while (this.bl.length >= _packet.HEADER_LENGTH) {
          const length = this.bl.readUInt16BE(2);
          if (length < _packet.HEADER_LENGTH) {
            return callback(new _errors.ConnectionError("Unable to process incoming packet"));
          }
          if (this.bl.length >= length) {
            const data = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(data);
            this.debug.packet("Received", packet);
            this.debug.data(packet);
            let message = this.currentMessage;
            if (message === void 0) {
              this.currentMessage = message = new _message.default({
                type: packet.type(),
                resetConnection: false
              });
              this.push(message);
            }
            if (packet.isLast()) {
              message.once("end", () => {
                this.currentMessage = void 0;
                this.processBufferedData(callback);
              });
              message.end(packet.data());
              return;
            } else if (!message.write(packet.data())) {
              message.once("drain", () => {
                this.processBufferedData(callback);
              });
              return;
            }
          } else {
            break;
          }
        }
        callback();
      }
      _transform(chunk, _encoding, callback) {
        this.bl.append(chunk);
        this.processBufferedData(callback);
      }
    };
    var _default = exports.default = IncomingMessageStream;
    module.exports = IncomingMessageStream;
  }
});

// node_modules/tedious/lib/outgoing-message-stream.js
var require_outgoing_message_stream = __commonJS({
  "node_modules/tedious/lib/outgoing-message-stream.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bl = _interopRequireDefault(require_bl());
    var _stream = require_stream();
    var _packet = require_packet();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OutgoingMessageStream = class extends _stream.Duplex {
      constructor(debug, {
        packetSize
      }) {
        super({
          writableObjectMode: true
        });
        this.packetSize = packetSize;
        this.debug = debug;
        this.bl = new _bl.default();
        this.on("finish", () => {
          this.push(null);
        });
      }
      _write(message, _encoding, callback) {
        const length = this.packetSize - _packet.HEADER_LENGTH;
        let packetNumber = 0;
        this.currentMessage = message;
        this.currentMessage.on("data", (data) => {
          if (message.ignore) {
            return;
          }
          this.bl.append(data);
          while (this.bl.length > length) {
            const data2 = this.bl.slice(0, length);
            this.bl.consume(length);
            const packet = new _packet.Packet(message.type);
            packet.packetId(packetNumber += 1);
            packet.resetConnection(message.resetConnection);
            packet.addData(data2);
            this.debug.packet("Sent", packet);
            this.debug.data(packet);
            if (this.push(packet.buffer) === false) {
              message.pause();
            }
          }
        });
        this.currentMessage.on("end", () => {
          const data = this.bl.slice();
          this.bl.consume(data.length);
          const packet = new _packet.Packet(message.type);
          packet.packetId(packetNumber += 1);
          packet.resetConnection(message.resetConnection);
          packet.last(true);
          packet.ignore(message.ignore);
          packet.addData(data);
          this.debug.packet("Sent", packet);
          this.debug.data(packet);
          this.push(packet.buffer);
          this.currentMessage = void 0;
          callback();
        });
      }
      _read(_size) {
        if (this.currentMessage) {
          this.currentMessage.resume();
        }
      }
    };
    var _default = exports.default = OutgoingMessageStream;
    module.exports = OutgoingMessageStream;
  }
});

// node_modules/tedious/lib/message-io.js
var require_message_io = __commonJS({
  "node_modules/tedious/lib/message-io.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _nativeDuplexpair = _interopRequireDefault(require_native_duplexpair());
    var tls = _interopRequireWildcard(require_tls());
    var _events = require_events();
    var _message = _interopRequireDefault(require_message());
    var _packet = require_packet();
    var _incomingMessageStream = _interopRequireDefault(require_incoming_message_stream());
    var _outgoingMessageStream = _interopRequireDefault(require_outgoing_message_stream());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MessageIO = class extends _events.EventEmitter {
      constructor(socket, packetSize, debug) {
        super();
        this.socket = socket;
        this.debug = debug;
        this.tlsNegotiationComplete = false;
        this.incomingMessageStream = new _incomingMessageStream.default(this.debug);
        this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();
        this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {
          packetSize
        });
        this.socket.pipe(this.incomingMessageStream);
        this.outgoingMessageStream.pipe(this.socket);
      }
      packetSize(...args) {
        if (args.length > 0) {
          const packetSize = args[0];
          this.debug.log("Packet size changed from " + this.outgoingMessageStream.packetSize + " to " + packetSize);
          this.outgoingMessageStream.packetSize = packetSize;
        }
        if (this.securePair) {
          this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
        }
        return this.outgoingMessageStream.packetSize;
      }
      // Negotiate TLS encryption.
      startTls(credentialsDetails, hostname, trustServerCertificate) {
        if (!credentialsDetails.maxVersion || !["TLSv1.2", "TLSv1.1", "TLSv1"].includes(credentialsDetails.maxVersion)) {
          credentialsDetails.maxVersion = "TLSv1.2";
        }
        const secureContext = tls.createSecureContext(credentialsDetails);
        return new Promise((resolve, reject) => {
          const duplexpair = new _nativeDuplexpair.default();
          const securePair = this.securePair = {
            cleartext: tls.connect({
              socket: duplexpair.socket1,
              servername: hostname,
              secureContext,
              rejectUnauthorized: !trustServerCertificate
            }),
            encrypted: duplexpair.socket2
          };
          const onSecureConnect = () => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.once("error", (err) => {
              this.socket.destroy(err);
            });
            const cipher = securePair.cleartext.getCipher();
            if (cipher) {
              this.debug.log("TLS negotiated (" + cipher.name + ", " + cipher.version + ")");
            }
            this.emit("secure", securePair.cleartext);
            securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
            this.outgoingMessageStream.unpipe(this.socket);
            this.socket.unpipe(this.incomingMessageStream);
            this.socket.pipe(securePair.encrypted);
            securePair.encrypted.pipe(this.socket);
            securePair.cleartext.pipe(this.incomingMessageStream);
            this.outgoingMessageStream.pipe(securePair.cleartext);
            this.tlsNegotiationComplete = true;
            resolve();
          };
          const onError = (err) => {
            securePair.encrypted.removeListener("readable", onReadable);
            securePair.cleartext.removeListener("error", onError);
            securePair.cleartext.removeListener("secureConnect", onSecureConnect);
            securePair.cleartext.destroy();
            securePair.encrypted.destroy();
            reject(err);
          };
          const onReadable = () => {
            const message = new _message.default({
              type: _packet.TYPE.PRELOGIN,
              resetConnection: false
            });
            let chunk;
            while (chunk = securePair.encrypted.read()) {
              message.write(chunk);
            }
            this.outgoingMessageStream.write(message);
            message.end();
            this.readMessage().then(async (response) => {
              securePair.encrypted.once("readable", onReadable);
              for await (const data of response) {
                securePair.encrypted.write(data);
              }
            }).catch(onError);
          };
          securePair.cleartext.once("error", onError);
          securePair.cleartext.once("secureConnect", onSecureConnect);
          securePair.encrypted.once("readable", onReadable);
        });
      }
      // TODO listen for 'drain' event when socket.write returns false.
      // TODO implement incomplete request cancelation (2.2.1.6)
      sendMessage(packetType, data, resetConnection) {
        const message = new _message.default({
          type: packetType,
          resetConnection
        });
        message.end(data);
        this.outgoingMessageStream.write(message);
        return message;
      }
      /**
       * Read the next incoming message from the socket.
       */
      async readMessage() {
        const result = await this.incomingMessageIterator.next();
        if (result.done) {
          throw new Error("unexpected end of message stream");
        }
        return result.value;
      }
    };
    var _default = exports.default = MessageIO;
    module.exports = MessageIO;
  }
});

// node_modules/tedious/lib/collation.js
var require_collation = __commonJS({
  "node_modules/tedious/lib/collation.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codepageBySortId = exports.codepageByLanguageId = exports.Flags = exports.Collation = void 0;
    var codepageByLanguageId = exports.codepageByLanguageId = {
      // Arabic_*
      [1025]: "CP1256",
      // Chinese_Taiwan_Stroke_*
      // Chinese_Traditional_Stroke_Count_*
      // Chinese_Taiwan_Bopomofo_*
      // Chinese_Traditional_Bopomofo_*
      [1028]: "CP950",
      // Czech_*
      [1029]: "CP1250",
      // Danish_Greenlandic_*
      // Danish_Norwegian_*
      [1030]: "CP1252",
      // Greek_*
      [1032]: "CP1253",
      // Latin1_General_*
      [1033]: "CP1252",
      // Traditional_Spanish_*
      [1034]: "CP1252",
      // Finnish_Swedish_*
      [1035]: "CP1252",
      // French_*
      [1036]: "CP1252",
      // Hebrew_*
      [1037]: "CP1255",
      // Hungarian_*
      // Hungarian_Technical_*
      [1038]: "CP1250",
      // Icelandic_*
      [1039]: "CP1252",
      // Japanese_*
      // Japanese_XJIS_*
      // Japanese_Unicode_*
      // Japanese_Bushu_Kakusu_*
      [1041]: "CP932",
      // Korean_*
      // Korean_Wansung_*
      [1042]: "CP949",
      // Norwegian_*
      [1044]: "CP1252",
      // Polish_*
      [1045]: "CP1250",
      // Romansh_*
      [1047]: "CP1252",
      // Romanian_*
      [1048]: "CP1250",
      // Cyrillic_*
      [1049]: "CP1251",
      // Croatian_*
      [1050]: "CP1250",
      // Slovak_*
      [1051]: "CP1250",
      // Albanian_*
      [1052]: "CP1250",
      // Thai_*
      [1054]: "CP874",
      // Turkish_*
      [1055]: "CP1254",
      // Urdu_*
      [1056]: "CP1256",
      // Ukrainian_*
      [1058]: "CP1251",
      // Slovenian_*
      [1060]: "CP1250",
      // Estonian_*
      [1061]: "CP1257",
      // Latvian_*
      [1062]: "CP1257",
      // Lithuanian_*
      [1063]: "CP1257",
      // Persian_*
      [1065]: "CP1256",
      // Vietnamese_*
      [1066]: "CP1258",
      // Azeri_Latin_*
      [1068]: "CP1254",
      // Upper_Sorbian_*
      [1070]: "CP1252",
      // Macedonian_FYROM_*
      [1071]: "CP1251",
      // Sami_Norway_*
      [1083]: "CP1252",
      // Kazakh_*
      [1087]: "CP1251",
      // Turkmen_*
      [1090]: "CP1250",
      // Uzbek_Latin_*
      [1091]: "CP1254",
      // Tatar_*
      [1092]: "CP1251",
      // Welsh_*
      [1106]: "CP1252",
      // Frisian_*
      [1122]: "CP1252",
      // Bashkir_*
      [1133]: "CP1251",
      // Mapudungan_*
      [1146]: "CP1252",
      // Mohawk_*
      [1148]: "CP1252",
      // Breton_*
      [1150]: "CP1252",
      // Uighur_*
      [1152]: "CP1256",
      // Corsican_*
      [1155]: "CP1252",
      // Yakut_*
      [1157]: "CP1251",
      // Dari_*
      [1164]: "CP1256",
      // Chinese_PRC_*
      // Chinese_Simplified_Pinyin_*
      // Chinese_PRC_Stroke_*
      // Chinese_Simplified_Stroke_Order_*
      [2052]: "CP936",
      // Serbian_Latin_*
      [2074]: "CP1250",
      // Azeri_Cyrillic_*
      [2092]: "CP1251",
      // Sami_Sweden_Finland_*
      [2107]: "CP1252",
      // Tamazight_*
      [2143]: "CP1252",
      // Chinese_Hong_Kong_Stroke_*
      [3076]: "CP950",
      // Modern_Spanish_*
      [3082]: "CP1252",
      // Serbian_Cyrillic_*
      [3098]: "CP1251",
      // Chinese_Traditional_Pinyin_*
      // Chinese_Traditional_Stroke_Order_*
      [5124]: "CP950",
      // Bosnian_Latin_*
      [5146]: "CP1250",
      // Bosnian_Cyrillic_*
      [8218]: "CP1251",
      // German
      // German_PhoneBook_*
      [1031]: "CP1252",
      // Georgian_Modern_Sort_*
      [1079]: "CP1252"
    };
    var codepageBySortId = exports.codepageBySortId = {
      [30]: "CP437",
      // SQL_Latin1_General_CP437_BIN
      [31]: "CP437",
      // SQL_Latin1_General_CP437_CS_AS
      [32]: "CP437",
      // SQL_Latin1_General_CP437_CI_AS
      [33]: "CP437",
      // SQL_Latin1_General_Pref_CP437_CI_AS
      [34]: "CP437",
      // SQL_Latin1_General_CP437_CI_AI
      [40]: "CP850",
      // SQL_Latin1_General_CP850_BIN
      [41]: "CP850",
      // SQL_Latin1_General_CP850_CS_AS
      [42]: "CP850",
      // SQL_Latin1_General_CP850_CI_AS
      [43]: "CP850",
      // SQL_Latin1_General_Pref_CP850_CI_AS
      [44]: "CP850",
      // SQL_Latin1_General_CP850_CI_AI
      [49]: "CP850",
      // SQL_1xCompat_CP850_CI_AS
      [51]: "CP1252",
      // SQL_Latin1_General_Cp1_CS_AS_KI_WI
      [52]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AS_KI_WI
      [53]: "CP1252",
      // SQL_Latin1_General_Pref_Cp1_CI_AS_KI_WI
      [54]: "CP1252",
      // SQL_Latin1_General_Cp1_CI_AI_KI_WI
      [55]: "CP850",
      // SQL_AltDiction_CP850_CS_AS
      [56]: "CP850",
      // SQL_AltDiction_Pref_CP850_CI_AS
      [57]: "CP850",
      // SQL_AltDiction_CP850_CI_AI
      [58]: "CP850",
      // SQL_Scandinavian_Pref_CP850_CI_AS
      [59]: "CP850",
      // SQL_Scandinavian_CP850_CS_AS
      [60]: "CP850",
      // SQL_Scandinavian_CP850_CI_AS
      [61]: "CP850",
      // SQL_AltDiction_CP850_CI_AS
      [80]: "CP1250",
      // SQL_Latin1_General_1250_BIN
      [81]: "CP1250",
      // SQL_Latin1_General_CP1250_CS_AS
      [82]: "CP1250",
      // SQL_Latin1_General_Cp1250_CI_AS_KI_WI
      [83]: "CP1250",
      // SQL_Czech_Cp1250_CS_AS_KI_WI
      [84]: "CP1250",
      // SQL_Czech_Cp1250_CI_AS_KI_WI
      [85]: "CP1250",
      // SQL_Hungarian_Cp1250_CS_AS_KI_WI
      [86]: "CP1250",
      // SQL_Hungarian_Cp1250_CI_AS_KI_WI
      [87]: "CP1250",
      // SQL_Polish_Cp1250_CS_AS_KI_WI
      [88]: "CP1250",
      // SQL_Polish_Cp1250_CI_AS_KI_WI
      [89]: "CP1250",
      // SQL_Romanian_Cp1250_CS_AS_KI_WI
      [90]: "CP1250",
      // SQL_Romanian_Cp1250_CI_AS_KI_WI
      [91]: "CP1250",
      // SQL_Croatian_Cp1250_CS_AS_KI_WI
      [92]: "CP1250",
      // SQL_Croatian_Cp1250_CI_AS_KI_WI
      [93]: "CP1250",
      // SQL_Slovak_Cp1250_CS_AS_KI_WI
      [94]: "CP1250",
      // SQL_Slovak_Cp1250_CI_AS_KI_WI
      [95]: "CP1250",
      // SQL_Slovenian_Cp1250_CS_AS_KI_WI
      [96]: "CP1250",
      // SQL_Slovenian_Cp1250_CI_AS_KI_WI
      [104]: "CP1251",
      // SQL_Latin1_General_1251_BIN
      [105]: "CP1251",
      // SQL_Latin1_General_CP1251_CS_AS
      [106]: "CP1251",
      // SQL_Latin1_General_CP1251_CI_AS
      [107]: "CP1251",
      // SQL_Ukrainian_Cp1251_CS_AS_KI_WI
      [108]: "CP1251",
      // SQL_Ukrainian_Cp1251_CI_AS_KI_WI
      [112]: "CP1253",
      // SQL_Latin1_General_1253_BIN
      [113]: "CP1253",
      // SQL_Latin1_General_CP1253_CS_AS
      [114]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AS
      [120]: "CP1253",
      // SQL_MixDiction_CP1253_CS_AS
      [121]: "CP1253",
      // SQL_AltDiction_CP1253_CS_AS
      [122]: "CP1253",
      // SQL_AltDiction2_CP1253_CS_AS
      [124]: "CP1253",
      // SQL_Latin1_General_CP1253_CI_AI
      [128]: "CP1254",
      // SQL_Latin1_General_1254_BIN
      [129]: "CP1254",
      // SQL_Latin1_General_Cp1254_CS_AS_KI_WI
      [130]: "CP1254",
      // SQL_Latin1_General_Cp1254_CI_AS_KI_WI
      [136]: "CP1255",
      // SQL_Latin1_General_1255_BIN
      [137]: "CP1255",
      // SQL_Latin1_General_CP1255_CS_AS
      [138]: "CP1255",
      // SQL_Latin1_General_CP1255_CI_AS
      [144]: "CP1256",
      // SQL_Latin1_General_1256_BIN
      [145]: "CP1256",
      // SQL_Latin1_General_CP1256_CS_AS
      [146]: "CP1256",
      // SQL_Latin1_General_CP1256_CI_AS
      [152]: "CP1257",
      // SQL_Latin1_General_1257_BIN
      [153]: "CP1257",
      // SQL_Latin1_General_CP1257_CS_AS
      [154]: "CP1257",
      // SQL_Latin1_General_CP1257_CI_AS
      [155]: "CP1257",
      // SQL_Estonian_Cp1257_CS_AS_KI_WI
      [156]: "CP1257",
      // SQL_Estonian_Cp1257_CI_AS_KI_WI
      [157]: "CP1257",
      // SQL_Latvian_Cp1257_CS_AS_KI_WI
      [158]: "CP1257",
      // SQL_Latvian_Cp1257_CI_AS_KI_WI
      [159]: "CP1257",
      // SQL_Lithuanian_Cp1257_CS_AS_KI_WI
      [160]: "CP1257",
      // SQL_Lithuanian_Cp1257_CI_AS_KI_WI
      [183]: "CP1252",
      // SQL_Danish_Pref_Cp1_CI_AS_KI_WI
      [184]: "CP1252",
      // SQL_SwedishPhone_Pref_Cp1_CI_AS_KI_WI
      [185]: "CP1252",
      // SQL_SwedishStd_Pref_Cp1_CI_AS_KI_WI
      [186]: "CP1252"
      // SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
    };
    var Flags = exports.Flags = {
      IGNORE_CASE: 1 << 0,
      IGNORE_ACCENT: 1 << 1,
      IGNORE_KANA: 1 << 2,
      IGNORE_WIDTH: 1 << 3,
      BINARY: 1 << 4,
      BINARY2: 1 << 5,
      UTF8: 1 << 6
    };
    var Collation = class {
      static fromBuffer(buffer, offset = 0) {
        let lcid = (buffer[offset + 2] & 15) << 16;
        lcid |= buffer[offset + 1] << 8;
        lcid |= buffer[offset + 0];
        let flags = (buffer[offset + 3] & 15) << 4;
        flags |= (buffer[offset + 2] & 240) >>> 4;
        const version2 = (buffer[offset + 3] & 240) >>> 4;
        const sortId = buffer[offset + 4];
        return new this(lcid, flags, version2, sortId);
      }
      constructor(lcid, flags, version2, sortId) {
        this.buffer = void 0;
        this.lcid = lcid;
        this.flags = flags;
        this.version = version2;
        this.sortId = sortId;
        if (this.flags & Flags.UTF8) {
          this.codepage = "utf-8";
        } else if (this.sortId) {
          this.codepage = codepageBySortId[this.sortId];
        } else {
          const languageId = this.lcid & 65535;
          this.codepage = codepageByLanguageId[languageId];
        }
      }
      toBuffer() {
        if (this.buffer) {
          return this.buffer;
        }
        this.buffer = Buffer.alloc(5);
        this.buffer[0] = this.lcid & 255;
        this.buffer[1] = this.lcid >>> 8 & 255;
        this.buffer[2] = this.lcid >>> 16 & 15 | (this.flags & 15) << 4;
        this.buffer[3] = (this.flags & 240) >>> 4 | (this.version & 15) << 4;
        this.buffer[4] = this.sortId & 255;
        return this.buffer;
      }
    };
    exports.Collation = Collation;
  }
});

// node_modules/tedious/lib/data-types/null.js
var require_null = __commonJS({
  "node_modules/tedious/lib/data-types/null.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Null = {
      id: 31,
      type: "NULL",
      name: "Null",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = Null;
    module.exports = Null;
  }
});

// node_modules/tedious/lib/data-types/intn.js
var require_intn = __commonJS({
  "node_modules/tedious/lib/data-types/intn.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var IntN = {
      id: 38,
      type: "INTN",
      name: "IntN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = IntN;
    module.exports = IntN;
  }
});

// node_modules/tedious/lib/data-types/tinyint.js
var require_tinyint = __commonJS({
  "node_modules/tedious/lib/data-types/tinyint.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var TinyInt = {
      id: 48,
      type: "INT1",
      name: "TinyInt",
      declaration: function() {
        return "tinyint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(1);
        buffer.writeUInt8(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < 0 || value > 255) {
          throw new TypeError("Value must be between 0 and 255, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports.default = TinyInt;
    module.exports = TinyInt;
  }
});

// node_modules/tedious/lib/data-types/bitn.js
var require_bitn = __commonJS({
  "node_modules/tedious/lib/data-types/bitn.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var BitN = {
      id: 104,
      type: "BITN",
      name: "BitN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      *generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = BitN;
    module.exports = BitN;
  }
});

// node_modules/tedious/lib/data-types/bit.js
var require_bit = __commonJS({
  "node_modules/tedious/lib/data-types/bit.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _bitn = _interopRequireDefault(require_bitn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([1]);
    var NULL_LENGTH = Buffer.from([0]);
    var Bit = {
      id: 50,
      type: "BIT",
      name: "Bit",
      declaration: function() {
        return "bit";
      },
      generateTypeInfo() {
        return Buffer.from([_bitn.default.id, 1]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value ? Buffer.from([1]) : Buffer.from([0]);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (value) {
          return true;
        } else {
          return false;
        }
      }
    };
    var _default = exports.default = Bit;
    module.exports = Bit;
  }
});

// node_modules/tedious/lib/data-types/smallint.js
var require_smallint = __commonJS({
  "node_modules/tedious/lib/data-types/smallint.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([2]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallInt = {
      id: 52,
      type: "INT2",
      name: "SmallInt",
      declaration: function() {
        return "smallint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 2]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeInt16LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -32768 || value > 32767) {
          throw new TypeError("Value must be between -32768 and 32767, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports.default = SmallInt;
    module.exports = SmallInt;
  }
});

// node_modules/tedious/lib/data-types/int.js
var require_int = __commonJS({
  "node_modules/tedious/lib/data-types/int.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Int = {
      id: 56,
      type: "INT4",
      name: "Int",
      declaration: function() {
        return "int";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Number(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "number") {
          value = Number(value);
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -2147483648 || value > 2147483647) {
          throw new TypeError("Value must be between -2147483648 and 2147483647, inclusive.");
        }
        return value | 0;
      }
    };
    var _default = exports.default = Int;
    module.exports = Int;
  }
});

// node_modules/tedious/lib/data-types/datetimen.js
var require_datetimen = __commonJS({
  "node_modules/tedious/lib/data-types/datetimen.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DateTimeN = {
      id: 111,
      type: "DATETIMN",
      name: "DateTimeN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = DateTimeN;
    module.exports = DateTimeN;
  }
});

// node_modules/tedious/lib/data-types/smalldatetime.js
var require_smalldatetime = __commonJS({
  "node_modules/tedious/lib/data-types/smalldatetime.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = new Date(1900, 0, 1);
    var UTC_EPOCH_DATE = new Date(Date.UTC(1900, 0, 1));
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallDateTime = {
      id: 58,
      type: "DATETIM4",
      name: "SmallDateTime",
      declaration: function() {
        return "smalldatetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        let days, dstDiff, minutes;
        if (options.useUTC) {
          days = Math.floor((parameter.value.getTime() - UTC_EPOCH_DATE.getTime()) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getUTCHours() * 60 + parameter.value.getUTCMinutes();
        } else {
          dstDiff = -(parameter.value.getTimezoneOffset() - EPOCH_DATE.getTimezoneOffset()) * 60 * 1e3;
          days = Math.floor((parameter.value.getTime() - EPOCH_DATE.getTime() + dstDiff) / (1e3 * 60 * 60 * 24));
          minutes = parameter.value.getHours() * 60 + parameter.value.getMinutes();
        }
        buffer.writeUInt16LE(days, 0);
        buffer.writeUInt16LE(minutes, 2);
        yield buffer;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year, month, date;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
          month = value.getUTCMonth();
          date = value.getUTCDate();
        } else {
          year = value.getFullYear();
          month = value.getMonth();
          date = value.getDate();
        }
        if (year < 1900 || year > 2079) {
          throw new TypeError("Out of range.");
        }
        if (year === 2079) {
          if (month > 4 || month === 4 && date > 6) {
            throw new TypeError("Out of range.");
          }
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = SmallDateTime;
    module.exports = SmallDateTime;
  }
});

// node_modules/tedious/lib/data-types/floatn.js
var require_floatn = __commonJS({
  "node_modules/tedious/lib/data-types/floatn.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var FloatN = {
      id: 109,
      type: "FLTN",
      name: "FloatN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = FloatN;
    module.exports = FloatN;
  }
});

// node_modules/tedious/lib/data-types/real.js
var require_real = __commonJS({
  "node_modules/tedious/lib/data-types/real.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([4]);
    var Real = {
      id: 59,
      type: "FLT4",
      name: "Real",
      declaration: function() {
        return "real";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeFloatLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports.default = Real;
    module.exports = Real;
  }
});

// node_modules/tedious/lib/data-types/moneyn.js
var require_moneyn = __commonJS({
  "node_modules/tedious/lib/data-types/moneyn.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MoneyN = {
      id: 110,
      type: "MONEYN",
      name: "MoneyN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = MoneyN;
    module.exports = MoneyN;
  }
});

// node_modules/tedious/lib/data-types/money.js
var require_money = __commonJS({
  "node_modules/tedious/lib/data-types/money.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var Money = {
      id: 60,
      type: "MONEY",
      name: "Money",
      declaration: function() {
        return "money";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value * 1e4;
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32), 0);
        buffer.writeInt32LE(value & -1, 4);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -9223372036854776e-1 || value > 9223372036854776e-1) {
          throw new TypeError("Value must be between -922337203685477.5808 and 922337203685477.5807, inclusive.");
        }
        return value;
      }
    };
    var _default = exports.default = Money;
    module.exports = Money;
  }
});

// node_modules/@js-joda/core/dist/js-joda.esm.js
var js_joda_esm_exports = {};
__export(js_joda_esm_exports, {
  ArithmeticException: () => ArithmeticException,
  ChronoField: () => ChronoField,
  ChronoLocalDate: () => ChronoLocalDate,
  ChronoLocalDateTime: () => ChronoLocalDateTime,
  ChronoUnit: () => ChronoUnit,
  ChronoZonedDateTime: () => ChronoZonedDateTime,
  Clock: () => Clock,
  DateTimeException: () => DateTimeException,
  DateTimeFormatter: () => DateTimeFormatter,
  DateTimeFormatterBuilder: () => DateTimeFormatterBuilder,
  DateTimeParseException: () => DateTimeParseException,
  DayOfWeek: () => DayOfWeek,
  DecimalStyle: () => DecimalStyle,
  Duration: () => Duration,
  IllegalArgumentException: () => IllegalArgumentException,
  IllegalStateException: () => IllegalStateException,
  Instant: () => Instant,
  IsoChronology: () => IsoChronology,
  IsoFields: () => IsoFields,
  LocalDate: () => LocalDate,
  LocalDateTime: () => LocalDateTime,
  LocalTime: () => LocalTime,
  Month: () => Month,
  MonthDay: () => MonthDay,
  NullPointerException: () => NullPointerException,
  OffsetDateTime: () => OffsetDateTime,
  OffsetTime: () => OffsetTime,
  ParsePosition: () => ParsePosition,
  Period: () => Period,
  ResolverStyle: () => ResolverStyle,
  SignStyle: () => SignStyle,
  Temporal: () => Temporal,
  TemporalAccessor: () => TemporalAccessor,
  TemporalAdjuster: () => TemporalAdjuster,
  TemporalAdjusters: () => TemporalAdjusters,
  TemporalAmount: () => TemporalAmount,
  TemporalField: () => TemporalField,
  TemporalQueries: () => TemporalQueries,
  TemporalQuery: () => TemporalQuery,
  TemporalUnit: () => TemporalUnit,
  TextStyle: () => TextStyle,
  UnsupportedTemporalTypeException: () => UnsupportedTemporalTypeException,
  ValueRange: () => ValueRange,
  Year: () => Year,
  YearConstants: () => YearConstants,
  YearMonth: () => YearMonth,
  ZoneId: () => ZoneId,
  ZoneOffset: () => ZoneOffset,
  ZoneOffsetTransition: () => ZoneOffsetTransition,
  ZoneRegion: () => ZoneRegion,
  ZoneRules: () => ZoneRules,
  ZoneRulesProvider: () => ZoneRulesProvider,
  ZonedDateTime: () => ZonedDateTime,
  _: () => _,
  convert: () => convert,
  nativeJs: () => nativeJs,
  use: () => use
});
function createErrorType(name2, init2, superErrorClass) {
  if (superErrorClass === void 0) {
    superErrorClass = Error;
  }
  function JsJodaException(message) {
    if (!Error.captureStackTrace) {
      this.stack = new Error().stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
    this.message = message;
    init2 && init2.apply(this, arguments);
    this.toString = function() {
      return this.name + ": " + this.message;
    };
  }
  JsJodaException.prototype = Object.create(superErrorClass.prototype);
  JsJodaException.prototype.name = name2;
  JsJodaException.prototype.constructor = JsJodaException;
  return JsJodaException;
}
function messageWithCause(message, cause) {
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
}
function messageForDateTimeParseException(message, text, index, cause) {
  if (text === void 0) {
    text = "";
  }
  if (index === void 0) {
    index = 0;
  }
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  msg += ": " + text + ", at index: " + index;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
  this.parsedString = function() {
    return text;
  };
  this.errorIndex = function() {
    return index;
  };
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function assert(assertion, msg, error) {
  if (!assertion) {
    if (error) {
      throw new error(msg);
    } else {
      throw new Error(msg);
    }
  }
}
function requireNonNull(value, parameterName) {
  if (value == null) {
    throw new NullPointerException(parameterName + " must not be null");
  }
  return value;
}
function requireInstance(value, _class, parameterName) {
  if (!(value instanceof _class)) {
    throw new IllegalArgumentException(parameterName + " must be an instance of " + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ", but is " + value.constructor.name : ""));
  }
  return value;
}
function abstractMethodFail(methodName) {
  throw new TypeError('abstract method "' + methodName + '" is not implemented');
}
function _init$n() {
  Duration.ZERO = new Duration(0, 0);
}
function _init$m() {
  YearConstants.MIN_VALUE = -999999;
  YearConstants.MAX_VALUE = 999999;
}
function _init$l() {
  ChronoUnit.NANOS = new ChronoUnit("Nanos", Duration.ofNanos(1));
  ChronoUnit.MICROS = new ChronoUnit("Micros", Duration.ofNanos(1e3));
  ChronoUnit.MILLIS = new ChronoUnit("Millis", Duration.ofNanos(1e6));
  ChronoUnit.SECONDS = new ChronoUnit("Seconds", Duration.ofSeconds(1));
  ChronoUnit.MINUTES = new ChronoUnit("Minutes", Duration.ofSeconds(60));
  ChronoUnit.HOURS = new ChronoUnit("Hours", Duration.ofSeconds(3600));
  ChronoUnit.HALF_DAYS = new ChronoUnit("HalfDays", Duration.ofSeconds(43200));
  ChronoUnit.DAYS = new ChronoUnit("Days", Duration.ofSeconds(86400));
  ChronoUnit.WEEKS = new ChronoUnit("Weeks", Duration.ofSeconds(7 * 86400));
  ChronoUnit.MONTHS = new ChronoUnit("Months", Duration.ofSeconds(31556952 / 12));
  ChronoUnit.YEARS = new ChronoUnit("Years", Duration.ofSeconds(31556952));
  ChronoUnit.DECADES = new ChronoUnit("Decades", Duration.ofSeconds(31556952 * 10));
  ChronoUnit.CENTURIES = new ChronoUnit("Centuries", Duration.ofSeconds(31556952 * 100));
  ChronoUnit.MILLENNIA = new ChronoUnit("Millennia", Duration.ofSeconds(31556952 * 1e3));
  ChronoUnit.ERAS = new ChronoUnit("Eras", Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));
  ChronoUnit.FOREVER = new ChronoUnit("Forever", Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
}
function _init$k() {
  ChronoField.NANO_OF_SECOND = new ChronoField("NanoOfSecond", ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));
  ChronoField.NANO_OF_DAY = new ChronoField("NanoOfDay", ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e9 - 1));
  ChronoField.MICRO_OF_SECOND = new ChronoField("MicroOfSecond", ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));
  ChronoField.MICRO_OF_DAY = new ChronoField("MicroOfDay", ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e6 - 1));
  ChronoField.MILLI_OF_SECOND = new ChronoField("MilliOfSecond", ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));
  ChronoField.MILLI_OF_DAY = new ChronoField("MilliOfDay", ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1e3 - 1));
  ChronoField.SECOND_OF_MINUTE = new ChronoField("SecondOfMinute", ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));
  ChronoField.SECOND_OF_DAY = new ChronoField("SecondOfDay", ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));
  ChronoField.MINUTE_OF_HOUR = new ChronoField("MinuteOfHour", ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));
  ChronoField.MINUTE_OF_DAY = new ChronoField("MinuteOfDay", ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));
  ChronoField.HOUR_OF_AMPM = new ChronoField("HourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));
  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField("ClockHourOfAmPm", ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));
  ChronoField.HOUR_OF_DAY = new ChronoField("HourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));
  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField("ClockHourOfDay", ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));
  ChronoField.AMPM_OF_DAY = new ChronoField("AmPmOfDay", ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));
  ChronoField.DAY_OF_WEEK = new ChronoField("DayOfWeek", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField("AlignedDayOfWeekInMonth", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField("AlignedDayOfWeekInYear", ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.DAY_OF_MONTH = new ChronoField("DayOfMonth", ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), "day");
  ChronoField.DAY_OF_YEAR = new ChronoField("DayOfYear", ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));
  ChronoField.EPOCH_DAY = new ChronoField("EpochDay", ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971));
  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField("AlignedWeekOfMonth", ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));
  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField("AlignedWeekOfYear", ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));
  ChronoField.MONTH_OF_YEAR = new ChronoField("MonthOfYear", ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), "month");
  ChronoField.PROLEPTIC_MONTH = new ChronoField("ProlepticMonth", ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));
  ChronoField.YEAR_OF_ERA = new ChronoField("YearOfEra", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));
  ChronoField.YEAR = new ChronoField("Year", ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), "year");
  ChronoField.ERA = new ChronoField("Era", ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));
  ChronoField.INSTANT_SECONDS = new ChronoField("InstantSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));
  ChronoField.OFFSET_SECONDS = new ChronoField("OffsetSeconds", ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
}
function createTemporalQuery(name2, queryFromFunction) {
  var ExtendedTemporalQuery = function(_TemporalQuery) {
    _inheritsLoose(ExtendedTemporalQuery2, _TemporalQuery);
    function ExtendedTemporalQuery2() {
      return _TemporalQuery.apply(this, arguments) || this;
    }
    return ExtendedTemporalQuery2;
  }(TemporalQuery);
  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
  return new ExtendedTemporalQuery(name2);
}
function _init$j() {
  DayOfWeek.MONDAY = new DayOfWeek(0, "MONDAY");
  DayOfWeek.TUESDAY = new DayOfWeek(1, "TUESDAY");
  DayOfWeek.WEDNESDAY = new DayOfWeek(2, "WEDNESDAY");
  DayOfWeek.THURSDAY = new DayOfWeek(3, "THURSDAY");
  DayOfWeek.FRIDAY = new DayOfWeek(4, "FRIDAY");
  DayOfWeek.SATURDAY = new DayOfWeek(5, "SATURDAY");
  DayOfWeek.SUNDAY = new DayOfWeek(6, "SUNDAY");
  DayOfWeek.FROM = createTemporalQuery("DayOfWeek.FROM", function(temporal) {
    return DayOfWeek.from(temporal);
  });
  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
}
function _init$i() {
  Month.JANUARY = new Month(1, "JANUARY");
  Month.FEBRUARY = new Month(2, "FEBRUARY");
  Month.MARCH = new Month(3, "MARCH");
  Month.APRIL = new Month(4, "APRIL");
  Month.MAY = new Month(5, "MAY");
  Month.JUNE = new Month(6, "JUNE");
  Month.JULY = new Month(7, "JULY");
  Month.AUGUST = new Month(8, "AUGUST");
  Month.SEPTEMBER = new Month(9, "SEPTEMBER");
  Month.OCTOBER = new Month(10, "OCTOBER");
  Month.NOVEMBER = new Month(11, "NOVEMBER");
  Month.DECEMBER = new Month(12, "DECEMBER");
  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
}
function _init$h() {
  Period.ofDays(0);
}
function _init$g() {
  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
}
function _init$f() {
  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEARS = new Unit("WeekBasedYears", Duration.ofSeconds(31556952));
  QUARTER_YEARS = new Unit("QuarterYears", Duration.ofSeconds(31556952 / 4));
  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
  IsoFields.QUARTER_YEARS = QUARTER_YEARS;
  LocalDate.prototype.isoWeekOfWeekyear = function() {
    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
  };
  LocalDate.prototype.isoWeekyear = function() {
    return this.get(IsoFields.WEEK_BASED_YEAR);
  };
}
function _init$e() {
  ReducedPrinterParser.BASE_DATE = LocalDate.of(2e3, 1, 1);
  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
  DateTimeFormatterBuilder.SettingsParser = SettingsParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
}
function _init$d() {
  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral("[").parseCaseSensitive().appendZoneId().appendLiteral("]").toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-W").appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral("-").appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery("PARSED_EXCESS_DAYS", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.excessDays;
    } else {
      return Period.ZERO;
    }
  });
  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery("PARSED_LEAP_SECOND", function(temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.leapSecond;
    } else {
      return false;
    }
  });
}
function _init$c() {
  PARSER$2 = new DateTimeFormatterBuilder().appendLiteral("--").appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral("-").appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();
  MonthDay.FROM = createTemporalQuery("MonthDay.FROM", function(temporal) {
    return MonthDay.from(temporal);
  });
}
function _init$b() {
  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral("-").appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();
  YearMonth.FROM = createTemporalQuery("YearMonth.FROM", function(temporal) {
    return YearMonth.from(temporal);
  });
}
function _init$a() {
  Year.MIN_VALUE = YearConstants.MIN_VALUE;
  Year.MAX_VALUE = YearConstants.MAX_VALUE;
  PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();
  Year.FROM = createTemporalQuery("Year.FROM", function(temporal) {
    return Year.from(temporal);
  });
}
function _init$9() {
  IsoChronology.INSTANCE = new IsoChronology("IsoChronology");
}
function _init$8() {
  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);
  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);
  OffsetTime.FROM = createTemporalQuery("OffsetTime.FROM", function(temporal) {
    return OffsetTime.from(temporal);
  });
}
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}
function _init$7() {
  ZonedDateTime.FROM = createTemporalQuery("ZonedDateTime.FROM", function(temporal) {
    return ZonedDateTime.from(temporal);
  });
}
function _init$6() {
  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
  OffsetDateTime.FROM = createTemporalQuery("OffsetDateTime.FROM", function(temporal) {
    return OffsetDateTime.from(temporal);
  });
}
function _init$5() {
  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);
  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);
  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);
  LocalDate.FROM = createTemporalQuery("LocalDate.FROM", function(temporal) {
    return LocalDate.from(temporal);
  });
}
function _init$4() {
  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);
  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);
  LocalDateTime.FROM = createTemporalQuery("LocalDateTime.FROM", function(temporal) {
    return LocalDateTime.from(temporal);
  });
}
function _init$3() {
  LocalTime.HOURS = [];
  for (var hour = 0; hour < 24; hour++) {
    LocalTime.of(hour, 0, 0, 0);
  }
  LocalTime.MIN = LocalTime.HOURS[0];
  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);
  LocalTime.MIDNIGHT = LocalTime.HOURS[0];
  LocalTime.NOON = LocalTime.HOURS[12];
  LocalTime.FROM = createTemporalQuery("LocalTime.FROM", function(temporal) {
    return LocalTime.from(temporal);
  });
}
function _init$2() {
  Instant.MIN_SECONDS = -31619119219200;
  Instant.MAX_SECONDS = 31494816403199;
  Instant.EPOCH = new Instant(0, 0);
  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
  Instant.FROM = createTemporalQuery("Instant.FROM", function(temporal) {
    return Instant.from(temporal);
  });
}
function _init$1() {
  TemporalQueries.ZONE_ID = createTemporalQuery("ZONE_ID", function(temporal) {
    return temporal.query(TemporalQueries.ZONE_ID);
  });
  TemporalQueries.CHRONO = createTemporalQuery("CHRONO", function(temporal) {
    return temporal.query(TemporalQueries.CHRONO);
  });
  TemporalQueries.PRECISION = createTemporalQuery("PRECISION", function(temporal) {
    return temporal.query(TemporalQueries.PRECISION);
  });
  TemporalQueries.OFFSET = createTemporalQuery("OFFSET", function(temporal) {
    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
    }
    return null;
  });
  TemporalQueries.ZONE = createTemporalQuery("ZONE", function(temporal) {
    var zone = temporal.query(TemporalQueries.ZONE_ID);
    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
  });
  TemporalQueries.LOCAL_DATE = createTemporalQuery("LOCAL_DATE", function(temporal) {
    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
    }
    return null;
  });
  TemporalQueries.LOCAL_TIME = createTemporalQuery("LOCAL_TIME", function(temporal) {
    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
    }
    return null;
  });
}
function _init() {
  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();
  ZoneId.systemDefault = ZoneIdFactory.systemDefault;
  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
  ZoneId.of = ZoneIdFactory.of;
  ZoneId.ofOffset = ZoneIdFactory.ofOffset;
  ZoneId.from = ZoneIdFactory.from;
  ZoneOffset.from = ZoneIdFactory.from;
  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
}
function init() {
  if (isInit) {
    return;
  }
  isInit = true;
  _init$m();
  _init$n();
  _init$l();
  _init$k();
  _init$3();
  _init$f();
  _init$1();
  _init$j();
  _init$2();
  _init$5();
  _init$4();
  _init$a();
  _init$i();
  _init$b();
  _init$c();
  _init$h();
  _init$g();
  _init$7();
  _init();
  _init$9();
  _init$d();
  _init$e();
  _init$6();
  _init$8();
}
function convert(temporal, zone) {
  return new ToNativeJsConverter(temporal, zone);
}
function nativeJs(date, zone) {
  if (zone === void 0) {
    zone = ZoneId.systemDefault();
  }
  requireNonNull(date, "date");
  requireNonNull(zone, "zone");
  if (date instanceof Date) {
    return Instant.ofEpochMilli(date.getTime()).atZone(zone);
  } else if (typeof date.toDate === "function" && date.toDate() instanceof Date) {
    return Instant.ofEpochMilli(date.toDate().getTime()).atZone(zone);
  }
  throw new IllegalArgumentException("date must be a javascript Date or a moment instance");
}
function bindUse(jsJoda) {
  var used = [];
  return function use2(fn) {
    if (!~used.indexOf(fn)) {
      fn(jsJoda);
      used.push(fn);
    }
    return jsJoda;
  };
}
var DateTimeException, DateTimeParseException, UnsupportedTemporalTypeException, ArithmeticException, IllegalArgumentException, IllegalStateException, NullPointerException, assert$1, MAX_SAFE_INTEGER, MIN_SAFE_INTEGER, MathUtil, Enum, TemporalAmount, TemporalUnit, Duration, YearConstants, ChronoUnit, TemporalField, ValueRange, ChronoField, TemporalQueries, TemporalAccessor, TemporalQuery, DayOfWeek, ENUMS, Month, MONTHS, PATTERN, Period, ParsePosition, EnumMap, ResolverStyle, Temporal, ChronoLocalDate, StringUtil, ZoneId, ZoneRules, Fixed, SECONDS_CACHE, ID_CACHE, ZoneOffset, DateTimeBuilder, DateTimeParseContext, Parsed, DateTimePrintContext, IsoFields, QUARTER_DAYS, Field, DAY_OF_QUARTER_FIELD, QUARTER_OF_YEAR_FIELD, WEEK_OF_WEEK_BASED_YEAR_FIELD, WEEK_BASED_YEAR_FIELD, Unit, DAY_OF_QUARTER, QUARTER_OF_YEAR, WEEK_OF_WEEK_BASED_YEAR, WEEK_BASED_YEAR, WEEK_BASED_YEARS, QUARTER_YEARS, DecimalStyle, SignStyle, TextStyle, CharLiteralPrinterParser, CompositePrinterParser, FractionPrinterParser, MAX_WIDTH$1, EXCEED_POINTS, NumberPrinterParser, ReducedPrinterParser, PATTERNS, OffsetIdPrinterParser, PadPrinterParserDecorator, SettingsParser, StringLiteralPrinterParser, ZoneRulesProvider, ZoneRegion, ZoneIdPrinterParser, ZoneIdTree, ZoneIdTreeMap, zoneIdTree, MAX_WIDTH, DateTimeFormatterBuilder, SECONDS_PER_10000_YEARS, SECONDS_0000_TO_1970, InstantPrinterParser, DefaultingParser, StringBuilder, DateTimeFormatter, MonthDay, PARSER$2, YearMonth, PARSER$1, Year, PARSER, TemporalAdjuster, TemporalAdjusters, Impl, DayOfWeekInMonth, RelativeDayOfWeek, IsoChronology, OffsetTime, ChronoZonedDateTime, ZonedDateTime, OffsetDateTime, DAYS_PER_CYCLE, DAYS_0000_TO_1970, LocalDate, ChronoLocalDateTime, LocalDateTime, LocalTime, NANOS_PER_MILLI, Instant, Clock, SystemClock, FixedClock, OffsetClock, ZoneOffsetTransition, SystemDefaultZoneRules, SystemDefaultZoneId, ZoneIdFactory, SYSTEM_DEFAULT_ZONE_ID_INSTANCE, isInit, ToNativeJsConverter, _, jsJodaExports, use;
var init_js_joda_esm = __esm({
  "node_modules/@js-joda/core/dist/js-joda.esm.js"() {
    init_process();
    init_buffer();
    DateTimeException = createErrorType("DateTimeException", messageWithCause);
    DateTimeParseException = createErrorType("DateTimeParseException", messageForDateTimeParseException);
    UnsupportedTemporalTypeException = createErrorType("UnsupportedTemporalTypeException", null, DateTimeException);
    ArithmeticException = createErrorType("ArithmeticException");
    IllegalArgumentException = createErrorType("IllegalArgumentException");
    IllegalStateException = createErrorType("IllegalStateException");
    NullPointerException = createErrorType("NullPointerException");
    assert$1 = Object.freeze({
      __proto__: null,
      assert,
      requireNonNull,
      requireInstance,
      abstractMethodFail
    });
    MAX_SAFE_INTEGER = 9007199254740991;
    MIN_SAFE_INTEGER = -9007199254740991;
    MathUtil = function() {
      function MathUtil2() {
      }
      MathUtil2.intDiv = function intDiv(x, y) {
        var r = x / y;
        r = MathUtil2.roundDown(r);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.intMod = function intMod(x, y) {
        var r = x - MathUtil2.intDiv(x, y) * y;
        r = MathUtil2.roundDown(r);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.roundDown = function roundDown(r) {
        if (r < 0) {
          return Math.ceil(r);
        } else {
          return Math.floor(r);
        }
      };
      MathUtil2.floorDiv = function floorDiv(x, y) {
        var r = Math.floor(x / y);
        return MathUtil2.safeZero(r);
      };
      MathUtil2.floorMod = function floorMod(x, y) {
        var r = x - MathUtil2.floorDiv(x, y) * y;
        return MathUtil2.safeZero(r);
      };
      MathUtil2.safeAdd = function safeAdd(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 0) {
          return MathUtil2.safeZero(y);
        }
        if (y === 0) {
          return MathUtil2.safeZero(x);
        }
        var r = MathUtil2.safeToInt(x + y);
        if (r === x || r === y) {
          throw new ArithmeticException("Invalid addition beyond MAX_SAFE_INTEGER!");
        }
        return r;
      };
      MathUtil2.safeSubtract = function safeSubtract(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 0 && y === 0) {
          return 0;
        } else if (x === 0) {
          return MathUtil2.safeZero(-1 * y);
        } else if (y === 0) {
          return MathUtil2.safeZero(x);
        }
        return MathUtil2.safeToInt(x - y);
      };
      MathUtil2.safeMultiply = function safeMultiply(x, y) {
        MathUtil2.verifyInt(x);
        MathUtil2.verifyInt(y);
        if (x === 1) {
          return MathUtil2.safeZero(y);
        }
        if (y === 1) {
          return MathUtil2.safeZero(x);
        }
        if (x === 0 || y === 0) {
          return 0;
        }
        var r = MathUtil2.safeToInt(x * y);
        if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
          throw new ArithmeticException("Multiplication overflows: " + x + " * " + y);
        }
        return r;
      };
      MathUtil2.parseInt = function(_parseInt) {
        function parseInt2(_x) {
          return _parseInt.apply(this, arguments);
        }
        parseInt2.toString = function() {
          return _parseInt.toString();
        };
        return parseInt2;
      }(function(value) {
        var r = parseInt(value);
        return MathUtil2.safeToInt(r);
      });
      MathUtil2.safeToInt = function safeToInt(value) {
        MathUtil2.verifyInt(value);
        return MathUtil2.safeZero(value);
      };
      MathUtil2.verifyInt = function verifyInt(value) {
        if (value == null) {
          throw new ArithmeticException("Invalid value: '" + value + "', using null or undefined as argument");
        }
        if (isNaN(value)) {
          throw new ArithmeticException("Invalid int value, using NaN as argument");
        }
        if (value % 1 !== 0) {
          throw new ArithmeticException("Invalid value: '" + value + "' is a float");
        }
        if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
          throw new ArithmeticException("Calculation overflows an int: " + value);
        }
      };
      MathUtil2.safeZero = function safeZero(value) {
        return value === 0 ? 0 : +value;
      };
      MathUtil2.compareNumbers = function compareNumbers(a, b) {
        if (a < b) {
          return -1;
        }
        if (a > b) {
          return 1;
        }
        return 0;
      };
      MathUtil2.smi = function smi(int) {
        return int >>> 1 & 1073741824 | int & 3221225471;
      };
      MathUtil2.hash = function hash(number) {
        if (number !== number || number === Infinity) {
          return 0;
        }
        var result = number;
        while (number > 4294967295) {
          number /= 4294967295;
          result ^= number;
        }
        return MathUtil2.smi(result);
      };
      MathUtil2.hashCode = function hashCode() {
        var result = 17;
        for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
          numbers[_key] = arguments[_key];
        }
        for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {
          var n = _numbers[_i];
          result = (result << 5) - result + MathUtil2.hash(n);
        }
        return MathUtil2.hash(result);
      };
      return MathUtil2;
    }();
    MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
    MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;
    Enum = function() {
      function Enum2(name2) {
        this._name = name2;
      }
      var _proto = Enum2.prototype;
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Enum2;
    }();
    TemporalAmount = function() {
      function TemporalAmount2() {
      }
      var _proto = TemporalAmount2.prototype;
      _proto.get = function get(unit) {
        abstractMethodFail("get");
      };
      _proto.units = function units() {
        abstractMethodFail("units");
      };
      _proto.addTo = function addTo(temporal) {
        abstractMethodFail("addTo");
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        abstractMethodFail("subtractFrom");
      };
      return TemporalAmount2;
    }();
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
      TemporalAmount.prototype[Symbol.toPrimitive] = function(hint) {
        if (hint !== "number") {
          return this.toString();
        }
        throw new TypeError("A conversion from TemporalAmount to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
      };
    }
    TemporalUnit = function() {
      function TemporalUnit2() {
      }
      var _proto = TemporalUnit2.prototype;
      _proto.duration = function duration() {
        abstractMethodFail("duration");
      };
      _proto.isDurationEstimated = function isDurationEstimated() {
        abstractMethodFail("isDurationEstimated");
      };
      _proto.isDateBased = function isDateBased() {
        abstractMethodFail("isDateBased");
      };
      _proto.isTimeBased = function isTimeBased() {
        abstractMethodFail("isTimeBased");
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        abstractMethodFail("isSupportedBy");
      };
      _proto.addTo = function addTo(dateTime, periodToAdd) {
        abstractMethodFail("addTo");
      };
      _proto.between = function between(temporal1, temporal2) {
        abstractMethodFail("between");
      };
      return TemporalUnit2;
    }();
    Duration = function(_TemporalAmount) {
      _inheritsLoose(Duration2, _TemporalAmount);
      function Duration2(seconds, nanos) {
        var _this;
        _this = _TemporalAmount.call(this) || this;
        _this._seconds = MathUtil.safeToInt(seconds);
        _this._nanos = MathUtil.safeToInt(nanos);
        return _this;
      }
      Duration2.ofDays = function ofDays(days) {
        return Duration2._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
      };
      Duration2.ofHours = function ofHours(hours) {
        return Duration2._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
      };
      Duration2.ofMinutes = function ofMinutes(minutes) {
        return Duration2._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
      };
      Duration2.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        return Duration2._create(secs, nos);
      };
      Duration2.ofMillis = function ofMillis(millis) {
        var secs = MathUtil.intDiv(millis, 1e3);
        var mos = MathUtil.intMod(millis, 1e3);
        if (mos < 0) {
          mos += 1e3;
          secs--;
        }
        return Duration2._create(secs, mos * 1e6);
      };
      Duration2.ofNanos = function ofNanos(nanos) {
        var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);
        if (nos < 0) {
          nos += LocalTime.NANOS_PER_SECOND;
          secs--;
        }
        return this._create(secs, nos);
      };
      Duration2.of = function of(amount, unit) {
        return Duration2.ZERO.plus(amount, unit);
      };
      Duration2.from = function from(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount);
        var duration = Duration2.ZERO;
        amount.units().forEach(function(unit) {
          duration = duration.plus(amount.get(unit), unit);
        });
        return duration;
      };
      Duration2.between = function between(startInclusive, endExclusive) {
        requireNonNull(startInclusive, "startInclusive");
        requireNonNull(endExclusive, "endExclusive");
        var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
        var nanos = 0;
        if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
          try {
            var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
            nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;
            if (secs > 0 && nanos < 0) {
              nanos += LocalTime.NANOS_PER_SECOND;
            } else if (secs < 0 && nanos > 0) {
              nanos -= LocalTime.NANOS_PER_SECOND;
            } else if (secs === 0 && nanos !== 0) {
              var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
              secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
            }
          } catch (e) {
          }
        }
        return this.ofSeconds(secs, nanos);
      };
      Duration2.parse = function parse2(text) {
        requireNonNull(text, "text");
        var PATTERN2 = new RegExp("([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?", "i");
        var matches = PATTERN2.exec(text);
        if (matches !== null) {
          if ("T" === matches[3] === false) {
            var negate = "-" === matches[1];
            var dayMatch = matches[2];
            var hourMatch = matches[4];
            var minuteMatch = matches[5];
            var secondMatch = matches[6];
            var fractionMatch = matches[7];
            if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
              var daysAsSecs = Duration2._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, "days");
              var hoursAsSecs = Duration2._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, "hours");
              var minsAsSecs = Duration2._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, "minutes");
              var seconds = Duration2._parseNumber(text, secondMatch, 1, "seconds");
              var negativeSecs = secondMatch != null && secondMatch.charAt(0) === "-";
              var nanos = Duration2._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);
              try {
                return Duration2._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
              } catch (ex) {
                throw new DateTimeParseException("Text cannot be parsed to a Duration: overflow", text, 0, ex);
              }
            }
          }
        }
        throw new DateTimeParseException("Text cannot be parsed to a Duration", text, 0);
      };
      Duration2._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {
        if (parsed == null) {
          return 0;
        }
        try {
          if (parsed[0] === "+") {
            parsed = parsed.substring(1);
          }
          return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
        } catch (ex) {
          throw new DateTimeParseException("Text cannot be parsed to a Duration: " + errorText, text, 0, ex);
        }
      };
      Duration2._parseFraction = function _parseFraction(text, parsed, negate) {
        if (parsed == null || parsed.length === 0) {
          return 0;
        }
        parsed = (parsed + "000000000").substring(0, 9);
        return parseFloat(parsed) * negate;
      };
      Duration2._create = function _create() {
        if (arguments.length <= 2) {
          return Duration2._createSecondsNanos(arguments[0], arguments[1]);
        } else {
          return Duration2._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        }
      };
      Duration2._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
        var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));
        if (negate) {
          return Duration2.ofSeconds(seconds, nanos).negated();
        }
        return Duration2.ofSeconds(seconds, nanos);
      };
      Duration2._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {
        if (seconds === void 0) {
          seconds = 0;
        }
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        if (seconds === 0 && nanoAdjustment === 0) {
          return Duration2.ZERO;
        }
        return new Duration2(seconds, nanoAdjustment);
      };
      var _proto = Duration2.prototype;
      _proto.get = function get(unit) {
        if (unit === ChronoUnit.SECONDS) {
          return this._seconds;
        } else if (unit === ChronoUnit.NANOS) {
          return this._nanos;
        } else {
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
      };
      _proto.units = function units() {
        return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
      };
      _proto.isZero = function isZero() {
        return this._seconds === 0 && this._nanos === 0;
      };
      _proto.isNegative = function isNegative() {
        return this._seconds < 0;
      };
      _proto.seconds = function seconds() {
        return this._seconds;
      };
      _proto.nano = function nano() {
        return this._nanos;
      };
      _proto.withSeconds = function withSeconds(seconds) {
        return Duration2._create(seconds, this._nanos);
      };
      _proto.withNanos = function withNanos(nanoOfSecond) {
        ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
        return Duration2._create(this._seconds, nanoOfSecond);
      };
      _proto.plusDuration = function plusDuration(duration) {
        requireNonNull(duration, "duration");
        return this.plus(duration.seconds(), duration.nano());
      };
      _proto.plus = function plus(durationOrNumber, unitOrNumber) {
        if (arguments.length === 1) {
          return this.plusDuration(durationOrNumber);
        } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
          return this.plusAmountUnit(durationOrNumber, unitOrNumber);
        } else {
          return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
        }
      };
      _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.DAYS) {
          return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
        }
        if (unit.isDurationEstimated()) {
          throw new UnsupportedTemporalTypeException("Unit must not have an estimated duration");
        }
        if (amountToAdd === 0) {
          return this;
        }
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1e6 * 1e3) * 1e3, MathUtil.intMod(amountToAdd, 1e6 * 1e3) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusMillis(amountToAdd);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
          }
          return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
        }
        var duration = unit.duration().multipliedBy(amountToAdd);
        return this.plusSecondsNanos(duration.seconds(), duration.nano());
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
      };
      _proto.plusHours = function plusHours(hoursToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
      };
      _proto.plusMinutes = function plusMinutes(minutesToAdd) {
        return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        return this.plusSecondsNanos(secondsToAdd, 0);
      };
      _proto.plusMillis = function plusMillis(millisToAdd) {
        return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * 1e6);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        return this.plusSecondsNanos(0, nanosToAdd);
      };
      _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
        requireNonNull(secondsToAdd, "secondsToAdd");
        requireNonNull(nanosToAdd, "nanosToAdd");
        if (secondsToAdd === 0 && nanosToAdd === 0) {
          return this;
        }
        var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
        epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
        nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
        var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
        return Duration2.ofSeconds(epochSec, nanoAdjustment);
      };
      _proto.minus = function minus(durationOrNumber, unit) {
        if (arguments.length === 1) {
          return this.minusDuration(durationOrNumber);
        } else {
          return this.minusAmountUnit(durationOrNumber, unit);
        }
      };
      _proto.minusDuration = function minusDuration(duration) {
        requireNonNull(duration, "duration");
        var secsToSubtract = duration.seconds();
        var nanosToSubtract = duration.nano();
        if (secsToSubtract === MIN_SAFE_INTEGER) {
          return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
        }
        return this.plus(-secsToSubtract, -nanosToSubtract);
      };
      _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
      };
      _proto.minusHours = function minusHours(hoursToSubtract) {
        return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
      };
      _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
        return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
      };
      _proto.minusMillis = function minusMillis(millisToSubtract) {
        return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
      };
      _proto.multipliedBy = function multipliedBy(multiplicand) {
        if (multiplicand === 0) {
          return Duration2.ZERO;
        }
        if (multiplicand === 1) {
          return this;
        }
        var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
        var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
        secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
        nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
        return Duration2.ofSeconds(secs, nos);
      };
      _proto.dividedBy = function dividedBy(divisor) {
        if (divisor === 0) {
          throw new ArithmeticException("Cannot divide by zero");
        }
        if (divisor === 1) {
          return this;
        }
        var secs = MathUtil.intDiv(this._seconds, divisor);
        var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.intDiv(this._nanos, divisor);
        nos = secsMod + nos;
        return Duration2.ofSeconds(secs, nos);
      };
      _proto.negated = function negated() {
        return this.multipliedBy(-1);
      };
      _proto.abs = function abs() {
        return this.isNegative() ? this.negated() : this;
      };
      _proto.addTo = function addTo(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._seconds !== 0) {
          temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
        }
        if (this._nanos !== 0) {
          temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
        }
        return temporal;
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._seconds !== 0) {
          temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
        }
        if (this._nanos !== 0) {
          temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
        }
        return temporal;
      };
      _proto.toDays = function toDays() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
      };
      _proto.toHours = function toHours() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
      };
      _proto.toMinutes = function toMinutes() {
        return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
      };
      _proto.toMillis = function toMillis() {
        var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1e3));
        millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1e6));
        return millis;
      };
      _proto.toNanos = function toNanos() {
        var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
        totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
        return totalNanos;
      };
      _proto.compareTo = function compareTo(otherDuration) {
        requireNonNull(otherDuration, "otherDuration");
        requireInstance(otherDuration, Duration2, "otherDuration");
        var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());
        if (cmp !== 0) {
          return cmp;
        }
        return this._nanos - otherDuration.nano();
      };
      _proto.equals = function equals(otherDuration) {
        if (this === otherDuration) {
          return true;
        }
        if (otherDuration instanceof Duration2) {
          return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
        }
        return false;
      };
      _proto.toString = function toString() {
        if (this === Duration2.ZERO) {
          return "PT0S";
        }
        var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
        var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
        var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
        var rval = "PT";
        if (hours !== 0) {
          rval += hours + "H";
        }
        if (minutes !== 0) {
          rval += minutes + "M";
        }
        if (secs === 0 && this._nanos === 0 && rval.length > 2) {
          return rval;
        }
        if (secs < 0 && this._nanos > 0) {
          if (secs === -1) {
            rval += "-0";
          } else {
            rval += secs + 1;
          }
        } else {
          rval += secs;
        }
        if (this._nanos > 0) {
          rval += ".";
          var nanoString;
          if (secs < 0) {
            nanoString = "" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
          } else {
            nanoString = "" + (LocalTime.NANOS_PER_SECOND + this._nanos);
          }
          nanoString = nanoString.slice(1, nanoString.length);
          rval += nanoString;
          while (rval.charAt(rval.length - 1) === "0") {
            rval = rval.slice(0, rval.length - 1);
          }
        }
        rval += "S";
        return rval;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Duration2;
    }(TemporalAmount);
    YearConstants = function YearConstants2() {
    };
    ChronoUnit = function(_TemporalUnit) {
      _inheritsLoose(ChronoUnit2, _TemporalUnit);
      function ChronoUnit2(name2, estimatedDuration) {
        var _this;
        _this = _TemporalUnit.call(this) || this;
        _this._name = name2;
        _this._duration = estimatedDuration;
        return _this;
      }
      var _proto = ChronoUnit2.prototype;
      _proto.duration = function duration() {
        return this._duration;
      };
      _proto.isDurationEstimated = function isDurationEstimated() {
        return this.isDateBased() || this === ChronoUnit2.FOREVER;
      };
      _proto.isDateBased = function isDateBased() {
        return this.compareTo(ChronoUnit2.DAYS) >= 0 && this !== ChronoUnit2.FOREVER;
      };
      _proto.isTimeBased = function isTimeBased() {
        return this.compareTo(ChronoUnit2.DAYS) < 0;
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        if (this === ChronoUnit2.FOREVER) {
          return false;
        }
        try {
          temporal.plus(1, this);
          return true;
        } catch (e) {
          try {
            temporal.plus(-1, this);
            return true;
          } catch (e2) {
            return false;
          }
        }
      };
      _proto.addTo = function addTo(temporal, amount) {
        return temporal.plus(amount, this);
      };
      _proto.between = function between(temporal1, temporal2) {
        return temporal1.until(temporal2, this);
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.compareTo = function compareTo(other) {
        return this.duration().compareTo(other.duration());
      };
      return ChronoUnit2;
    }(TemporalUnit);
    TemporalField = function() {
      function TemporalField2() {
      }
      var _proto = TemporalField2.prototype;
      _proto.isDateBased = function isDateBased() {
        abstractMethodFail("isDateBased");
      };
      _proto.isTimeBased = function isTimeBased() {
        abstractMethodFail("isTimeBased");
      };
      _proto.baseUnit = function baseUnit() {
        abstractMethodFail("baseUnit");
      };
      _proto.rangeUnit = function rangeUnit() {
        abstractMethodFail("rangeUnit");
      };
      _proto.range = function range() {
        abstractMethodFail("range");
      };
      _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
        abstractMethodFail("rangeRefinedBy");
      };
      _proto.getFrom = function getFrom(temporal) {
        abstractMethodFail("getFrom");
      };
      _proto.adjustInto = function adjustInto(temporal, newValue) {
        abstractMethodFail("adjustInto");
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        abstractMethodFail("isSupportedBy");
      };
      _proto.displayName = function displayName() {
        abstractMethodFail("displayName");
      };
      _proto.equals = function equals(other) {
        abstractMethodFail("equals");
      };
      _proto.name = function name2() {
        abstractMethodFail("name");
      };
      return TemporalField2;
    }();
    ValueRange = function() {
      function ValueRange2(minSmallest, minLargest, maxSmallest, maxLargest) {
        assert(!(minSmallest > minLargest), "Smallest minimum value '" + minSmallest + "' must be less than largest minimum value '" + minLargest + "'", IllegalArgumentException);
        assert(!(maxSmallest > maxLargest), "Smallest maximum value '" + maxSmallest + "' must be less than largest maximum value '" + maxLargest + "'", IllegalArgumentException);
        assert(!(minLargest > maxLargest), "Minimum value '" + minLargest + "' must be less than maximum value '" + maxLargest + "'", IllegalArgumentException);
        this._minSmallest = minSmallest;
        this._minLargest = minLargest;
        this._maxLargest = maxLargest;
        this._maxSmallest = maxSmallest;
      }
      var _proto = ValueRange2.prototype;
      _proto.isFixed = function isFixed() {
        return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
      };
      _proto.minimum = function minimum() {
        return this._minSmallest;
      };
      _proto.largestMinimum = function largestMinimum() {
        return this._minLargest;
      };
      _proto.maximum = function maximum() {
        return this._maxLargest;
      };
      _proto.smallestMaximum = function smallestMaximum() {
        return this._maxSmallest;
      };
      _proto.isValidValue = function isValidValue(value) {
        return this.minimum() <= value && value <= this.maximum();
      };
      _proto.checkValidValue = function checkValidValue(value, field) {
        var msg;
        if (!this.isValidValue(value)) {
          if (field != null) {
            msg = "Invalid value for " + field + " (valid values " + this.toString() + "): " + value;
          } else {
            msg = "Invalid value (valid values " + this.toString() + "): " + value;
          }
          return assert(false, msg, DateTimeException);
        }
        return value;
      };
      _proto.checkValidIntValue = function checkValidIntValue(value, field) {
        if (this.isValidIntValue(value) === false) {
          throw new DateTimeException("Invalid int value for " + field + ": " + value);
        }
        return value;
      };
      _proto.isValidIntValue = function isValidIntValue(value) {
        return this.isIntValue() && this.isValidValue(value);
      };
      _proto.isIntValue = function isIntValue() {
        return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
      };
      _proto.equals = function equals(other) {
        if (other === this) {
          return true;
        }
        if (other instanceof ValueRange2) {
          return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
      };
      _proto.toString = function toString() {
        var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? "/" + this.largestMinimum() : "");
        str += " - ";
        str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? "/" + this.maximum() : "");
        return str;
      };
      ValueRange2.of = function of() {
        if (arguments.length === 2) {
          return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[1]);
        } else if (arguments.length === 3) {
          return new ValueRange2(arguments[0], arguments[0], arguments[1], arguments[2]);
        } else if (arguments.length === 4) {
          return new ValueRange2(arguments[0], arguments[1], arguments[2], arguments[3]);
        } else {
          return assert(false, "Invalid number of arguments " + arguments.length, IllegalArgumentException);
        }
      };
      return ValueRange2;
    }();
    ChronoField = function(_TemporalField) {
      _inheritsLoose(ChronoField2, _TemporalField);
      ChronoField2.byName = function byName(fieldName) {
        for (var prop in ChronoField2) {
          if (ChronoField2[prop]) {
            if (ChronoField2[prop] instanceof ChronoField2 && ChronoField2[prop].name() === fieldName) {
              return ChronoField2[prop];
            }
          }
        }
      };
      function ChronoField2(name2, baseUnit, rangeUnit, range) {
        var _this;
        _this = _TemporalField.call(this) || this;
        _this._name = name2;
        _this._baseUnit = baseUnit;
        _this._rangeUnit = rangeUnit;
        _this._range = range;
        return _this;
      }
      var _proto = ChronoField2.prototype;
      _proto.name = function name2() {
        return this._name;
      };
      _proto.baseUnit = function baseUnit() {
        return this._baseUnit;
      };
      _proto.rangeUnit = function rangeUnit() {
        return this._rangeUnit;
      };
      _proto.range = function range() {
        return this._range;
      };
      _proto.displayName = function displayName() {
        return this.toString();
      };
      _proto.checkValidValue = function checkValidValue(value) {
        return this.range().checkValidValue(value, this);
      };
      _proto.checkValidIntValue = function checkValidIntValue(value) {
        return this.range().checkValidIntValue(value, this);
      };
      _proto.isDateBased = function isDateBased() {
        var dateBased = this === ChronoField2.DAY_OF_WEEK || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField2.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField2.DAY_OF_MONTH || this === ChronoField2.DAY_OF_YEAR || this === ChronoField2.EPOCH_DAY || this === ChronoField2.ALIGNED_WEEK_OF_MONTH || this === ChronoField2.ALIGNED_WEEK_OF_YEAR || this === ChronoField2.MONTH_OF_YEAR || this === ChronoField2.PROLEPTIC_MONTH || this === ChronoField2.YEAR_OF_ERA || this === ChronoField2.YEAR || this === ChronoField2.ERA;
        return dateBased;
      };
      _proto.isTimeBased = function isTimeBased() {
        var timeBased = this === ChronoField2.NANO_OF_SECOND || this === ChronoField2.NANO_OF_DAY || this === ChronoField2.MICRO_OF_SECOND || this === ChronoField2.MICRO_OF_DAY || this === ChronoField2.MILLI_OF_SECOND || this === ChronoField2.MILLI_OF_DAY || this === ChronoField2.SECOND_OF_MINUTE || this === ChronoField2.SECOND_OF_DAY || this === ChronoField2.MINUTE_OF_HOUR || this === ChronoField2.MINUTE_OF_DAY || this === ChronoField2.HOUR_OF_AMPM || this === ChronoField2.CLOCK_HOUR_OF_AMPM || this === ChronoField2.HOUR_OF_DAY || this === ChronoField2.CLOCK_HOUR_OF_DAY || this === ChronoField2.AMPM_OF_DAY;
        return timeBased;
      };
      _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return temporal.range(this);
      };
      _proto.getFrom = function getFrom(temporal) {
        return temporal.getLong(this);
      };
      _proto.toString = function toString() {
        return this.name();
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.adjustInto = function adjustInto(temporal, newValue) {
        return temporal.with(this, newValue);
      };
      _proto.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(this);
      };
      return ChronoField2;
    }(TemporalField);
    TemporalQueries = function() {
      function TemporalQueries2() {
      }
      TemporalQueries2.zoneId = function zoneId() {
        return TemporalQueries2.ZONE_ID;
      };
      TemporalQueries2.chronology = function chronology() {
        return TemporalQueries2.CHRONO;
      };
      TemporalQueries2.precision = function precision() {
        return TemporalQueries2.PRECISION;
      };
      TemporalQueries2.zone = function zone() {
        return TemporalQueries2.ZONE;
      };
      TemporalQueries2.offset = function offset() {
        return TemporalQueries2.OFFSET;
      };
      TemporalQueries2.localDate = function localDate() {
        return TemporalQueries2.LOCAL_DATE;
      };
      TemporalQueries2.localTime = function localTime() {
        return TemporalQueries2.LOCAL_TIME;
      };
      return TemporalQueries2;
    }();
    TemporalAccessor = function() {
      function TemporalAccessor2() {
      }
      var _proto = TemporalAccessor2.prototype;
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        abstractMethodFail("getLong");
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (this.isSupported(field)) {
            return field.range();
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.isSupported = function isSupported(field) {
        abstractMethodFail("isSupported");
      };
      return TemporalAccessor2;
    }();
    TemporalQuery = function(_Enum) {
      _inheritsLoose(TemporalQuery2, _Enum);
      function TemporalQuery2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = TemporalQuery2.prototype;
      _proto.queryFrom = function queryFrom(temporal) {
        abstractMethodFail("queryFrom");
      };
      return TemporalQuery2;
    }(Enum);
    DayOfWeek = function(_TemporalAccessor) {
      _inheritsLoose(DayOfWeek2, _TemporalAccessor);
      function DayOfWeek2(ordinal, name2) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._ordinal = ordinal;
        _this._name = name2;
        return _this;
      }
      var _proto = DayOfWeek2.prototype;
      _proto.ordinal = function ordinal() {
        return this._ordinal;
      };
      _proto.name = function name2() {
        return this._name;
      };
      DayOfWeek2.values = function values() {
        return ENUMS.slice();
      };
      DayOfWeek2.valueOf = function valueOf(name2) {
        var ordinal = 0;
        for (ordinal; ordinal < ENUMS.length; ordinal++) {
          if (ENUMS[ordinal].name() === name2) {
            break;
          }
        }
        return DayOfWeek2.of(ordinal + 1);
      };
      DayOfWeek2.of = function of(dayOfWeek) {
        if (dayOfWeek < 1 || dayOfWeek > 7) {
          throw new DateTimeException("Invalid value for DayOfWeek: " + dayOfWeek);
        }
        return ENUMS[dayOfWeek - 1];
      };
      DayOfWeek2.from = function from(temporal) {
        assert(temporal != null, "temporal", NullPointerException);
        if (temporal instanceof DayOfWeek2) {
          return temporal;
        }
        try {
          return DayOfWeek2.of(temporal.get(ChronoField.DAY_OF_WEEK));
        } catch (ex) {
          if (ex instanceof DateTimeException) {
            throw new DateTimeException("Unable to obtain DayOfWeek from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""), ex);
          } else {
            throw ex;
          }
        }
      };
      _proto.value = function value() {
        return this._ordinal + 1;
      };
      _proto.displayName = function displayName(style, locale) {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
      };
      _proto.isSupported = function isSupported(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.DAY_OF_WEEK;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return field.range();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return this.value();
        }
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.DAY_OF_WEEK) {
          return this.value();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.plus = function plus(days) {
        var amount = MathUtil.floorMod(days, 7);
        return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
      };
      _proto.minus = function minus(days) {
        return this.plus(-1 * MathUtil.floorMod(days, 7));
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.DAYS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        assert(_query != null, "query", NullPointerException);
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      _proto.toString = function toString() {
        return this._name;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, DayOfWeek2, "other");
        return this._ordinal - other._ordinal;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return DayOfWeek2;
    }(TemporalAccessor);
    Month = function(_TemporalAccessor) {
      _inheritsLoose(Month2, _TemporalAccessor);
      function Month2(value, name2) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._value = MathUtil.safeToInt(value);
        _this._name = name2;
        return _this;
      }
      var _proto = Month2.prototype;
      _proto.value = function value() {
        return this._value;
      };
      _proto.ordinal = function ordinal() {
        return this._value - 1;
      };
      _proto.name = function name2() {
        return this._name;
      };
      _proto.displayName = function displayName(style, locale) {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented yet!");
      };
      _proto.isSupported = function isSupported(field) {
        if (null === field) {
          return false;
        }
        if (field instanceof ChronoField) {
          return field === ChronoField.MONTH_OF_YEAR;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.get = function get(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return this.value();
        }
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return this.value();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.plus = function plus(months) {
        var amount = MathUtil.intMod(months, 12) + 12;
        var newMonthVal = MathUtil.intMod(this.value() + amount, 12);
        newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
        return Month2.of(newMonthVal);
      };
      _proto.minus = function minus(months) {
        return this.plus(-1 * MathUtil.intMod(months, 12));
      };
      _proto.length = function length(leapYear) {
        switch (this) {
          case Month2.FEBRUARY:
            return leapYear ? 29 : 28;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.minLength = function minLength() {
        switch (this) {
          case Month2.FEBRUARY:
            return 28;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.maxLength = function maxLength() {
        switch (this) {
          case Month2.FEBRUARY:
            return 29;
          case Month2.APRIL:
          case Month2.JUNE:
          case Month2.SEPTEMBER:
          case Month2.NOVEMBER:
            return 30;
          default:
            return 31;
        }
      };
      _proto.firstDayOfYear = function firstDayOfYear(leapYear) {
        var leap = leapYear ? 1 : 0;
        switch (this) {
          case Month2.JANUARY:
            return 1;
          case Month2.FEBRUARY:
            return 32;
          case Month2.MARCH:
            return 60 + leap;
          case Month2.APRIL:
            return 91 + leap;
          case Month2.MAY:
            return 121 + leap;
          case Month2.JUNE:
            return 152 + leap;
          case Month2.JULY:
            return 182 + leap;
          case Month2.AUGUST:
            return 213 + leap;
          case Month2.SEPTEMBER:
            return 244 + leap;
          case Month2.OCTOBER:
            return 274 + leap;
          case Month2.NOVEMBER:
            return 305 + leap;
          case Month2.DECEMBER:
          default:
            return 335 + leap;
        }
      };
      _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {
        switch (this) {
          case Month2.JANUARY:
          case Month2.FEBRUARY:
          case Month2.MARCH:
            return Month2.JANUARY;
          case Month2.APRIL:
          case Month2.MAY:
          case Month2.JUNE:
            return Month2.APRIL;
          case Month2.JULY:
          case Month2.AUGUST:
          case Month2.SEPTEMBER:
            return Month2.JULY;
          case Month2.OCTOBER:
          case Month2.NOVEMBER:
          case Month2.DECEMBER:
          default:
            return Month2.OCTOBER;
        }
      };
      _proto.query = function query(_query) {
        assert(_query != null, "query() parameter must not be null", DateTimeException);
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.MONTHS;
        }
        return _TemporalAccessor.prototype.query.call(this, _query);
      };
      _proto.toString = function toString() {
        switch (this) {
          case Month2.JANUARY:
            return "JANUARY";
          case Month2.FEBRUARY:
            return "FEBRUARY";
          case Month2.MARCH:
            return "MARCH";
          case Month2.APRIL:
            return "APRIL";
          case Month2.MAY:
            return "MAY";
          case Month2.JUNE:
            return "JUNE";
          case Month2.JULY:
            return "JULY";
          case Month2.AUGUST:
            return "AUGUST";
          case Month2.SEPTEMBER:
            return "SEPTEMBER";
          case Month2.OCTOBER:
            return "OCTOBER";
          case Month2.NOVEMBER:
            return "NOVEMBER";
          case Month2.DECEMBER:
            return "DECEMBER";
          default:
            return "unknown Month, value: " + this.value();
        }
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, Month2, "other");
        return this._value - other._value;
      };
      _proto.equals = function equals(other) {
        return this === other;
      };
      Month2.valueOf = function valueOf(name2) {
        var ordinal = 0;
        for (ordinal; ordinal < MONTHS.length; ordinal++) {
          if (MONTHS[ordinal].name() === name2) {
            break;
          }
        }
        return Month2.of(ordinal + 1);
      };
      Month2.values = function values() {
        return MONTHS.slice();
      };
      Month2.of = function of(month) {
        if (month < 1 || month > 12) {
          assert(false, "Invalid value for MonthOfYear: " + month, DateTimeException);
        }
        return MONTHS[month - 1];
      };
      Month2.from = function from(temporal) {
        if (temporal instanceof Month2) {
          return temporal;
        }
        try {
          return Month2.of(temporal.get(ChronoField.MONTH_OF_YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Month from TemporalAccessor: " + temporal + " of type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""), ex);
        }
      };
      return Month2;
    }(TemporalAccessor);
    PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;
    Period = function(_TemporalAmount) {
      _inheritsLoose(Period2, _TemporalAmount);
      function Period2(years, months, days) {
        var _this;
        _this = _TemporalAmount.call(this) || this;
        var _years = MathUtil.safeToInt(years);
        var _months = MathUtil.safeToInt(months);
        var _days = MathUtil.safeToInt(days);
        if (_years === 0 && _months === 0 && _days === 0) {
          if (!Period2.ZERO) {
            _this._years = _years;
            _this._months = _months;
            _this._days = _days;
            Period2.ZERO = _assertThisInitialized(_this);
          }
          return Period2.ZERO || _assertThisInitialized(_this);
        }
        _this._years = _years;
        _this._months = _months;
        _this._days = _days;
        return _this;
      }
      Period2.ofYears = function ofYears(years) {
        return Period2.create(years, 0, 0);
      };
      Period2.ofMonths = function ofMonths(months) {
        return Period2.create(0, months, 0);
      };
      Period2.ofWeeks = function ofWeeks(weeks) {
        return Period2.create(0, 0, MathUtil.safeMultiply(weeks, 7));
      };
      Period2.ofDays = function ofDays(days) {
        return Period2.create(0, 0, days);
      };
      Period2.of = function of(years, months, days) {
        return Period2.create(years, months, days);
      };
      Period2.from = function from(amount) {
        if (amount instanceof Period2) {
          return amount;
        }
        requireNonNull(amount, "amount");
        var years = 0;
        var months = 0;
        var days = 0;
        var units = amount.units();
        for (var i = 0; i < units.length; i++) {
          var unit = units[i];
          var unitAmount = amount.get(unit);
          if (unit === ChronoUnit.YEARS) {
            years = MathUtil.safeToInt(unitAmount);
          } else if (unit === ChronoUnit.MONTHS) {
            months = MathUtil.safeToInt(unitAmount);
          } else if (unit === ChronoUnit.DAYS) {
            days = MathUtil.safeToInt(unitAmount);
          } else {
            throw new DateTimeException("Unit must be Years, Months or Days, but was " + unit);
          }
        }
        return Period2.create(years, months, days);
      };
      Period2.between = function between(startDate, endDate) {
        requireNonNull(startDate, "startDate");
        requireNonNull(endDate, "endDate");
        requireInstance(startDate, LocalDate, "startDate");
        requireInstance(endDate, LocalDate, "endDate");
        return startDate.until(endDate);
      };
      Period2.parse = function parse2(text) {
        requireNonNull(text, "text");
        try {
          return Period2._parse(text);
        } catch (ex) {
          if (ex instanceof ArithmeticException) {
            throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0, ex);
          } else {
            throw ex;
          }
        }
      };
      Period2._parse = function _parse(text) {
        var matches = PATTERN.exec(text);
        if (matches != null) {
          var negate = "-" === matches[1] ? -1 : 1;
          var yearMatch = matches[2];
          var monthMatch = matches[3];
          var weekMatch = matches[4];
          var dayMatch = matches[5];
          if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
            var years = Period2._parseNumber(text, yearMatch, negate);
            var months = Period2._parseNumber(text, monthMatch, negate);
            var weeks = Period2._parseNumber(text, weekMatch, negate);
            var days = Period2._parseNumber(text, dayMatch, negate);
            days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
            return Period2.create(years, months, days);
          }
        }
        throw new DateTimeParseException("Text cannot be parsed to a Period", text, 0);
      };
      Period2._parseNumber = function _parseNumber(text, str, negate) {
        if (str == null) {
          return 0;
        }
        var val = MathUtil.parseInt(str);
        return MathUtil.safeMultiply(val, negate);
      };
      Period2.create = function create(years, months, days) {
        return new Period2(years, months, days);
      };
      var _proto = Period2.prototype;
      _proto.units = function units() {
        return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
      };
      _proto.chronology = function chronology() {
        return IsoChronology.INSTANCE;
      };
      _proto.get = function get(unit) {
        if (unit === ChronoUnit.YEARS) {
          return this._years;
        }
        if (unit === ChronoUnit.MONTHS) {
          return this._months;
        }
        if (unit === ChronoUnit.DAYS) {
          return this._days;
        }
        throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
      };
      _proto.isZero = function isZero() {
        return this === Period2.ZERO;
      };
      _proto.isNegative = function isNegative() {
        return this._years < 0 || this._months < 0 || this._days < 0;
      };
      _proto.years = function years() {
        return this._years;
      };
      _proto.months = function months() {
        return this._months;
      };
      _proto.days = function days() {
        return this._days;
      };
      _proto.withYears = function withYears(years) {
        if (years === this._years) {
          return this;
        }
        return Period2.create(years, this._months, this._days);
      };
      _proto.withMonths = function withMonths(months) {
        if (months === this._months) {
          return this;
        }
        return Period2.create(this._years, months, this._days);
      };
      _proto.withDays = function withDays(days) {
        if (days === this._days) {
          return this;
        }
        return Period2.create(this._years, this._months, days);
      };
      _proto.plus = function plus(amountToAdd) {
        var amount = Period2.from(amountToAdd);
        return Period2.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        return Period2.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        return Period2.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        if (daysToAdd === 0) {
          return this;
        }
        return Period2.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
      };
      _proto.minus = function minus(amountToSubtract) {
        var amount = Period2.from(amountToSubtract);
        return Period2.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return this.plusYears(-1 * yearsToSubtract);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return this.plusMonths(-1 * monthsToSubtract);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return this.plusDays(-1 * daysToSubtract);
      };
      _proto.multipliedBy = function multipliedBy(scalar) {
        if (this === Period2.ZERO || scalar === 1) {
          return this;
        }
        return Period2.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
      };
      _proto.negated = function negated() {
        return this.multipliedBy(-1);
      };
      _proto.normalized = function normalized() {
        var totalMonths = this.toTotalMonths();
        var splitYears = MathUtil.intDiv(totalMonths, 12);
        var splitMonths = MathUtil.intMod(totalMonths, 12);
        if (splitYears === this._years && splitMonths === this._months) {
          return this;
        }
        return Period2.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
      };
      _proto.toTotalMonths = function toTotalMonths() {
        return this._years * 12 + this._months;
      };
      _proto.addTo = function addTo(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._years !== 0) {
          if (this._months !== 0) {
            temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
          } else {
            temporal = temporal.plus(this._years, ChronoUnit.YEARS);
          }
        } else if (this._months !== 0) {
          temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
        }
        if (this._days !== 0) {
          temporal = temporal.plus(this._days, ChronoUnit.DAYS);
        }
        return temporal;
      };
      _proto.subtractFrom = function subtractFrom(temporal) {
        requireNonNull(temporal, "temporal");
        if (this._years !== 0) {
          if (this._months !== 0) {
            temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
          } else {
            temporal = temporal.minus(this._years, ChronoUnit.YEARS);
          }
        } else if (this._months !== 0) {
          temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
        }
        if (this._days !== 0) {
          temporal = temporal.minus(this._days, ChronoUnit.DAYS);
        }
        return temporal;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof Period2) {
          var other = obj;
          return this._years === other._years && this._months === other._months && this._days === other._days;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._years, this._months, this._days);
      };
      _proto.toString = function toString() {
        if (this === Period2.ZERO) {
          return "P0D";
        } else {
          var buf = "P";
          if (this._years !== 0) {
            buf += this._years + "Y";
          }
          if (this._months !== 0) {
            buf += this._months + "M";
          }
          if (this._days !== 0) {
            buf += this._days + "D";
          }
          return buf;
        }
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Period2;
    }(TemporalAmount);
    ParsePosition = function() {
      function ParsePosition2(index) {
        this._index = index;
        this._errorIndex = -1;
      }
      var _proto = ParsePosition2.prototype;
      _proto.getIndex = function getIndex() {
        return this._index;
      };
      _proto.setIndex = function setIndex(index) {
        this._index = index;
      };
      _proto.getErrorIndex = function getErrorIndex() {
        return this._errorIndex;
      };
      _proto.setErrorIndex = function setErrorIndex(errorIndex) {
        this._errorIndex = errorIndex;
      };
      return ParsePosition2;
    }();
    EnumMap = function() {
      function EnumMap2() {
        this._map = {};
      }
      var _proto = EnumMap2.prototype;
      _proto.putAll = function putAll(otherMap) {
        for (var key in otherMap._map) {
          this._map[key] = otherMap._map[key];
        }
        return this;
      };
      _proto.containsKey = function containsKey(key) {
        return this._map.hasOwnProperty(key.name()) && this.get(key) !== void 0;
      };
      _proto.get = function get(key) {
        return this._map[key.name()];
      };
      _proto.put = function put(key, val) {
        return this.set(key, val);
      };
      _proto.set = function set(key, val) {
        this._map[key.name()] = val;
        return this;
      };
      _proto.retainAll = function retainAll(keyList) {
        var map = {};
        for (var i = 0; i < keyList.length; i++) {
          var key = keyList[i].name();
          map[key] = this._map[key];
        }
        this._map = map;
        return this;
      };
      _proto.remove = function remove(key) {
        var keyName = key.name();
        var val = this._map[keyName];
        this._map[keyName] = void 0;
        return val;
      };
      _proto.keySet = function keySet() {
        return this._map;
      };
      _proto.clear = function clear() {
        this._map = {};
      };
      return EnumMap2;
    }();
    ResolverStyle = function(_Enum) {
      _inheritsLoose(ResolverStyle2, _Enum);
      function ResolverStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      return ResolverStyle2;
    }(Enum);
    ResolverStyle.STRICT = new ResolverStyle("STRICT");
    ResolverStyle.SMART = new ResolverStyle("SMART");
    ResolverStyle.LENIENT = new ResolverStyle("LENIENT");
    Temporal = function(_TemporalAccessor) {
      _inheritsLoose(Temporal2, _TemporalAccessor);
      function Temporal2() {
        return _TemporalAccessor.apply(this, arguments) || this;
      }
      var _proto = Temporal2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        abstractMethodFail("isSupported");
      };
      _proto.minus = function minus(amount, unit) {
        if (arguments.length < 2) {
          return this._minusAmount(amount);
        } else {
          return this._minusUnit(amount, unit);
        }
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount, "amount");
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        return this._plusUnit(-amountToSubtract, unit);
      };
      _proto.plus = function plus(amount, unit) {
        if (arguments.length < 2) {
          return this._plusAmount(amount);
        } else {
          return this._plusUnit(amount, unit);
        }
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount, "amount");
        requireInstance(amount, TemporalAmount, "amount");
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        abstractMethodFail("_plusUnit");
      };
      _proto.until = function until(endTemporal, unit) {
        abstractMethodFail("until");
      };
      _proto.with = function _with(adjusterOrField, newValue) {
        if (arguments.length < 2) {
          return this._withAdjuster(adjusterOrField);
        } else {
          return this._withField(adjusterOrField, newValue);
        }
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        assert(typeof adjuster.adjustInto === "function", "adjuster must be a TemporalAdjuster", IllegalArgumentException);
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        abstractMethodFail("_withField");
      };
      return Temporal2;
    }(TemporalAccessor);
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive) {
      Temporal.prototype[Symbol.toPrimitive] = function(hint) {
        if (hint !== "number") {
          return this.toString();
        }
        throw new TypeError("A conversion from Temporal to a number is not allowed. To compare use the methods .equals(), .compareTo(), .isBefore() or one that is more suitable to your use case.");
      };
    }
    ChronoLocalDate = function(_Temporal) {
      _inheritsLoose(ChronoLocalDate2, _Temporal);
      function ChronoLocalDate2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoLocalDate2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.DAYS;
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toEpochDay());
        } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      return ChronoLocalDate2;
    }(Temporal);
    StringUtil = function() {
      function StringUtil2() {
      }
      StringUtil2.startsWith = function startsWith(text, pattern) {
        return text.indexOf(pattern) === 0;
      };
      StringUtil2.hashCode = function hashCode(text) {
        var len = text.length;
        if (len === 0) {
          return 0;
        }
        var hash = 0;
        for (var i = 0; i < len; i++) {
          var chr = text.charCodeAt(i);
          hash = (hash << 5) - hash + chr;
          hash |= 0;
        }
        return MathUtil.smi(hash);
      };
      return StringUtil2;
    }();
    ZoneId = function() {
      function ZoneId2() {
      }
      ZoneId2.systemDefault = function systemDefault() {
        throw new DateTimeException("not supported operation");
      };
      ZoneId2.getAvailableZoneIds = function getAvailableZoneIds() {
        throw new DateTimeException("not supported operation");
      };
      ZoneId2.of = function of(zoneId) {
        throw new DateTimeException("not supported operation" + zoneId);
      };
      ZoneId2.ofOffset = function ofOffset(prefix, offset) {
        throw new DateTimeException("not supported operation" + prefix + offset);
      };
      ZoneId2.from = function from(temporal) {
        throw new DateTimeException("not supported operation" + temporal);
      };
      var _proto = ZoneId2.prototype;
      _proto.id = function id() {
        abstractMethodFail("ZoneId.id");
      };
      _proto.rules = function rules() {
        abstractMethodFail("ZoneId.rules");
      };
      _proto.normalized = function normalized() {
        var rules = this.rules();
        if (rules.isFixedOffset()) {
          return rules.offset(Instant.EPOCH);
        }
        return this;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ZoneId2) {
          return this.id() === other.id();
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return StringUtil.hashCode(this.id());
      };
      _proto.toString = function toString() {
        return this.id();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return ZoneId2;
    }();
    ZoneRules = function() {
      function ZoneRules2() {
      }
      ZoneRules2.of = function of(offset) {
        requireNonNull(offset, "offset");
        return new Fixed(offset);
      };
      var _proto = ZoneRules2.prototype;
      _proto.isFixedOffset = function isFixedOffset() {
        abstractMethodFail("ZoneRules.isFixedOffset");
      };
      _proto.offset = function offset(instantOrLocalDateTime) {
        if (instantOrLocalDateTime instanceof Instant) {
          return this.offsetOfInstant(instantOrLocalDateTime);
        } else {
          return this.offsetOfLocalDateTime(instantOrLocalDateTime);
        }
      };
      _proto.offsetOfInstant = function offsetOfInstant(instant) {
        abstractMethodFail("ZoneRules.offsetInstant");
      };
      _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
        abstractMethodFail("ZoneRules.offsetOfEpochMilli");
      };
      _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
        abstractMethodFail("ZoneRules.offsetLocalDateTime");
      };
      _proto.validOffsets = function validOffsets(localDateTime) {
        abstractMethodFail("ZoneRules.validOffsets");
      };
      _proto.transition = function transition(localDateTime) {
        abstractMethodFail("ZoneRules.transition");
      };
      _proto.standardOffset = function standardOffset(instant) {
        abstractMethodFail("ZoneRules.standardOffset");
      };
      _proto.daylightSavings = function daylightSavings(instant) {
        abstractMethodFail("ZoneRules.daylightSavings");
      };
      _proto.isDaylightSavings = function isDaylightSavings(instant) {
        abstractMethodFail("ZoneRules.isDaylightSavings");
      };
      _proto.isValidOffset = function isValidOffset(localDateTime, offset) {
        abstractMethodFail("ZoneRules.isValidOffset");
      };
      _proto.nextTransition = function nextTransition(instant) {
        abstractMethodFail("ZoneRules.nextTransition");
      };
      _proto.previousTransition = function previousTransition(instant) {
        abstractMethodFail("ZoneRules.previousTransition");
      };
      _proto.transitions = function transitions() {
        abstractMethodFail("ZoneRules.transitions");
      };
      _proto.transitionRules = function transitionRules() {
        abstractMethodFail("ZoneRules.transitionRules");
      };
      _proto.toString = function toString() {
        abstractMethodFail("ZoneRules.toString");
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return ZoneRules2;
    }();
    Fixed = function(_ZoneRules) {
      _inheritsLoose(Fixed2, _ZoneRules);
      function Fixed2(offset) {
        var _this;
        _this = _ZoneRules.call(this) || this;
        _this._offset = offset;
        return _this;
      }
      var _proto2 = Fixed2.prototype;
      _proto2.isFixedOffset = function isFixedOffset() {
        return true;
      };
      _proto2.offsetOfInstant = function offsetOfInstant() {
        return this._offset;
      };
      _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {
        return this._offset;
      };
      _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
        return this._offset;
      };
      _proto2.validOffsets = function validOffsets() {
        return [this._offset];
      };
      _proto2.transition = function transition() {
        return null;
      };
      _proto2.standardOffset = function standardOffset() {
        return this._offset;
      };
      _proto2.daylightSavings = function daylightSavings() {
        return Duration.ZERO;
      };
      _proto2.isDaylightSavings = function isDaylightSavings() {
        return false;
      };
      _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {
        return this._offset.equals(offset);
      };
      _proto2.nextTransition = function nextTransition() {
        return null;
      };
      _proto2.previousTransition = function previousTransition() {
        return null;
      };
      _proto2.transitions = function transitions() {
        return [];
      };
      _proto2.transitionRules = function transitionRules() {
        return [];
      };
      _proto2.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Fixed2) {
          return this._offset.equals(other._offset);
        }
        return false;
      };
      _proto2.toString = function toString() {
        return "FixedRules:" + this._offset.toString();
      };
      return Fixed2;
    }(ZoneRules);
    SECONDS_CACHE = {};
    ID_CACHE = {};
    ZoneOffset = function(_ZoneId) {
      _inheritsLoose(ZoneOffset2, _ZoneId);
      function ZoneOffset2(totalSeconds) {
        var _this;
        _this = _ZoneId.call(this) || this;
        ZoneOffset2._validateTotalSeconds(totalSeconds);
        _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
        _this._rules = ZoneRules.of(_assertThisInitialized(_this));
        _this._id = ZoneOffset2._buildId(totalSeconds);
        return _this;
      }
      var _proto = ZoneOffset2.prototype;
      _proto.totalSeconds = function totalSeconds() {
        return this._totalSeconds;
      };
      _proto.id = function id() {
        return this._id;
      };
      ZoneOffset2._buildId = function _buildId(totalSeconds) {
        if (totalSeconds === 0) {
          return "Z";
        } else {
          var absTotalSeconds = Math.abs(totalSeconds);
          var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
          var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
          var buf = (totalSeconds < 0 ? "-" : "+") + (absHours < 10 ? "0" : "") + absHours + (absMinutes < 10 ? ":0" : ":") + absMinutes;
          var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);
          if (absSeconds !== 0) {
            buf += (absSeconds < 10 ? ":0" : ":") + absSeconds;
          }
          return buf;
        }
      };
      ZoneOffset2._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
        if (Math.abs(totalSeconds) > ZoneOffset2.MAX_SECONDS) {
          throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
        }
      };
      ZoneOffset2._validate = function _validate(hours, minutes, seconds) {
        if (hours < -18 || hours > 18) {
          throw new DateTimeException("Zone offset hours not in valid range: value " + hours + " is not in the range -18 to 18");
        }
        if (hours > 0) {
          if (minutes < 0 || seconds < 0) {
            throw new DateTimeException("Zone offset minutes and seconds must be positive because hours is positive");
          }
        } else if (hours < 0) {
          if (minutes > 0 || seconds > 0) {
            throw new DateTimeException("Zone offset minutes and seconds must be negative because hours is negative");
          }
        } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
          throw new DateTimeException("Zone offset minutes and seconds must have the same sign");
        }
        if (Math.abs(minutes) > 59) {
          throw new DateTimeException("Zone offset minutes not in valid range: abs(value) " + Math.abs(minutes) + " is not in the range 0 to 59");
        }
        if (Math.abs(seconds) > 59) {
          throw new DateTimeException("Zone offset seconds not in valid range: abs(value) " + Math.abs(seconds) + " is not in the range 0 to 59");
        }
        if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
          throw new DateTimeException("Zone offset not in valid range: -18:00 to +18:00");
        }
      };
      ZoneOffset2.of = function of(offsetId) {
        requireNonNull(offsetId, "offsetId");
        var offset = ID_CACHE[offsetId];
        if (offset != null) {
          return offset;
        }
        var hours, minutes, seconds;
        switch (offsetId.length) {
          case 2:
            offsetId = offsetId[0] + "0" + offsetId[1];
          case 3:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = 0;
            seconds = 0;
            break;
          case 5:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
            seconds = 0;
            break;
          case 6:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
            seconds = 0;
            break;
          case 7:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 3, false);
            seconds = ZoneOffset2._parseNumber(offsetId, 5, false);
            break;
          case 9:
            hours = ZoneOffset2._parseNumber(offsetId, 1, false);
            minutes = ZoneOffset2._parseNumber(offsetId, 4, true);
            seconds = ZoneOffset2._parseNumber(offsetId, 7, true);
            break;
          default:
            throw new DateTimeException("Invalid ID for ZoneOffset, invalid format: " + offsetId);
        }
        var first = offsetId[0];
        if (first !== "+" && first !== "-") {
          throw new DateTimeException("Invalid ID for ZoneOffset, plus/minus not found when expected: " + offsetId);
        }
        if (first === "-") {
          return ZoneOffset2.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
        } else {
          return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, seconds);
        }
      };
      ZoneOffset2._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
        if (precededByColon && offsetId[pos - 1] !== ":") {
          throw new DateTimeException("Invalid ID for ZoneOffset, colon not found when expected: " + offsetId);
        }
        var ch1 = offsetId[pos];
        var ch2 = offsetId[pos + 1];
        if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
          throw new DateTimeException("Invalid ID for ZoneOffset, non numeric characters found: " + offsetId);
        }
        return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
      };
      ZoneOffset2.ofHours = function ofHours(hours) {
        return ZoneOffset2.ofHoursMinutesSeconds(hours, 0, 0);
      };
      ZoneOffset2.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
        return ZoneOffset2.ofHoursMinutesSeconds(hours, minutes, 0);
      };
      ZoneOffset2.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
        ZoneOffset2._validate(hours, minutes, seconds);
        var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
        return ZoneOffset2.ofTotalSeconds(totalSeconds);
      };
      ZoneOffset2.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
        var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
        return ZoneOffset2.ofTotalSeconds(totalSeconds);
      };
      ZoneOffset2.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
        if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
          var totalSecs = totalSeconds;
          var result = SECONDS_CACHE[totalSecs];
          if (result == null) {
            result = new ZoneOffset2(totalSeconds);
            SECONDS_CACHE[totalSecs] = result;
            ID_CACHE[result.id()] = result;
          }
          return result;
        } else {
          return new ZoneOffset2(totalSeconds);
        }
      };
      _proto.rules = function rules() {
        return this._rules;
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field === ChronoField.OFFSET_SECONDS) {
          return this._totalSeconds;
        } else if (field instanceof ChronoField) {
          throw new DateTimeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        return other._totalSeconds - this._totalSeconds;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof ZoneOffset2) {
          return this._totalSeconds === obj._totalSeconds;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._totalSeconds;
      };
      _proto.toString = function toString() {
        return this._id;
      };
      return ZoneOffset2;
    }(ZoneId);
    DateTimeBuilder = function(_TemporalAccessor) {
      _inheritsLoose(DateTimeBuilder2, _TemporalAccessor);
      DateTimeBuilder2.create = function create(field, value) {
        var dtb = new DateTimeBuilder2();
        dtb._addFieldValue(field, value);
        return dtb;
      };
      function DateTimeBuilder2() {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this.fieldValues = new EnumMap();
        _this.chrono = null;
        _this.zone = null;
        _this.date = null;
        _this.time = null;
        _this.leapSecond = false;
        _this.excessDays = null;
        return _this;
      }
      var _proto = DateTimeBuilder2.prototype;
      _proto.getFieldValue0 = function getFieldValue0(field) {
        return this.fieldValues.get(field);
      };
      _proto._addFieldValue = function _addFieldValue(field, value) {
        requireNonNull(field, "field");
        var old = this.getFieldValue0(field);
        if (old != null && old !== value) {
          throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value + ": " + this);
        }
        return this._putFieldValue0(field, value);
      };
      _proto._putFieldValue0 = function _putFieldValue0(field, value) {
        this.fieldValues.put(field, value);
        return this;
      };
      _proto.resolve = function resolve(resolverStyle, resolverFields) {
        if (resolverFields != null) {
          this.fieldValues.retainAll(resolverFields);
        }
        this._mergeDate(resolverStyle);
        this._mergeTime(resolverStyle);
        this._resolveTimeInferZeroes(resolverStyle);
        if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
          this.date = this.date.plus(this.excessDays);
          this.excessDays = Period.ZERO;
        }
        this._resolveInstant();
        return this;
      };
      _proto._mergeDate = function _mergeDate(resolverStyle) {
        this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
      };
      _proto._checkDate = function _checkDate(date) {
        if (date != null) {
          this._addObject(date);
          for (var fieldName in this.fieldValues.keySet()) {
            var field = ChronoField.byName(fieldName);
            if (field) {
              if (this.fieldValues.get(field) !== void 0) {
                if (field.isDateBased()) {
                  var val1 = void 0;
                  try {
                    val1 = date.getLong(field);
                  } catch (ex) {
                    if (ex instanceof DateTimeException) {
                      continue;
                    } else {
                      throw ex;
                    }
                  }
                  var val2 = this.fieldValues.get(field);
                  if (val1 !== val2) {
                    throw new DateTimeException("Conflict found: Field " + field + " " + val1 + " differs from " + field + " " + val2 + " derived from " + date);
                  }
                }
              }
            }
          }
        }
      };
      _proto._mergeTime = function _mergeTime(resolverStyle) {
        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
          var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (resolverStyle === ResolverStyle.SMART && ch === 0)
              ;
            else {
              ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
            }
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
        }
        if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
          var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            if (resolverStyle === ResolverStyle.SMART && _ch === 0)
              ;
            else {
              ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
            }
          }
          this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
            ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
          }
          if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
            ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
          }
        }
        if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
          var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
          var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);
          this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
        }
        if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
          var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.NANO_OF_DAY.checkValidValue(nod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1e9));
          this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1e9));
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
          var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MICRO_OF_DAY.checkValidValue(cod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1e6));
          this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1e6));
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
          var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MILLI_OF_DAY.checkValidValue(lod);
          }
          this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1e3));
          this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1e3));
        }
        if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
          var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.SECOND_OF_DAY.checkValidValue(sod);
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));
          this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));
          this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
        }
        if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
          var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
          }
          this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));
          this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
            ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
          }
          if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
            ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
          }
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
          var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
          var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);
          this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1e3 + MathUtil.intMod(cos, 1e3));
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
          var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
          this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1e3));
          this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
        }
        if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
          var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
          this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1e6));
          this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
        }
        if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
          var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
          this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1e3);
        } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
          var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
          this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1e6);
        }
      };
      _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
        var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
        var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
        var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
        var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
        if (hod == null) {
          return;
        }
        if (moh == null && (som != null || nos != null)) {
          return;
        }
        if (moh != null && som == null && nos != null) {
          return;
        }
        if (resolverStyle !== ResolverStyle.LENIENT) {
          if (hod != null) {
            if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
              hod = 0;
              this.excessDays = Period.ofDays(1);
            }
            var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);
            if (moh != null) {
              var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);
              if (som != null) {
                var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);
                if (nos != null) {
                  var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);
                  this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
                } else {
                  this._addObject(LocalTime.of(hodVal, mohVal, somVal));
                }
              } else {
                if (nos == null) {
                  this._addObject(LocalTime.of(hodVal, mohVal));
                }
              }
            } else {
              if (som == null && nos == null) {
                this._addObject(LocalTime.of(hodVal, 0));
              }
            }
          }
        } else {
          if (hod != null) {
            var _hodVal = hod;
            if (moh != null) {
              if (som != null) {
                if (nos == null) {
                  nos = 0;
                }
                var totalNanos = MathUtil.safeMultiply(_hodVal, 36e11);
                totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 6e10));
                totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1e9));
                totalNanos = MathUtil.safeAdd(totalNanos, nos);
                var excessDays = MathUtil.floorDiv(totalNanos, 864e11);
                var nod = MathUtil.floorMod(totalNanos, 864e11);
                this._addObject(LocalTime.ofNanoOfDay(nod));
                this.excessDays = Period.ofDays(excessDays);
              } else {
                var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
                totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));
                var _excessDays = MathUtil.floorDiv(totalSecs, 86400);
                var sod = MathUtil.floorMod(totalSecs, 86400);
                this._addObject(LocalTime.ofSecondOfDay(sod));
                this.excessDays = Period.ofDays(_excessDays);
              }
            } else {
              var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));
              _hodVal = MathUtil.floorMod(_hodVal, 24);
              this._addObject(LocalTime.of(_hodVal, 0));
              this.excessDays = Period.ofDays(_excessDays2);
            }
          }
        }
        this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
        this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
        this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
        this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
      };
      _proto._addObject = function _addObject(dateOrTime) {
        if (dateOrTime instanceof ChronoLocalDate) {
          this.date = dateOrTime;
        } else if (dateOrTime instanceof LocalTime) {
          this.time = dateOrTime;
        }
      };
      _proto._resolveInstant = function _resolveInstant() {
        if (this.date != null && this.time != null) {
          var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);
          if (offsetSecs != null) {
            var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
            var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
            this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
          } else if (this.zone != null) {
            var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);
            this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
          }
        }
      };
      _proto.build = function build(type) {
        return type.queryFrom(this);
      };
      _proto.isSupported = function isSupported(field) {
        if (field == null) {
          return false;
        }
        return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== void 0 || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        var value = this.getFieldValue0(field);
        if (value == null) {
          if (this.date != null && this.date.isSupported(field)) {
            return this.date.getLong(field);
          }
          if (this.time != null && this.time.isSupported(field)) {
            return this.time.getLong(field);
          }
          throw new DateTimeException("Field not found: " + field);
        }
        return value;
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId()) {
          return this.zone;
        } else if (_query === TemporalQueries.chronology()) {
          return this.chrono;
        } else if (_query === TemporalQueries.localDate()) {
          return this.date != null ? LocalDate.from(this.date) : null;
        } else if (_query === TemporalQueries.localTime()) {
          return this.time;
        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
          return _query.queryFrom(this);
        } else if (_query === TemporalQueries.precision()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      return DateTimeBuilder2;
    }(TemporalAccessor);
    DateTimeParseContext = function() {
      function DateTimeParseContext2() {
        if (arguments.length === 1) {
          if (arguments[0] instanceof DateTimeParseContext2) {
            this._constructorSelf.apply(this, arguments);
            return;
          } else {
            this._constructorFormatter.apply(this, arguments);
          }
        } else {
          this._constructorParam.apply(this, arguments);
        }
        this._caseSensitive = true;
        this._strict = true;
        this._parsed = [new Parsed(this)];
      }
      var _proto = DateTimeParseContext2.prototype;
      _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {
        this._locale = locale;
        this._symbols = symbols;
        this._overrideChronology = chronology;
      };
      _proto._constructorFormatter = function _constructorFormatter(formatter) {
        this._locale = formatter.locale();
        this._symbols = formatter.decimalStyle();
        this._overrideChronology = formatter.chronology();
      };
      _proto._constructorSelf = function _constructorSelf(other) {
        this._locale = other._locale;
        this._symbols = other._symbols;
        this._overrideChronology = other._overrideChronology;
        this._overrideZone = other._overrideZone;
        this._caseSensitive = other._caseSensitive;
        this._strict = other._strict;
        this._parsed = [new Parsed(this)];
      };
      _proto.copy = function copy() {
        return new DateTimeParseContext2(this);
      };
      _proto.symbols = function symbols() {
        return this._symbols;
      };
      _proto.isStrict = function isStrict() {
        return this._strict;
      };
      _proto.setStrict = function setStrict(strict) {
        this._strict = strict;
      };
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.setLocale = function setLocale(locale) {
        this._locale = locale;
      };
      _proto.startOptional = function startOptional() {
        this._parsed.push(this.currentParsed().copy());
      };
      _proto.endOptional = function endOptional(successful) {
        if (successful) {
          this._parsed.splice(this._parsed.length - 2, 1);
        } else {
          this._parsed.splice(this._parsed.length - 1, 1);
        }
      };
      _proto.isCaseSensitive = function isCaseSensitive() {
        return this._caseSensitive;
      };
      _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {
        this._caseSensitive = caseSensitive;
      };
      _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
        if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
          return false;
        }
        if (!this.isCaseSensitive()) {
          cs1 = cs1.toLowerCase();
          cs2 = cs2.toLowerCase();
        }
        for (var i = 0; i < length; i++) {
          var ch1 = cs1[offset1 + i];
          var ch2 = cs2[offset2 + i];
          if (ch1 !== ch2) {
            return false;
          }
        }
        return true;
      };
      _proto.charEquals = function charEquals(ch1, ch2) {
        if (this.isCaseSensitive()) {
          return ch1 === ch2;
        }
        return this.charEqualsIgnoreCase(ch1, ch2);
      };
      _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
        return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
      };
      _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {
        var currentParsedFieldValues = this.currentParsed().fieldValues;
        var old = currentParsedFieldValues.get(field);
        currentParsedFieldValues.set(field, value);
        return old != null && old !== value ? ~errorPos : successPos;
      };
      _proto.setParsedZone = function setParsedZone(zone) {
        requireNonNull(zone, "zone");
        this.currentParsed().zone = zone;
      };
      _proto.getParsed = function getParsed(field) {
        return this.currentParsed().fieldValues.get(field);
      };
      _proto.toParsed = function toParsed() {
        return this.currentParsed();
      };
      _proto.currentParsed = function currentParsed() {
        return this._parsed[this._parsed.length - 1];
      };
      _proto.setParsedLeapSecond = function setParsedLeapSecond() {
        this.currentParsed().leapSecond = true;
      };
      _proto.getEffectiveChronology = function getEffectiveChronology() {
        var chrono = this.currentParsed().chrono;
        if (chrono == null) {
          chrono = this._overrideChronology;
          if (chrono == null) {
            chrono = IsoChronology.INSTANCE;
          }
        }
        return chrono;
      };
      return DateTimeParseContext2;
    }();
    Parsed = function(_Temporal) {
      _inheritsLoose(Parsed2, _Temporal);
      function Parsed2(dateTimeParseContext) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this.chrono = null;
        _this.zone = null;
        _this.fieldValues = new EnumMap();
        _this.leapSecond = false;
        _this.dateTimeParseContext = dateTimeParseContext;
        return _this;
      }
      var _proto2 = Parsed2.prototype;
      _proto2.copy = function copy() {
        var cloned = new Parsed2();
        cloned.chrono = this.chrono;
        cloned.zone = this.zone;
        cloned.fieldValues.putAll(this.fieldValues);
        cloned.leapSecond = this.leapSecond;
        cloned.dateTimeParseContext = this.dateTimeParseContext;
        return cloned;
      };
      _proto2.toString = function toString() {
        return this.fieldValues + ", " + this.chrono + ", " + this.zone;
      };
      _proto2.isSupported = function isSupported(field) {
        return this.fieldValues.containsKey(field);
      };
      _proto2.get = function get(field) {
        var val = this.fieldValues.get(field);
        assert(val != null);
        return val;
      };
      _proto2.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chrono;
        }
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
          return this.zone;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto2.toBuilder = function toBuilder() {
        var builder = new DateTimeBuilder();
        builder.fieldValues.putAll(this.fieldValues);
        builder.chrono = this.dateTimeParseContext.getEffectiveChronology();
        if (this.zone != null) {
          builder.zone = this.zone;
        } else {
          builder.zone = this.overrideZone;
        }
        builder.leapSecond = this.leapSecond;
        builder.excessDays = this.excessDays;
        return builder;
      };
      return Parsed2;
    }(Temporal);
    DateTimePrintContext = function() {
      function DateTimePrintContext2(temporal, localeOrFormatter, symbols) {
        if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
          this._temporal = DateTimePrintContext2.adjust(temporal, localeOrFormatter);
          this._locale = localeOrFormatter.locale();
          this._symbols = localeOrFormatter.decimalStyle();
        } else {
          this._temporal = temporal;
          this._locale = localeOrFormatter;
          this._symbols = symbols;
        }
        this._optional = 0;
      }
      DateTimePrintContext2.adjust = function adjust(temporal, formatter) {
        return temporal;
      };
      var _proto = DateTimePrintContext2.prototype;
      _proto.symbols = function symbols() {
        return this._symbols;
      };
      _proto.startOptional = function startOptional() {
        this._optional++;
      };
      _proto.endOptional = function endOptional() {
        this._optional--;
      };
      _proto.getValueQuery = function getValueQuery(query) {
        var result = this._temporal.query(query);
        if (result == null && this._optional === 0) {
          throw new DateTimeException("Unable to extract value: " + this._temporal);
        }
        return result;
      };
      _proto.getValue = function getValue(field) {
        try {
          return this._temporal.getLong(field);
        } catch (ex) {
          if (ex instanceof DateTimeException && this._optional > 0) {
            return null;
          }
          throw ex;
        }
      };
      _proto.temporal = function temporal() {
        return this._temporal;
      };
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.setDateTime = function setDateTime(temporal) {
        this._temporal = temporal;
      };
      _proto.setLocale = function setLocale(locale) {
        this._locale = locale;
      };
      return DateTimePrintContext2;
    }();
    IsoFields = {};
    QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];
    Field = function(_TemporalField) {
      _inheritsLoose(Field2, _TemporalField);
      function Field2() {
        return _TemporalField.apply(this, arguments) || this;
      }
      var _proto = Field2.prototype;
      _proto.isDateBased = function isDateBased() {
        return true;
      };
      _proto.isTimeBased = function isTimeBased() {
        return false;
      };
      _proto._isIso = function _isIso() {
        return true;
      };
      Field2._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {
        var wby = Field2._getWeekBasedYear(date);
        return ValueRange.of(1, Field2._getWeekRangeByYear(wby));
      };
      Field2._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
        var date = LocalDate.of(wby, 1, 1);
        if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {
          return 53;
        }
        return 52;
      };
      Field2._getWeek = function _getWeek(date) {
        var dow0 = date.dayOfWeek().ordinal();
        var doy0 = date.dayOfYear() - 1;
        var doyThu0 = doy0 + (3 - dow0);
        var alignedWeek = MathUtil.intDiv(doyThu0, 7);
        var firstThuDoy0 = doyThu0 - alignedWeek * 7;
        var firstMonDoy0 = firstThuDoy0 - 3;
        if (firstMonDoy0 < -3) {
          firstMonDoy0 += 7;
        }
        if (doy0 < firstMonDoy0) {
          return Field2._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();
        }
        var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;
        if (week === 53) {
          if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {
            week = 1;
          }
        }
        return week;
      };
      Field2._getWeekBasedYear = function _getWeekBasedYear(date) {
        var year = date.year();
        var doy = date.dayOfYear();
        if (doy <= 3) {
          var dow = date.dayOfWeek().ordinal();
          if (doy - dow < -2) {
            year--;
          }
        } else if (doy >= 363) {
          var _dow = date.dayOfWeek().ordinal();
          doy = doy - 363 - (date.isLeapYear() ? 1 : 0);
          if (doy - _dow >= 0) {
            year++;
          }
        }
        return year;
      };
      _proto.displayName = function displayName() {
        return this.toString();
      };
      _proto.resolve = function resolve() {
        return null;
      };
      _proto.name = function name2() {
        return this.toString();
      };
      return Field2;
    }(TemporalField);
    DAY_OF_QUARTER_FIELD = function(_Field) {
      _inheritsLoose(DAY_OF_QUARTER_FIELD2, _Field);
      function DAY_OF_QUARTER_FIELD2() {
        return _Field.apply(this, arguments) || this;
      }
      var _proto2 = DAY_OF_QUARTER_FIELD2.prototype;
      _proto2.toString = function toString() {
        return "DayOfQuarter";
      };
      _proto2.baseUnit = function baseUnit() {
        return ChronoUnit.DAYS;
      };
      _proto2.rangeUnit = function rangeUnit() {
        return QUARTER_YEARS;
      };
      _proto2.range = function range() {
        return ValueRange.of(1, 90, 92);
      };
      _proto2.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
      };
      _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
        }
        var qoy = temporal.getLong(QUARTER_OF_YEAR);
        if (qoy === 1) {
          var year = temporal.getLong(ChronoField.YEAR);
          return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
        } else if (qoy === 2) {
          return ValueRange.of(1, 91);
        } else if (qoy === 3 || qoy === 4) {
          return ValueRange.of(1, 92);
        }
        return this.range();
      };
      _proto2.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: DayOfQuarter");
        }
        var doy = temporal.get(ChronoField.DAY_OF_YEAR);
        var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
        var year = temporal.getLong(ChronoField.YEAR);
        return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
      };
      _proto2.adjustInto = function adjustInto(temporal, newValue) {
        var curValue = this.getFrom(temporal);
        this.range().checkValidValue(newValue, this);
        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
      };
      _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
        var yearLong = fieldValues.get(ChronoField.YEAR);
        var qoyLong = fieldValues.get(QUARTER_OF_YEAR);
        if (yearLong == null || qoyLong == null) {
          return null;
        }
        var y = ChronoField.YEAR.checkValidIntValue(yearLong);
        var doq = fieldValues.get(DAY_OF_QUARTER);
        var date;
        if (resolverStyle === ResolverStyle.LENIENT) {
          var qoy = qoyLong;
          date = LocalDate.of(y, 1, 1);
          date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
          date = date.plusDays(MathUtil.safeSubtract(doq, 1));
        } else {
          var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);
          if (resolverStyle === ResolverStyle.STRICT) {
            var max = 92;
            if (_qoy === 1) {
              max = IsoChronology.isLeapYear(y) ? 91 : 90;
            } else if (_qoy === 2) {
              max = 91;
            }
            ValueRange.of(1, max).checkValidValue(doq, this);
          } else {
            this.range().checkValidValue(doq, this);
          }
          date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
        }
        fieldValues.remove(this);
        fieldValues.remove(ChronoField.YEAR);
        fieldValues.remove(QUARTER_OF_YEAR);
        return date;
      };
      return DAY_OF_QUARTER_FIELD2;
    }(Field);
    QUARTER_OF_YEAR_FIELD = function(_Field2) {
      _inheritsLoose(QUARTER_OF_YEAR_FIELD2, _Field2);
      function QUARTER_OF_YEAR_FIELD2() {
        return _Field2.apply(this, arguments) || this;
      }
      var _proto3 = QUARTER_OF_YEAR_FIELD2.prototype;
      _proto3.toString = function toString() {
        return "QuarterOfYear";
      };
      _proto3.baseUnit = function baseUnit() {
        return QUARTER_YEARS;
      };
      _proto3.rangeUnit = function rangeUnit() {
        return ChronoUnit.YEARS;
      };
      _proto3.range = function range() {
        return ValueRange.of(1, 4);
      };
      _proto3.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
      };
      _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return this.range();
      };
      _proto3.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: QuarterOfYear");
        }
        var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
        return MathUtil.intDiv(moy + 2, 3);
      };
      _proto3.adjustInto = function adjustInto(temporal, newValue) {
        var curValue = this.getFrom(temporal);
        this.range().checkValidValue(newValue, this);
        return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
      };
      return QUARTER_OF_YEAR_FIELD2;
    }(Field);
    WEEK_OF_WEEK_BASED_YEAR_FIELD = function(_Field3) {
      _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD2, _Field3);
      function WEEK_OF_WEEK_BASED_YEAR_FIELD2() {
        return _Field3.apply(this, arguments) || this;
      }
      var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD2.prototype;
      _proto4.toString = function toString() {
        return "WeekOfWeekBasedYear";
      };
      _proto4.baseUnit = function baseUnit() {
        return ChronoUnit.WEEKS;
      };
      _proto4.rangeUnit = function rangeUnit() {
        return WEEK_BASED_YEARS;
      };
      _proto4.range = function range() {
        return ValueRange.of(1, 52, 53);
      };
      _proto4.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
      };
      _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
        }
        return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
      };
      _proto4.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekOfWeekBasedYear");
        }
        return Field._getWeek(LocalDate.from(temporal));
      };
      _proto4.adjustInto = function adjustInto(temporal, newValue) {
        this.range().checkValidValue(newValue, this);
        return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
      };
      _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
        var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
        var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);
        if (wbyLong == null || dowLong == null) {
          return null;
        }
        var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
        var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
        var date;
        if (resolverStyle === ResolverStyle.LENIENT) {
          var dow = dowLong;
          var weeks = 0;
          if (dow > 7) {
            weeks = MathUtil.intDiv(dow - 1, 7);
            dow = MathUtil.intMod(dow - 1, 7) + 1;
          } else if (dow < 1) {
            weeks = MathUtil.intDiv(dow, 7) - 1;
            dow = MathUtil.intMod(dow, 7) + 7;
          }
          date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
        } else {
          var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);
          if (resolverStyle === ResolverStyle.STRICT) {
            var temp = LocalDate.of(wby, 1, 4);
            var range = Field._getWeekRangeByLocalDate(temp);
            range.checkValidValue(wowby, this);
          } else {
            this.range().checkValidValue(wowby, this);
          }
          date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
        }
        fieldValues.remove(this);
        fieldValues.remove(WEEK_BASED_YEAR);
        fieldValues.remove(ChronoField.DAY_OF_WEEK);
        return date;
      };
      _proto4.displayName = function displayName() {
        return "Week";
      };
      return WEEK_OF_WEEK_BASED_YEAR_FIELD2;
    }(Field);
    WEEK_BASED_YEAR_FIELD = function(_Field4) {
      _inheritsLoose(WEEK_BASED_YEAR_FIELD2, _Field4);
      function WEEK_BASED_YEAR_FIELD2() {
        return _Field4.apply(this, arguments) || this;
      }
      var _proto5 = WEEK_BASED_YEAR_FIELD2.prototype;
      _proto5.toString = function toString() {
        return "WeekBasedYear";
      };
      _proto5.baseUnit = function baseUnit() {
        return WEEK_BASED_YEARS;
      };
      _proto5.rangeUnit = function rangeUnit() {
        return ChronoUnit.FOREVER;
      };
      _proto5.range = function range() {
        return ChronoField.YEAR.range();
      };
      _proto5.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
      };
      _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {
        return ChronoField.YEAR.range();
      };
      _proto5.getFrom = function getFrom(temporal) {
        if (temporal.isSupported(this) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
        }
        return Field._getWeekBasedYear(LocalDate.from(temporal));
      };
      _proto5.adjustInto = function adjustInto(temporal, newValue) {
        if (this.isSupportedBy(temporal) === false) {
          throw new UnsupportedTemporalTypeException("Unsupported field: WeekBasedYear");
        }
        var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
        var date = LocalDate.from(temporal);
        var dow = date.get(ChronoField.DAY_OF_WEEK);
        var week = Field._getWeek(date);
        if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
          week = 52;
        }
        var resolved = LocalDate.of(newWby, 1, 4);
        var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
        resolved = resolved.plusDays(days);
        return temporal.with(resolved);
      };
      return WEEK_BASED_YEAR_FIELD2;
    }(Field);
    Unit = function(_TemporalUnit) {
      _inheritsLoose(Unit2, _TemporalUnit);
      function Unit2(name2, estimatedDuration) {
        var _this;
        _this = _TemporalUnit.call(this) || this;
        _this._name = name2;
        _this._duration = estimatedDuration;
        return _this;
      }
      var _proto6 = Unit2.prototype;
      _proto6.duration = function duration() {
        return this._duration;
      };
      _proto6.isDurationEstimated = function isDurationEstimated() {
        return true;
      };
      _proto6.isDateBased = function isDateBased() {
        return true;
      };
      _proto6.isTimeBased = function isTimeBased() {
        return false;
      };
      _proto6.isSupportedBy = function isSupportedBy(temporal) {
        return temporal.isSupported(ChronoField.EPOCH_DAY);
      };
      _proto6.addTo = function addTo(temporal, periodToAdd) {
        switch (this) {
          case WEEK_BASED_YEARS: {
            var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
            return temporal.with(WEEK_BASED_YEAR, added);
          }
          case QUARTER_YEARS:
            return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);
          default:
            throw new IllegalStateException("Unreachable");
        }
      };
      _proto6.between = function between(temporal1, temporal2) {
        switch (this) {
          case WEEK_BASED_YEARS:
            return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));
          case QUARTER_YEARS:
            return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);
          default:
            throw new IllegalStateException("Unreachable");
        }
      };
      _proto6.toString = function toString() {
        return this._name;
      };
      return Unit2;
    }(TemporalUnit);
    DAY_OF_QUARTER = null;
    QUARTER_OF_YEAR = null;
    WEEK_OF_WEEK_BASED_YEAR = null;
    WEEK_BASED_YEAR = null;
    WEEK_BASED_YEARS = null;
    QUARTER_YEARS = null;
    DecimalStyle = function() {
      function DecimalStyle2(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
        this._zeroDigit = zeroChar;
        this._zeroDigitCharCode = zeroChar.charCodeAt(0);
        this._positiveSign = positiveSignChar;
        this._negativeSign = negativeSignChar;
        this._decimalSeparator = decimalPointChar;
      }
      var _proto = DecimalStyle2.prototype;
      _proto.positiveSign = function positiveSign() {
        return this._positiveSign;
      };
      _proto.withPositiveSign = function withPositiveSign(positiveSign) {
        if (positiveSign === this._positiveSign) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
      };
      _proto.negativeSign = function negativeSign() {
        return this._negativeSign;
      };
      _proto.withNegativeSign = function withNegativeSign(negativeSign) {
        if (negativeSign === this._negativeSign) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
      };
      _proto.zeroDigit = function zeroDigit() {
        return this._zeroDigit;
      };
      _proto.withZeroDigit = function withZeroDigit(zeroDigit) {
        if (zeroDigit === this._zeroDigit) {
          return this;
        }
        return new DecimalStyle2(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
      };
      _proto.decimalSeparator = function decimalSeparator() {
        return this._decimalSeparator;
      };
      _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
        if (decimalSeparator === this._decimalSeparator) {
          return this;
        }
        return new DecimalStyle2(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
      };
      _proto.convertToDigit = function convertToDigit(char) {
        var val = char.charCodeAt(0) - this._zeroDigitCharCode;
        return val >= 0 && val <= 9 ? val : -1;
      };
      _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {
        if (this._zeroDigit === "0") {
          return numericText;
        }
        var diff = this._zeroDigitCharCode - "0".charCodeAt(0);
        var convertedText = "";
        for (var i = 0; i < numericText.length; i++) {
          convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);
        }
        return convertedText;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof DecimalStyle2) {
          return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
      };
      _proto.toString = function toString() {
        return "DecimalStyle[" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + "]";
      };
      DecimalStyle2.of = function of() {
        throw new Error("not yet supported");
      };
      DecimalStyle2.availableLocales = function availableLocales() {
        throw new Error("not yet supported");
      };
      return DecimalStyle2;
    }();
    DecimalStyle.STANDARD = new DecimalStyle("0", "+", "-", ".");
    SignStyle = function(_Enum) {
      _inheritsLoose(SignStyle2, _Enum);
      function SignStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = SignStyle2.prototype;
      _proto.parse = function parse2(positive, strict, fixedWidth) {
        switch (this) {
          case SignStyle2.NORMAL:
            return !positive || !strict;
          case SignStyle2.ALWAYS:
          case SignStyle2.EXCEEDS_PAD:
            return true;
          default:
            return !strict && !fixedWidth;
        }
      };
      return SignStyle2;
    }(Enum);
    SignStyle.NORMAL = new SignStyle("NORMAL");
    SignStyle.NEVER = new SignStyle("NEVER");
    SignStyle.ALWAYS = new SignStyle("ALWAYS");
    SignStyle.EXCEEDS_PAD = new SignStyle("EXCEEDS_PAD");
    SignStyle.NOT_NEGATIVE = new SignStyle("NOT_NEGATIVE");
    TextStyle = function(_Enum) {
      _inheritsLoose(TextStyle2, _Enum);
      function TextStyle2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = TextStyle2.prototype;
      _proto.isStandalone = function isStandalone() {
        switch (this) {
          case TextStyle2.FULL_STANDALONE:
          case TextStyle2.SHORT_STANDALONE:
          case TextStyle2.NARROW_STANDALONE:
            return true;
          default:
            return false;
        }
      };
      _proto.asStandalone = function asStandalone() {
        switch (this) {
          case TextStyle2.FULL:
            return TextStyle2.FULL_STANDALONE;
          case TextStyle2.SHORT:
            return TextStyle2.SHORT_STANDALONE;
          case TextStyle2.NARROW:
            return TextStyle2.NARROW_STANDALONE;
          default:
            return this;
        }
      };
      _proto.asNormal = function asNormal() {
        switch (this) {
          case TextStyle2.FULL_STANDALONE:
            return TextStyle2.FULL;
          case TextStyle2.SHORT_STANDALONE:
            return TextStyle2.SHORT;
          case TextStyle2.NARROW_STANDALONE:
            return TextStyle2.NARROW;
          default:
            return this;
        }
      };
      return TextStyle2;
    }(Enum);
    TextStyle.FULL = new TextStyle("FULL");
    TextStyle.FULL_STANDALONE = new TextStyle("FULL_STANDALONE");
    TextStyle.SHORT = new TextStyle("SHORT");
    TextStyle.SHORT_STANDALONE = new TextStyle("SHORT_STANDALONE");
    TextStyle.NARROW = new TextStyle("NARROW");
    TextStyle.NARROW_STANDALONE = new TextStyle("NARROW_STANDALONE");
    CharLiteralPrinterParser = function() {
      function CharLiteralPrinterParser2(literal) {
        if (literal.length > 1) {
          throw new IllegalArgumentException('invalid literal, too long: "' + literal + '"');
        }
        this._literal = literal;
      }
      var _proto = CharLiteralPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        buf.append(this._literal);
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        if (position === length) {
          return ~position;
        }
        var ch = text.charAt(position);
        if (context.charEquals(this._literal, ch) === false) {
          return ~position;
        }
        return position + this._literal.length;
      };
      _proto.toString = function toString() {
        if (this._literal === "'") {
          return "''";
        }
        return "'" + this._literal + "'";
      };
      return CharLiteralPrinterParser2;
    }();
    CompositePrinterParser = function() {
      function CompositePrinterParser2(printerParsers, optional) {
        this._printerParsers = printerParsers;
        this._optional = optional;
      }
      var _proto = CompositePrinterParser2.prototype;
      _proto.withOptional = function withOptional(optional) {
        if (optional === this._optional) {
          return this;
        }
        return new CompositePrinterParser2(this._printerParsers, optional);
      };
      _proto.print = function print(context, buf) {
        var length = buf.length();
        if (this._optional) {
          context.startOptional();
        }
        try {
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            if (pp.print(context, buf) === false) {
              buf.setLength(length);
              return true;
            }
          }
        } finally {
          if (this._optional) {
            context.endOptional();
          }
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        if (this._optional) {
          context.startOptional();
          var pos = position;
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            pos = pp.parse(context, text, pos);
            if (pos < 0) {
              context.endOptional(false);
              return position;
            }
          }
          context.endOptional(true);
          return pos;
        } else {
          for (var _i = 0; _i < this._printerParsers.length; _i++) {
            var _pp = this._printerParsers[_i];
            position = _pp.parse(context, text, position);
            if (position < 0) {
              break;
            }
          }
          return position;
        }
      };
      _proto.toString = function toString() {
        var buf = "";
        if (this._printerParsers != null) {
          buf += this._optional ? "[" : "(";
          for (var i = 0; i < this._printerParsers.length; i++) {
            var pp = this._printerParsers[i];
            buf += pp.toString();
          }
          buf += this._optional ? "]" : ")";
        }
        return buf;
      };
      return CompositePrinterParser2;
    }();
    FractionPrinterParser = function() {
      function FractionPrinterParser2(field, minWidth, maxWidth, decimalPoint) {
        requireNonNull(field, "field");
        if (field.range().isFixed() === false) {
          throw new IllegalArgumentException("Field must have a fixed set of values: " + field);
        }
        if (minWidth < 0 || minWidth > 9) {
          throw new IllegalArgumentException("Minimum width must be from 0 to 9 inclusive but was " + minWidth);
        }
        if (maxWidth < 1 || maxWidth > 9) {
          throw new IllegalArgumentException("Maximum width must be from 1 to 9 inclusive but was " + maxWidth);
        }
        if (maxWidth < minWidth) {
          throw new IllegalArgumentException("Maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
        }
        this.field = field;
        this.minWidth = minWidth;
        this.maxWidth = maxWidth;
        this.decimalPoint = decimalPoint;
      }
      var _proto = FractionPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        var value = context.getValue(this.field);
        if (value === null) {
          return false;
        }
        var symbols = context.symbols();
        if (value === 0) {
          if (this.minWidth > 0) {
            if (this.decimalPoint) {
              buf.append(symbols.decimalSeparator());
            }
            for (var i = 0; i < this.minWidth; i++) {
              buf.append(symbols.zeroDigit());
            }
          }
        } else {
          var fraction = this.convertToFraction(value, symbols.zeroDigit());
          var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
          fraction = fraction.substr(0, outputScale);
          if (fraction * 1 > 0) {
            while (fraction.length > this.minWidth && fraction[fraction.length - 1] === "0") {
              fraction = fraction.substr(0, fraction.length - 1);
            }
          }
          var str = fraction;
          str = symbols.convertNumberToI18N(str);
          if (this.decimalPoint) {
            buf.append(symbols.decimalSeparator());
          }
          buf.append(str);
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var effectiveMin = context.isStrict() ? this.minWidth : 0;
        var effectiveMax = context.isStrict() ? this.maxWidth : 9;
        var length = text.length;
        if (position === length) {
          return effectiveMin > 0 ? ~position : position;
        }
        if (this.decimalPoint) {
          if (text[position] !== context.symbols().decimalSeparator()) {
            return effectiveMin > 0 ? ~position : position;
          }
          position++;
        }
        var minEndPos = position + effectiveMin;
        if (minEndPos > length) {
          return ~position;
        }
        var maxEndPos = Math.min(position + effectiveMax, length);
        var total = 0;
        var pos = position;
        while (pos < maxEndPos) {
          var ch = text.charAt(pos++);
          var digit = context.symbols().convertToDigit(ch);
          if (digit < 0) {
            if (pos < minEndPos) {
              return ~position;
            }
            pos--;
            break;
          }
          total = total * 10 + digit;
        }
        var moveLeft = pos - position;
        var scale = Math.pow(10, moveLeft);
        var value = this.convertFromFraction(total, scale);
        return context.setParsedField(this.field, value, position, pos);
      };
      _proto.convertToFraction = function convertToFraction(value, zeroDigit) {
        var range = this.field.range();
        range.checkValidValue(value, this.field);
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = value - _min;
        var _scaled = MathUtil.intDiv(_value * 1e9, _range);
        var fraction = "" + _scaled;
        while (fraction.length < 9) {
          fraction = zeroDigit + fraction;
        }
        return fraction;
      };
      _proto.convertFromFraction = function convertFromFraction(total, scale) {
        var range = this.field.range();
        var _min = range.minimum();
        var _range = range.maximum() - _min + 1;
        var _value = MathUtil.intDiv(total * _range, scale);
        return _value;
      };
      _proto.toString = function toString() {
        var decimal = this.decimalPoint ? ",DecimalPoint" : "";
        return "Fraction(" + this.field + "," + this.minWidth + "," + this.maxWidth + decimal + ")";
      };
      return FractionPrinterParser2;
    }();
    MAX_WIDTH$1 = 15;
    EXCEED_POINTS = [0, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9];
    NumberPrinterParser = function() {
      function NumberPrinterParser2(field, minWidth, maxWidth, signStyle, subsequentWidth) {
        if (subsequentWidth === void 0) {
          subsequentWidth = 0;
        }
        this._field = field;
        this._minWidth = minWidth;
        this._maxWidth = maxWidth;
        this._signStyle = signStyle;
        this._subsequentWidth = subsequentWidth;
      }
      var _proto = NumberPrinterParser2.prototype;
      _proto.field = function field() {
        return this._field;
      };
      _proto.minWidth = function minWidth() {
        return this._minWidth;
      };
      _proto.maxWidth = function maxWidth() {
        return this._maxWidth;
      };
      _proto.signStyle = function signStyle() {
        return this._signStyle;
      };
      _proto.withFixedWidth = function withFixedWidth() {
        if (this._subsequentWidth === -1) {
          return this;
        }
        return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
      };
      _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
        return new NumberPrinterParser2(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
      };
      _proto._isFixedWidth = function _isFixedWidth() {
        return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
      };
      _proto.print = function print(context, buf) {
        var contextValue = context.getValue(this._field);
        if (contextValue == null) {
          return false;
        }
        var value = this._getValue(context, contextValue);
        var symbols = context.symbols();
        var str = "" + Math.abs(value);
        if (str.length > this._maxWidth) {
          throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " exceeds the maximum print width of " + this._maxWidth);
        }
        str = symbols.convertNumberToI18N(str);
        if (value >= 0) {
          switch (this._signStyle) {
            case SignStyle.EXCEEDS_PAD:
              if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {
                buf.append(symbols.positiveSign());
              }
              break;
            case SignStyle.ALWAYS:
              buf.append(symbols.positiveSign());
              break;
          }
        } else {
          switch (this._signStyle) {
            case SignStyle.NORMAL:
            case SignStyle.EXCEEDS_PAD:
            case SignStyle.ALWAYS:
              buf.append(symbols.negativeSign());
              break;
            case SignStyle.NOT_NEGATIVE:
              throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " cannot be negative according to the SignStyle");
          }
        }
        for (var i = 0; i < this._minWidth - str.length; i++) {
          buf.append(symbols.zeroDigit());
        }
        buf.append(str);
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        if (position === length) {
          return ~position;
        }
        assert(position >= 0 && position < length);
        var sign = text.charAt(position);
        var negative = false;
        var positive = false;
        if (sign === context.symbols().positiveSign()) {
          if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {
            return ~position;
          }
          positive = true;
          position++;
        } else if (sign === context.symbols().negativeSign()) {
          if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {
            return ~position;
          }
          negative = true;
          position++;
        } else {
          if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {
            return ~position;
          }
        }
        var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
        var minEndPos = position + effMinWidth;
        if (minEndPos > length) {
          return ~position;
        }
        var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
        var total = 0;
        var pos = position;
        for (var pass = 0; pass < 2; pass++) {
          var maxEndPos = Math.min(pos + effMaxWidth, length);
          while (pos < maxEndPos) {
            var ch = text.charAt(pos++);
            var digit = context.symbols().convertToDigit(ch);
            if (digit < 0) {
              pos--;
              if (pos < minEndPos) {
                return ~position;
              }
              break;
            }
            if (pos - position > MAX_WIDTH$1) {
              throw new ArithmeticException("number text exceeds length");
            } else {
              total = total * 10 + digit;
            }
          }
          if (this._subsequentWidth > 0 && pass === 0) {
            var parseLen = pos - position;
            effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
            pos = position;
            total = 0;
          } else {
            break;
          }
        }
        if (negative) {
          if (total === 0 && context.isStrict()) {
            return ~(position - 1);
          }
          if (total !== 0) {
            total = -total;
          }
        } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {
          var _parseLen = pos - position;
          if (positive) {
            if (_parseLen <= this._minWidth) {
              return ~(position - 1);
            }
          } else {
            if (_parseLen > this._minWidth) {
              return ~position;
            }
          }
        }
        return this._setValue(context, total, position, pos);
      };
      _proto._getValue = function _getValue(context, value) {
        return value;
      };
      _proto._setValue = function _setValue(context, value, errorPos, successPos) {
        return context.setParsedField(this._field, value, errorPos, successPos);
      };
      _proto.toString = function toString() {
        if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {
          return "Value(" + this._field + ")";
        }
        if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
          return "Value(" + this._field + "," + this._minWidth + ")";
        }
        return "Value(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + this._signStyle + ")";
      };
      return NumberPrinterParser2;
    }();
    ReducedPrinterParser = function(_NumberPrinterParser) {
      _inheritsLoose(ReducedPrinterParser2, _NumberPrinterParser);
      function ReducedPrinterParser2(field, width, maxWidth, baseValue, baseDate) {
        var _this;
        _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;
        if (width < 1 || width > 10) {
          throw new IllegalArgumentException("The width must be from 1 to 10 inclusive but was " + width);
        }
        if (maxWidth < 1 || maxWidth > 10) {
          throw new IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was " + maxWidth);
        }
        if (maxWidth < width) {
          throw new IllegalArgumentException("The maxWidth must be greater than the width");
        }
        if (baseDate === null) {
          if (field.range().isValidValue(baseValue) === false) {
            throw new IllegalArgumentException("The base value must be within the range of the field");
          }
          if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
            throw new DateTimeException("Unable to add printer-parser as the range exceeds the capacity of an int");
          }
        }
        _this._baseValue = baseValue;
        _this._baseDate = baseDate;
        return _this;
      }
      var _proto2 = ReducedPrinterParser2.prototype;
      _proto2._getValue = function _getValue(context, value) {
        var absValue = Math.abs(value);
        var baseValue = this._baseValue;
        if (this._baseDate !== null) {
          context.temporal();
          var chrono = IsoChronology.INSTANCE;
          baseValue = chrono.date(this._baseDate).get(this._field);
        }
        if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
          return absValue % EXCEED_POINTS[this._minWidth];
        }
        return absValue % EXCEED_POINTS[this._maxWidth];
      };
      _proto2._setValue = function _setValue(context, value, errorPos, successPos) {
        var baseValue = this._baseValue;
        if (this._baseDate != null) {
          var chrono = context.getEffectiveChronology();
          baseValue = chrono.date(this._baseDate).get(this._field);
        }
        var parseLen = successPos - errorPos;
        if (parseLen === this._minWidth && value >= 0) {
          var range = EXCEED_POINTS[this._minWidth];
          var lastPart = baseValue % range;
          var basePart = baseValue - lastPart;
          if (baseValue > 0) {
            value = basePart + value;
          } else {
            value = basePart - value;
          }
          if (value < baseValue) {
            value += range;
          }
        }
        return context.setParsedField(this._field, value, errorPos, successPos);
      };
      _proto2.withFixedWidth = function withFixedWidth() {
        if (this._subsequentWidth === -1) {
          return this;
        }
        return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate);
      };
      _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
        return new ReducedPrinterParser2(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
      };
      _proto2.isFixedWidth = function isFixedWidth(context) {
        if (context.isStrict() === false) {
          return false;
        }
        return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);
      };
      _proto2.toString = function toString() {
        return "ReducedValue(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + (this._baseDate != null ? this._baseDate : this._baseValue) + ")";
      };
      return ReducedPrinterParser2;
    }(NumberPrinterParser);
    PATTERNS = ["+HH", "+HHmm", "+HH:mm", "+HHMM", "+HH:MM", "+HHMMss", "+HH:MM:ss", "+HHMMSS", "+HH:MM:SS"];
    OffsetIdPrinterParser = function() {
      function OffsetIdPrinterParser2(noOffsetText, pattern) {
        requireNonNull(noOffsetText, "noOffsetText");
        requireNonNull(pattern, "pattern");
        this.noOffsetText = noOffsetText;
        this.type = this._checkPattern(pattern);
      }
      var _proto = OffsetIdPrinterParser2.prototype;
      _proto._checkPattern = function _checkPattern(pattern) {
        for (var i = 0; i < PATTERNS.length; i++) {
          if (PATTERNS[i] === pattern) {
            return i;
          }
        }
        throw new IllegalArgumentException("Invalid zone offset pattern: " + pattern);
      };
      _proto.print = function print(context, buf) {
        var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);
        if (offsetSecs == null) {
          return false;
        }
        var totalSecs = MathUtil.safeToInt(offsetSecs);
        if (totalSecs === 0) {
          buf.append(this.noOffsetText);
        } else {
          var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
          var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
          var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
          var bufPos = buf.length();
          var output = absHours;
          buf.append(totalSecs < 0 ? "-" : "+").appendChar(MathUtil.intDiv(absHours, 10) + "0").appendChar(MathUtil.intMod(absHours, 10) + "0");
          if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
            buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absMinutes, 10) + "0").appendChar(absMinutes % 10 + "0");
            output += absMinutes;
            if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
              buf.append(this.type % 2 === 0 ? ":" : "").appendChar(MathUtil.intDiv(absSeconds, 10) + "0").appendChar(absSeconds % 10 + "0");
              output += absSeconds;
            }
          }
          if (output === 0) {
            buf.setLength(bufPos);
            buf.append(this.noOffsetText);
          }
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        var noOffsetLen = this.noOffsetText.length;
        if (noOffsetLen === 0) {
          if (position === length) {
            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
          }
        } else {
          if (position === length) {
            return ~position;
          }
          if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
            return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
          }
        }
        var sign = text[position];
        if (sign === "+" || sign === "-") {
          var negative = sign === "-" ? -1 : 1;
          var array = [0, 0, 0, 0];
          array[0] = position + 1;
          if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {
            var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
            return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
          }
        }
        if (noOffsetLen === 0) {
          return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
        }
        return ~position;
      };
      _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
        if ((this.type + 3) / 2 < arrayIndex) {
          return false;
        }
        var pos = array[0];
        if (this.type % 2 === 0 && arrayIndex > 1) {
          if (pos + 1 > parseText.length || parseText[pos] !== ":") {
            return required;
          }
          pos++;
        }
        if (pos + 2 > parseText.length) {
          return required;
        }
        var ch1 = parseText[pos++];
        var ch2 = parseText[pos++];
        if (ch1 < "0" || ch1 > "9" || ch2 < "0" || ch2 > "9") {
          return required;
        }
        var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
        if (value < 0 || value > 59) {
          return required;
        }
        array[arrayIndex] = value;
        array[0] = pos;
        return false;
      };
      _proto.toString = function toString() {
        var converted = this.noOffsetText.replace("'", "''");
        return "Offset(" + PATTERNS[this.type] + ",'" + converted + "')";
      };
      return OffsetIdPrinterParser2;
    }();
    OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser("Z", "+HH:MM:ss");
    OffsetIdPrinterParser.PATTERNS = PATTERNS;
    PadPrinterParserDecorator = function() {
      function PadPrinterParserDecorator2(printerParser, padWidth, padChar) {
        this._printerParser = printerParser;
        this._padWidth = padWidth;
        this._padChar = padChar;
      }
      var _proto = PadPrinterParserDecorator2.prototype;
      _proto.print = function print(context, buf) {
        var preLen = buf.length();
        if (this._printerParser.print(context, buf) === false) {
          return false;
        }
        var len = buf.length() - preLen;
        if (len > this._padWidth) {
          throw new DateTimeException("Cannot print as output of " + len + " characters exceeds pad width of " + this._padWidth);
        }
        for (var i = 0; i < this._padWidth - len; i++) {
          buf.insert(preLen, this._padChar);
        }
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var strict = context.isStrict();
        var caseSensitive = context.isCaseSensitive();
        assert(!(position > text.length));
        assert(position >= 0);
        if (position === text.length) {
          return ~position;
        }
        var endPos = position + this._padWidth;
        if (endPos > text.length) {
          if (strict) {
            return ~position;
          }
          endPos = text.length;
        }
        var pos = position;
        while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {
          pos++;
        }
        text = text.substring(0, endPos);
        var resultPos = this._printerParser.parse(context, text, pos);
        if (resultPos !== endPos && strict) {
          return ~(position + pos);
        }
        return resultPos;
      };
      _proto.toString = function toString() {
        return "Pad(" + this._printerParser + "," + this._padWidth + (this._padChar === " " ? ")" : ",'" + this._padChar + "')");
      };
      return PadPrinterParserDecorator2;
    }();
    SettingsParser = function(_Enum) {
      _inheritsLoose(SettingsParser2, _Enum);
      function SettingsParser2() {
        return _Enum.apply(this, arguments) || this;
      }
      var _proto = SettingsParser2.prototype;
      _proto.print = function print() {
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        switch (this) {
          case SettingsParser2.SENSITIVE:
            context.setCaseSensitive(true);
            break;
          case SettingsParser2.INSENSITIVE:
            context.setCaseSensitive(false);
            break;
          case SettingsParser2.STRICT:
            context.setStrict(true);
            break;
          case SettingsParser2.LENIENT:
            context.setStrict(false);
            break;
        }
        return position;
      };
      _proto.toString = function toString() {
        switch (this) {
          case SettingsParser2.SENSITIVE:
            return "ParseCaseSensitive(true)";
          case SettingsParser2.INSENSITIVE:
            return "ParseCaseSensitive(false)";
          case SettingsParser2.STRICT:
            return "ParseStrict(true)";
          case SettingsParser2.LENIENT:
            return "ParseStrict(false)";
        }
      };
      return SettingsParser2;
    }(Enum);
    SettingsParser.SENSITIVE = new SettingsParser("SENSITIVE");
    SettingsParser.INSENSITIVE = new SettingsParser("INSENSITIVE");
    SettingsParser.STRICT = new SettingsParser("STRICT");
    SettingsParser.LENIENT = new SettingsParser("LENIENT");
    StringLiteralPrinterParser = function() {
      function StringLiteralPrinterParser2(literal) {
        this._literal = literal;
      }
      var _proto = StringLiteralPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        buf.append(this._literal);
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        assert(!(position > length || position < 0));
        if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
          return ~position;
        }
        return position + this._literal.length;
      };
      _proto.toString = function toString() {
        var converted = this._literal.replace("'", "''");
        return "'" + converted + "'";
      };
      return StringLiteralPrinterParser2;
    }();
    ZoneRulesProvider = function() {
      function ZoneRulesProvider2() {
      }
      ZoneRulesProvider2.getRules = function getRules(zoneId) {
        throw new DateTimeException("unsupported ZoneId:" + zoneId);
      };
      ZoneRulesProvider2.getAvailableZoneIds = function getAvailableZoneIds() {
        return [];
      };
      return ZoneRulesProvider2;
    }();
    ZoneRegion = function(_ZoneId) {
      _inheritsLoose(ZoneRegion2, _ZoneId);
      ZoneRegion2.ofId = function ofId(zoneId) {
        var rules = ZoneRulesProvider.getRules(zoneId);
        return new ZoneRegion2(zoneId, rules);
      };
      function ZoneRegion2(id, rules) {
        var _this;
        _this = _ZoneId.call(this) || this;
        _this._id = id;
        _this._rules = rules;
        return _this;
      }
      var _proto = ZoneRegion2.prototype;
      _proto.id = function id() {
        return this._id;
      };
      _proto.rules = function rules() {
        return this._rules;
      };
      return ZoneRegion2;
    }(ZoneId);
    ZoneIdPrinterParser = function() {
      function ZoneIdPrinterParser2(query, description) {
        this.query = query;
        this.description = description;
      }
      var _proto = ZoneIdPrinterParser2.prototype;
      _proto.print = function print(context, buf) {
        var zone = context.getValueQuery(this.query);
        if (zone == null) {
          return false;
        }
        buf.append(zone.id());
        return true;
      };
      _proto.parse = function parse2(context, text, position) {
        var length = text.length;
        if (position > length) {
          return ~position;
        }
        if (position === length) {
          return ~position;
        }
        var nextChar = text.charAt(position);
        if (nextChar === "+" || nextChar === "-") {
          var newContext = context.copy();
          var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
          if (endPos < 0) {
            return endPos;
          }
          var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
          var zone = ZoneOffset.ofTotalSeconds(offset);
          context.setParsedZone(zone);
          return endPos;
        } else if (length >= position + 2) {
          var nextNextChar = text.charAt(position + 1);
          if (context.charEquals(nextChar, "U") && context.charEquals(nextNextChar, "T")) {
            if (length >= position + 3 && context.charEquals(text.charAt(position + 2), "C")) {
              return this._parsePrefixedOffset(context, text, position, position + 3);
            }
            return this._parsePrefixedOffset(context, text, position, position + 2);
          } else if (context.charEquals(nextChar, "G") && length >= position + 3 && context.charEquals(nextNextChar, "M") && context.charEquals(text.charAt(position + 2), "T")) {
            return this._parsePrefixedOffset(context, text, position, position + 3);
          }
        }
        if (text.substr(position, 6) === "SYSTEM") {
          context.setParsedZone(ZoneId.systemDefault());
          return position + 6;
        }
        if (context.charEquals(nextChar, "Z")) {
          context.setParsedZone(ZoneOffset.UTC);
          return position + 1;
        }
        var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
        if (zoneIdTree.size !== availableZoneIds.length) {
          zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
        }
        var maxParseLength = length - position;
        var treeMap = zoneIdTree.treeMap;
        var parsedZoneId = null;
        var parseLength = 0;
        while (treeMap != null) {
          var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));
          treeMap = treeMap.get(parsedSubZoneId);
          if (treeMap != null && treeMap.isLeaf) {
            parsedZoneId = parsedSubZoneId;
            parseLength = treeMap.length;
          }
        }
        if (parsedZoneId != null) {
          context.setParsedZone(ZoneRegion.ofId(parsedZoneId));
          return position + parseLength;
        }
        return ~position;
      };
      _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {
        var prefix = text.substring(prefixPos, position).toUpperCase();
        var newContext = context.copy();
        if (position < text.length && context.charEquals(text.charAt(position), "Z")) {
          context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
          return position;
        }
        var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
        if (endPos < 0) {
          context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
          return position;
        }
        var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
        context.setParsedZone(ZoneId.ofOffset(prefix, offset));
        return endPos;
      };
      _proto.toString = function toString() {
        return this.description;
      };
      return ZoneIdPrinterParser2;
    }();
    ZoneIdTree = function() {
      ZoneIdTree2.createTreeMap = function createTreeMap(availableZoneIds) {
        var sortedZoneIds = availableZoneIds.sort(function(a, b) {
          return a.length - b.length;
        });
        var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);
        for (var i = 0; i < sortedZoneIds.length; i++) {
          treeMap.add(sortedZoneIds[i]);
        }
        return new ZoneIdTree2(sortedZoneIds.length, treeMap);
      };
      function ZoneIdTree2(size, treeMap) {
        this.size = size;
        this.treeMap = treeMap;
      }
      return ZoneIdTree2;
    }();
    ZoneIdTreeMap = function() {
      function ZoneIdTreeMap2(length, isLeaf) {
        if (length === void 0) {
          length = 0;
        }
        if (isLeaf === void 0) {
          isLeaf = false;
        }
        this.length = length;
        this.isLeaf = isLeaf;
        this._treeMap = {};
      }
      var _proto2 = ZoneIdTreeMap2.prototype;
      _proto2.add = function add(zoneId) {
        var idLength = zoneId.length;
        if (idLength === this.length) {
          this._treeMap[zoneId] = new ZoneIdTreeMap2(idLength, true);
        } else if (idLength > this.length) {
          var subZoneId = zoneId.substr(0, this.length);
          var subTreeMap = this._treeMap[subZoneId];
          if (subTreeMap == null) {
            subTreeMap = new ZoneIdTreeMap2(idLength, false);
            this._treeMap[subZoneId] = subTreeMap;
          }
          subTreeMap.add(zoneId);
        }
      };
      _proto2.get = function get(zoneId) {
        return this._treeMap[zoneId];
      };
      return ZoneIdTreeMap2;
    }();
    zoneIdTree = new ZoneIdTree([]);
    MAX_WIDTH = 15;
    DateTimeFormatterBuilder = function() {
      function DateTimeFormatterBuilder2() {
        this._active = this;
        this._parent = null;
        this._printerParsers = [];
        this._optional = false;
        this._padNextWidth = 0;
        this._padNextChar = null;
        this._valueParserIndex = -1;
      }
      DateTimeFormatterBuilder2._of = function _of(parent, optional) {
        requireNonNull(parent, "parent");
        requireNonNull(optional, "optional");
        var dtFormatterBuilder = new DateTimeFormatterBuilder2();
        dtFormatterBuilder._parent = parent;
        dtFormatterBuilder._optional = optional;
        return dtFormatterBuilder;
      };
      var _proto = DateTimeFormatterBuilder2.prototype;
      _proto.parseCaseSensitive = function parseCaseSensitive() {
        this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
        return this;
      };
      _proto.parseCaseInsensitive = function parseCaseInsensitive() {
        this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
        return this;
      };
      _proto.parseStrict = function parseStrict() {
        this._appendInternalPrinterParser(SettingsParser.STRICT);
        return this;
      };
      _proto.parseLenient = function parseLenient() {
        this._appendInternalPrinterParser(SettingsParser.LENIENT);
        return this;
      };
      _proto.parseDefaulting = function parseDefaulting(field, value) {
        requireNonNull(field);
        this._appendInternal(new DefaultingParser(field, value));
        return this;
      };
      _proto.appendValue = function appendValue() {
        if (arguments.length === 1) {
          return this._appendValue1.apply(this, arguments);
        } else if (arguments.length === 2) {
          return this._appendValue2.apply(this, arguments);
        } else {
          return this._appendValue4.apply(this, arguments);
        }
      };
      _proto._appendValue1 = function _appendValue1(field) {
        requireNonNull(field);
        this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));
        return this;
      };
      _proto._appendValue2 = function _appendValue2(field, width) {
        requireNonNull(field);
        if (width < 1 || width > MAX_WIDTH) {
          throw new IllegalArgumentException("The width must be from 1 to " + MAX_WIDTH + " inclusive but was " + width);
        }
        var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
        requireNonNull(field);
        requireNonNull(signStyle);
        if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
          return this._appendValue2(field, maxWidth);
        }
        if (minWidth < 1 || minWidth > MAX_WIDTH) {
          throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + minWidth);
        }
        if (maxWidth < 1 || maxWidth > MAX_WIDTH) {
          throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + maxWidth);
        }
        if (maxWidth < minWidth) {
          throw new IllegalArgumentException("The maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
        }
        var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto.appendValueReduced = function appendValueReduced() {
        if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
          return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
        } else {
          return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
        }
      };
      _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
        requireNonNull(field, "field");
        var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
        requireNonNull(field, "field");
        requireNonNull(baseDate, "baseDate");
        requireInstance(baseDate, ChronoLocalDate, "baseDate");
        var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
        this._appendValuePrinterParser(pp);
        return this;
      };
      _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
        assert(pp != null);
        if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
          var activeValueParser = this._active._valueParserIndex;
          var basePP = this._active._printerParsers[activeValueParser];
          if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
            basePP = basePP.withSubsequentWidth(pp.maxWidth());
            this._appendInternal(pp.withFixedWidth());
            this._active._valueParserIndex = activeValueParser;
          } else {
            basePP = basePP.withFixedWidth();
            this._active._valueParserIndex = this._appendInternal(pp);
          }
          this._active._printerParsers[activeValueParser] = basePP;
        } else {
          this._active._valueParserIndex = this._appendInternal(pp);
        }
        return this;
      };
      _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
        this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
        return this;
      };
      _proto.appendInstant = function appendInstant(fractionalDigits) {
        if (fractionalDigits === void 0) {
          fractionalDigits = -2;
        }
        if (fractionalDigits < -2 || fractionalDigits > 9) {
          throw new IllegalArgumentException("Invalid fractional digits: " + fractionalDigits);
        }
        this._appendInternal(new InstantPrinterParser(fractionalDigits));
        return this;
      };
      _proto.appendOffsetId = function appendOffsetId() {
        this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
        return this;
      };
      _proto.appendOffset = function appendOffset(pattern, noOffsetText) {
        this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
        return this;
      };
      _proto.appendZoneId = function appendZoneId() {
        this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), "ZoneId()"));
        return this;
      };
      _proto.appendPattern = function appendPattern(pattern) {
        requireNonNull(pattern, "pattern");
        this._parsePattern(pattern);
        return this;
      };
      _proto.appendZoneText = function appendZoneText() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendText = function appendText() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendLocalizedOffset = function appendLocalizedOffset() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto.appendWeekField = function appendWeekField() {
        throw new IllegalArgumentException("Pattern using (localized) text not implemented, use @js-joda/locale plugin!");
      };
      _proto._parsePattern = function _parsePattern(pattern) {
        var FIELD_MAP = {
          "G": ChronoField.ERA,
          "y": ChronoField.YEAR_OF_ERA,
          "u": ChronoField.YEAR,
          "Q": IsoFields.QUARTER_OF_YEAR,
          "q": IsoFields.QUARTER_OF_YEAR,
          "M": ChronoField.MONTH_OF_YEAR,
          "L": ChronoField.MONTH_OF_YEAR,
          "D": ChronoField.DAY_OF_YEAR,
          "d": ChronoField.DAY_OF_MONTH,
          "F": ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
          "E": ChronoField.DAY_OF_WEEK,
          "c": ChronoField.DAY_OF_WEEK,
          "e": ChronoField.DAY_OF_WEEK,
          "a": ChronoField.AMPM_OF_DAY,
          "H": ChronoField.HOUR_OF_DAY,
          "k": ChronoField.CLOCK_HOUR_OF_DAY,
          "K": ChronoField.HOUR_OF_AMPM,
          "h": ChronoField.CLOCK_HOUR_OF_AMPM,
          "m": ChronoField.MINUTE_OF_HOUR,
          "s": ChronoField.SECOND_OF_MINUTE,
          "S": ChronoField.NANO_OF_SECOND,
          "A": ChronoField.MILLI_OF_DAY,
          "n": ChronoField.NANO_OF_SECOND,
          "N": ChronoField.NANO_OF_DAY
        };
        for (var pos = 0; pos < pattern.length; pos++) {
          var cur = pattern.charAt(pos);
          if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
            var start = pos++;
            for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++)
              ;
            var count = pos - start;
            if (cur === "p") {
              var pad = 0;
              if (pos < pattern.length) {
                cur = pattern.charAt(pos);
                if (cur >= "A" && cur <= "Z" || cur >= "a" && cur <= "z") {
                  pad = count;
                  start = pos++;
                  for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++)
                    ;
                  count = pos - start;
                }
              }
              if (pad === 0) {
                throw new IllegalArgumentException("Pad letter 'p' must be followed by valid pad pattern: " + pattern);
              }
              this.padNext(pad);
            }
            var field = FIELD_MAP[cur];
            if (field != null) {
              this._parseField(cur, count, field);
            } else if (cur === "z") {
              if (count > 4) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              } else if (count === 4) {
                this.appendZoneText(TextStyle.FULL);
              } else {
                this.appendZoneText(TextStyle.SHORT);
              }
            } else if (cur === "V") {
              if (count !== 2) {
                throw new IllegalArgumentException("Pattern letter count must be 2: " + cur);
              }
              this.appendZoneId();
            } else if (cur === "Z") {
              if (count < 4) {
                this.appendOffset("+HHMM", "+0000");
              } else if (count === 4) {
                this.appendLocalizedOffset(TextStyle.FULL);
              } else if (count === 5) {
                this.appendOffset("+HH:MM:ss", "Z");
              } else {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
            } else if (cur === "O") {
              if (count === 1) {
                this.appendLocalizedOffset(TextStyle.SHORT);
              } else if (count === 4) {
                this.appendLocalizedOffset(TextStyle.FULL);
              } else {
                throw new IllegalArgumentException("Pattern letter count must be 1 or 4: " + cur);
              }
            } else if (cur === "X") {
              if (count > 5) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], "Z");
            } else if (cur === "x") {
              if (count > 5) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              var zero = count === 1 ? "+00" : count % 2 === 0 ? "+0000" : "+00:00";
              this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
            } else if (cur === "W") {
              if (count > 1) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendWeekField("W", count);
            } else if (cur === "w") {
              if (count > 2) {
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
              }
              this.appendWeekField("w", count);
            } else if (cur === "Y") {
              this.appendWeekField("Y", count);
            } else {
              throw new IllegalArgumentException("Unknown pattern letter: " + cur);
            }
            pos--;
          } else if (cur === "'") {
            var _start = pos++;
            for (; pos < pattern.length; pos++) {
              if (pattern.charAt(pos) === "'") {
                if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === "'") {
                  pos++;
                } else {
                  break;
                }
              }
            }
            if (pos >= pattern.length) {
              throw new IllegalArgumentException("Pattern ends with an incomplete string literal: " + pattern);
            }
            var str = pattern.substring(_start + 1, pos);
            if (str.length === 0) {
              this.appendLiteral("'");
            } else {
              this.appendLiteral(str.replace("''", "'"));
            }
          } else if (cur === "[") {
            this.optionalStart();
          } else if (cur === "]") {
            if (this._active._parent === null) {
              throw new IllegalArgumentException("Pattern invalid as it contains ] without previous [");
            }
            this.optionalEnd();
          } else if (cur === "{" || cur === "}" || cur === "#") {
            throw new IllegalArgumentException("Pattern includes reserved character: '" + cur + "'");
          } else {
            this.appendLiteral(cur);
          }
        }
      };
      _proto._parseField = function _parseField(cur, count, field) {
        switch (cur) {
          case "u":
          case "y":
            if (count === 2) {
              this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
            } else if (count < 4) {
              this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
            } else {
              this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
            }
            break;
          case "M":
          case "Q":
            switch (count) {
              case 1:
                this.appendValue(field);
                break;
              case 2:
                this.appendValue(field, 2);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "L":
          case "q":
            switch (count) {
              case 1:
                this.appendValue(field);
                break;
              case 2:
                this.appendValue(field, 2);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT_STANDALONE);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL_STANDALONE);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW_STANDALONE);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "e":
            switch (count) {
              case 1:
              case 2:
                this.appendWeekField("e", count);
                break;
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "c":
            switch (count) {
              case 1:
                this.appendWeekField("c", count);
                break;
              case 2:
                throw new IllegalArgumentException("Invalid number of pattern letters: " + cur);
              case 3:
                this.appendText(field, TextStyle.SHORT_STANDALONE);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL_STANDALONE);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW_STANDALONE);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "a":
            if (count === 1) {
              this.appendText(field, TextStyle.SHORT);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "E":
          case "G":
            switch (count) {
              case 1:
              case 2:
              case 3:
                this.appendText(field, TextStyle.SHORT);
                break;
              case 4:
                this.appendText(field, TextStyle.FULL);
                break;
              case 5:
                this.appendText(field, TextStyle.NARROW);
                break;
              default:
                throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "S":
            this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
            break;
          case "F":
            if (count === 1) {
              this.appendValue(field);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "d":
          case "h":
          case "H":
          case "k":
          case "K":
          case "m":
          case "s":
            if (count === 1) {
              this.appendValue(field);
            } else if (count === 2) {
              this.appendValue(field, count);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          case "D":
            if (count === 1) {
              this.appendValue(field);
            } else if (count <= 3) {
              this.appendValue(field, count);
            } else {
              throw new IllegalArgumentException("Too many pattern letters: " + cur);
            }
            break;
          default:
            if (count === 1) {
              this.appendValue(field);
            } else {
              this.appendValue(field, count);
            }
            break;
        }
      };
      _proto.padNext = function padNext() {
        if (arguments.length === 1) {
          return this._padNext1.apply(this, arguments);
        } else {
          return this._padNext2.apply(this, arguments);
        }
      };
      _proto._padNext1 = function _padNext1(padWidth) {
        return this._padNext2(padWidth, " ");
      };
      _proto._padNext2 = function _padNext2(padWidth, padChar) {
        if (padWidth < 1) {
          throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
        }
        this._active._padNextWidth = padWidth;
        this._active._padNextChar = padChar;
        this._active._valueParserIndex = -1;
        return this;
      };
      _proto.optionalStart = function optionalStart() {
        this._active._valueParserIndex = -1;
        this._active = DateTimeFormatterBuilder2._of(this._active, true);
        return this;
      };
      _proto.optionalEnd = function optionalEnd() {
        if (this._active._parent == null) {
          throw new IllegalStateException("Cannot call optionalEnd() as there was no previous call to optionalStart()");
        }
        if (this._active._printerParsers.length > 0) {
          var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
          this._active = this._active._parent;
          this._appendInternal(cpp);
        } else {
          this._active = this._active._parent;
        }
        return this;
      };
      _proto._appendInternal = function _appendInternal(pp) {
        assert(pp != null);
        if (this._active._padNextWidth > 0) {
          if (pp != null) {
            pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
          }
          this._active._padNextWidth = 0;
          this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
      };
      _proto.appendLiteral = function appendLiteral(literal) {
        assert(literal != null);
        if (literal.length > 0) {
          if (literal.length === 1) {
            this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
          } else {
            this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
          }
        }
        return this;
      };
      _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
        assert(pp != null);
        if (this._active._padNextWidth > 0) {
          if (pp != null) {
            pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
          }
          this._active._padNextWidth = 0;
          this._active._padNextChar = 0;
        }
        this._active._printerParsers.push(pp);
        this._active._valueParserIndex = -1;
        return this._active._printerParsers.length - 1;
      };
      _proto.append = function append(formatter) {
        requireNonNull(formatter, "formatter");
        this._appendInternal(formatter._toPrinterParser(false));
        return this;
      };
      _proto.toFormatter = function toFormatter(resolverStyle) {
        if (resolverStyle === void 0) {
          resolverStyle = ResolverStyle.SMART;
        }
        while (this._active._parent != null) {
          this.optionalEnd();
        }
        var pp = new CompositePrinterParser(this._printerParsers, false);
        return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
      };
      return DateTimeFormatterBuilder2;
    }();
    SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
    SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;
    InstantPrinterParser = function() {
      function InstantPrinterParser2(fractionalDigits) {
        this.fractionalDigits = fractionalDigits;
      }
      var _proto2 = InstantPrinterParser2.prototype;
      _proto2.print = function print(context, buf) {
        var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);
        var inNanos = 0;
        if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
          inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);
        }
        if (inSecs == null) {
          return false;
        }
        var inSec = inSecs;
        var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
        if (inSec >= -SECONDS_0000_TO_1970) {
          var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
          var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
          var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
          var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
          if (hi > 0) {
            buf.append("+").append(hi);
          }
          buf.append(ldt.toString());
          if (ldt.second() === 0) {
            buf.append(":00");
          }
        } else {
          var _zeroSecs = inSec + SECONDS_0000_TO_1970;
          var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);
          var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);
          var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
          var pos = buf.length();
          buf.append(_ldt.toString());
          if (_ldt.second() === 0) {
            buf.append(":00");
          }
          if (_hi < 0) {
            if (_ldt.year() === -1e4) {
              buf.replace(pos, pos + 2, "" + (_hi - 1));
            } else if (_lo === 0) {
              buf.insert(pos, _hi);
            } else {
              buf.insert(pos + 1, Math.abs(_hi));
            }
          }
        }
        if (this.fractionalDigits === -2) {
          if (inNano !== 0) {
            buf.append(".");
            if (MathUtil.intMod(inNano, 1e6) === 0) {
              buf.append(("" + (MathUtil.intDiv(inNano, 1e6) + 1e3)).substring(1));
            } else if (MathUtil.intMod(inNano, 1e3) === 0) {
              buf.append(("" + (MathUtil.intDiv(inNano, 1e3) + 1e6)).substring(1));
            } else {
              buf.append(("" + (inNano + 1e9)).substring(1));
            }
          }
        } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
          buf.append(".");
          var div = 1e8;
          for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
            var digit = MathUtil.intDiv(inNano, div);
            buf.append(digit);
            inNano = inNano - digit * div;
            div = MathUtil.intDiv(div, 10);
          }
        }
        buf.append("Z");
        return true;
      };
      _proto2.parse = function parse2(context, text, position) {
        var newContext = context.copy();
        var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
        var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;
        var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral("T").appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(":").appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(":").appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral("Z").toFormatter()._toPrinterParser(false);
        var pos = parser.parse(newContext, text, position);
        if (pos < 0) {
          return pos;
        }
        var yearParsed = newContext.getParsed(ChronoField.YEAR);
        var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
        var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
        var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
        var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
        var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
        var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
        var sec = secVal != null ? secVal : 0;
        var nano = nanoVal != null ? nanoVal : 0;
        var year = MathUtil.intMod(yearParsed, 1e4);
        var days = 0;
        if (hour === 24 && min === 0 && sec === 0 && nano === 0) {
          hour = 0;
          days = 1;
        } else if (hour === 23 && min === 59 && sec === 60) {
          context.setParsedLeapSecond();
          sec = 59;
        }
        var instantSecs;
        try {
          var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
          instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
          instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 1e4), SECONDS_PER_10000_YEARS);
        } catch (ex) {
          return ~position;
        }
        var successPos = pos;
        successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
        return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
      };
      _proto2.toString = function toString() {
        return "Instant()";
      };
      return InstantPrinterParser2;
    }();
    DefaultingParser = function() {
      function DefaultingParser2(field, value) {
        this._field = field;
        this._value = value;
      }
      var _proto3 = DefaultingParser2.prototype;
      _proto3.print = function print() {
        return true;
      };
      _proto3.parse = function parse2(context, text, position) {
        if (context.getParsed(this._field) == null) {
          context.setParsedField(this._field, this._value, position, position);
        }
        return position;
      };
      return DefaultingParser2;
    }();
    StringBuilder = function() {
      function StringBuilder2() {
        this._str = "";
      }
      var _proto = StringBuilder2.prototype;
      _proto.append = function append(str) {
        this._str += str;
        return this;
      };
      _proto.appendChar = function appendChar(str) {
        this._str += str[0];
        return this;
      };
      _proto.insert = function insert(offset, str) {
        this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
        return this;
      };
      _proto.replace = function replace(start, end, str) {
        this._str = this._str.slice(0, start) + str + this._str.slice(end);
        return this;
      };
      _proto.length = function length() {
        return this._str.length;
      };
      _proto.setLength = function setLength(length) {
        this._str = this._str.slice(0, length);
        return this;
      };
      _proto.toString = function toString() {
        return this._str;
      };
      return StringBuilder2;
    }();
    DateTimeFormatter = function() {
      DateTimeFormatter2.parsedExcessDays = function parsedExcessDays() {
        return DateTimeFormatter2.PARSED_EXCESS_DAYS;
      };
      DateTimeFormatter2.parsedLeapSecond = function parsedLeapSecond() {
        return DateTimeFormatter2.PARSED_LEAP_SECOND;
      };
      DateTimeFormatter2.ofPattern = function ofPattern(pattern) {
        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
      };
      function DateTimeFormatter2(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {
        if (chrono === void 0) {
          chrono = IsoChronology.INSTANCE;
        }
        assert(printerParser != null);
        assert(decimalStyle != null);
        assert(resolverStyle != null);
        this._printerParser = printerParser;
        this._locale = locale;
        this._decimalStyle = decimalStyle;
        this._resolverStyle = resolverStyle;
        this._resolverFields = resolverFields;
        this._chrono = chrono;
        this._zone = zone;
      }
      var _proto = DateTimeFormatter2.prototype;
      _proto.locale = function locale() {
        return this._locale;
      };
      _proto.decimalStyle = function decimalStyle() {
        return this._decimalStyle;
      };
      _proto.chronology = function chronology() {
        return this._chrono;
      };
      _proto.withChronology = function withChronology(chrono) {
        if (this._chrono != null && this._chrono.equals(chrono)) {
          return this;
        }
        return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
      };
      _proto.withLocale = function withLocale() {
        return this;
      };
      _proto.withResolverStyle = function withResolverStyle(resolverStyle) {
        requireNonNull(resolverStyle, "resolverStyle");
        if (resolverStyle.equals(this._resolverStyle)) {
          return this;
        }
        return new DateTimeFormatter2(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
      };
      _proto.format = function format(temporal) {
        var buf = new StringBuilder(32);
        this._formatTo(temporal, buf);
        return buf.toString();
      };
      _proto._formatTo = function _formatTo(temporal, appendable) {
        requireNonNull(temporal, "temporal");
        requireNonNull(appendable, "appendable");
        var context = new DateTimePrintContext(temporal, this);
        this._printerParser.print(context, appendable);
      };
      _proto.parse = function parse2(text, type) {
        if (arguments.length === 1) {
          return this.parse1(text);
        } else {
          return this.parse2(text, type);
        }
      };
      _proto.parse1 = function parse1(text) {
        requireNonNull(text, "text");
        try {
          return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
        } catch (ex) {
          if (ex instanceof DateTimeParseException) {
            throw ex;
          } else {
            throw this._createError(text, ex);
          }
        }
      };
      _proto.parse2 = function parse2(text, type) {
        requireNonNull(text, "text");
        requireNonNull(type, "type");
        try {
          var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
          return builder.build(type);
        } catch (ex) {
          if (ex instanceof DateTimeParseException) {
            throw ex;
          } else {
            throw this._createError(text, ex);
          }
        }
      };
      _proto._createError = function _createError(text, ex) {
        var abbr = "";
        if (text.length > 64) {
          abbr = text.substring(0, 64) + "...";
        } else {
          abbr = text;
        }
        return new DateTimeParseException("Text '" + abbr + "' could not be parsed: " + ex.message, text, 0, ex);
      };
      _proto._parseToBuilder = function _parseToBuilder(text, position) {
        var pos = position != null ? position : new ParsePosition(0);
        var result = this._parseUnresolved0(text, pos);
        if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {
          var abbr = "";
          if (text.length > 64) {
            abbr = text.substr(0, 64).toString() + "...";
          } else {
            abbr = text;
          }
          if (pos.getErrorIndex() >= 0) {
            throw new DateTimeParseException("Text '" + abbr + "' could not be parsed at index " + pos.getErrorIndex(), text, pos.getErrorIndex());
          } else {
            throw new DateTimeParseException("Text '" + abbr + "' could not be parsed, unparsed text found at index " + pos.getIndex(), text, pos.getIndex());
          }
        }
        return result.toBuilder();
      };
      _proto.parseUnresolved = function parseUnresolved(text, position) {
        return this._parseUnresolved0(text, position);
      };
      _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {
        assert(text != null, "text", NullPointerException);
        assert(position != null, "position", NullPointerException);
        var context = new DateTimeParseContext(this);
        var pos = position.getIndex();
        pos = this._printerParser.parse(context, text, pos);
        if (pos < 0) {
          position.setErrorIndex(~pos);
          return null;
        }
        position.setIndex(pos);
        return context.toParsed();
      };
      _proto._toPrinterParser = function _toPrinterParser(optional) {
        return this._printerParser.withOptional(optional);
      };
      _proto.toString = function toString() {
        var pattern = this._printerParser.toString();
        return pattern.indexOf("[") === 0 ? pattern : pattern.substring(1, pattern.length - 1);
      };
      return DateTimeFormatter2;
    }();
    MonthDay = function(_TemporalAccessor) {
      _inheritsLoose(MonthDay2, _TemporalAccessor);
      MonthDay2.now = function now(zoneIdOrClock) {
        if (arguments.length === 0) {
          return MonthDay2.now0();
        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
          return MonthDay2.nowZoneId(zoneIdOrClock);
        } else {
          return MonthDay2.nowClock(zoneIdOrClock);
        }
      };
      MonthDay2.now0 = function now0() {
        return this.nowClock(Clock.systemDefaultZone());
      };
      MonthDay2.nowZoneId = function nowZoneId(zone) {
        requireNonNull(zone, "zone");
        return this.nowClock(Clock.system(zone));
      };
      MonthDay2.nowClock = function nowClock(clock) {
        requireNonNull(clock, "clock");
        var now = LocalDate.now(clock);
        return MonthDay2.of(now.month(), now.dayOfMonth());
      };
      MonthDay2.of = function of(monthOrNumber, number) {
        if (arguments.length === 2 && monthOrNumber instanceof Month) {
          return MonthDay2.ofMonthNumber(monthOrNumber, number);
        } else {
          return MonthDay2.ofNumberNumber(monthOrNumber, number);
        }
      };
      MonthDay2.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
        requireNonNull(month, "month");
        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
        if (dayOfMonth > month.maxLength()) {
          throw new DateTimeException("Illegal value for DayOfMonth field, value " + dayOfMonth + " is not valid for month " + month.toString());
        }
        return new MonthDay2(month.value(), dayOfMonth);
      };
      MonthDay2.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
        requireNonNull(month, "month");
        requireNonNull(dayOfMonth, "dayOfMonth");
        return MonthDay2.of(Month.of(month), dayOfMonth);
      };
      MonthDay2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, TemporalAccessor, "temporal");
        if (temporal instanceof MonthDay2) {
          return temporal;
        }
        try {
          return MonthDay2.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain MonthDay from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      MonthDay2.parse = function parse2(text, formatter) {
        if (arguments.length === 1) {
          return MonthDay2.parseString(text);
        } else {
          return MonthDay2.parseStringFormatter(text, formatter);
        }
      };
      MonthDay2.parseString = function parseString(text) {
        return MonthDay2.parseStringFormatter(text, PARSER$2);
      };
      MonthDay2.parseStringFormatter = function parseStringFormatter(text, formatter) {
        requireNonNull(text, "text");
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.parse(text, MonthDay2.FROM);
      };
      function MonthDay2(month, dayOfMonth) {
        var _this;
        _this = _TemporalAccessor.call(this) || this;
        _this._month = MathUtil.safeToInt(month);
        _this._day = MathUtil.safeToInt(dayOfMonth);
        return _this;
      }
      var _proto = MonthDay2.prototype;
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._day;
      };
      _proto.isSupported = function isSupported(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.MONTH_OF_YEAR) {
          return field.range();
        } else if (field === ChronoField.DAY_OF_MONTH) {
          return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
        }
        return _TemporalAccessor.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.DAY_OF_MONTH:
              return this._day;
            case ChronoField.MONTH_OF_YEAR:
              return this._month;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.isValidYear = function isValidYear(year) {
        return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
      };
      _proto.withMonth = function withMonth(month) {
        return this.with(Month.of(month));
      };
      _proto.with = function _with(month) {
        requireNonNull(month, "month");
        if (month.value() === this._month) {
          return this;
        }
        var day = Math.min(this._day, month.maxLength());
        return new MonthDay2(month.value(), day);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        if (dayOfMonth === this._day) {
          return this;
        }
        return MonthDay2.of(this._month, dayOfMonth);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        requireInstance(_query, TemporalQuery, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        }
        return _TemporalAccessor.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
        return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
      };
      _proto.atYear = function atYear(year) {
        return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        var cmp = this._month - other.monthValue();
        if (cmp === 0) {
          cmp = this._day - other.dayOfMonth();
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        requireInstance(other, MonthDay2, "other");
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof MonthDay2) {
          var other = obj;
          return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
        }
        return false;
      };
      _proto.toString = function toString() {
        return "--" + (this._month < 10 ? "0" : "") + this._month + (this._day < 10 ? "-0" : "-") + this._day;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      return MonthDay2;
    }(TemporalAccessor);
    YearMonth = function(_Temporal) {
      _inheritsLoose(YearMonth2, _Temporal);
      YearMonth2.now = function now(zoneIdOrClock) {
        if (arguments.length === 0) {
          return YearMonth2.now0();
        } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
          return YearMonth2.nowZoneId(zoneIdOrClock);
        } else {
          return YearMonth2.nowClock(zoneIdOrClock);
        }
      };
      YearMonth2.now0 = function now0() {
        return YearMonth2.nowClock(Clock.systemDefaultZone());
      };
      YearMonth2.nowZoneId = function nowZoneId(zone) {
        return YearMonth2.nowClock(Clock.system(zone));
      };
      YearMonth2.nowClock = function nowClock(clock) {
        var now = LocalDate.now(clock);
        return YearMonth2.of(now.year(), now.month());
      };
      YearMonth2.of = function of(year, monthOrNumber) {
        if (arguments.length === 2 && monthOrNumber instanceof Month) {
          return YearMonth2.ofNumberMonth(year, monthOrNumber);
        } else {
          return YearMonth2.ofNumberNumber(year, monthOrNumber);
        }
      };
      YearMonth2.ofNumberMonth = function ofNumberMonth(year, month) {
        requireNonNull(month, "month");
        requireInstance(month, Month, "month");
        return YearMonth2.ofNumberNumber(year, month.value());
      };
      YearMonth2.ofNumberNumber = function ofNumberNumber(year, month) {
        requireNonNull(year, "year");
        requireNonNull(month, "month");
        ChronoField.YEAR.checkValidValue(year);
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        return new YearMonth2(year, month);
      };
      YearMonth2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof YearMonth2) {
          return temporal;
        }
        try {
          return YearMonth2.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain YearMonth from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      YearMonth2.parse = function parse2(text, formatter) {
        if (arguments.length === 1) {
          return YearMonth2.parseString(text);
        } else {
          return YearMonth2.parseStringFormatter(text, formatter);
        }
      };
      YearMonth2.parseString = function parseString(text) {
        return YearMonth2.parseStringFormatter(text, PARSER$1);
      };
      YearMonth2.parseStringFormatter = function parseStringFormatter(text, formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, YearMonth2.FROM);
      };
      function YearMonth2(year, month) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this._year = MathUtil.safeToInt(year);
        _this._month = MathUtil.safeToInt(month);
        return _this;
      }
      var _proto = YearMonth2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
          return this.isSupportedField(fieldOrUnit);
        } else {
          return this.isSupportedUnit(fieldOrUnit);
        }
      };
      _proto.isSupportedField = function isSupportedField(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.isSupportedUnit = function isSupportedUnit(unit) {
        if (unit instanceof ChronoUnit) {
          return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
        }
        return unit != null && unit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field === ChronoField.YEAR_OF_ERA) {
          return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
        }
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.MONTH_OF_YEAR:
              return this._month;
            case ChronoField.PROLEPTIC_MONTH:
              return this._getProlepticMonth();
            case ChronoField.YEAR_OF_ERA:
              return this._year < 1 ? 1 - this._year : this._year;
            case ChronoField.YEAR:
              return this._year;
            case ChronoField.ERA:
              return this._year < 1 ? 0 : 1;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto._getProlepticMonth = function _getProlepticMonth() {
        return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
      };
      _proto.year = function year() {
        return this._year;
      };
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.isLeapYear = function isLeapYear() {
        return IsoChronology.isLeapYear(this._year);
      };
      _proto.isValidDay = function isValidDay(dayOfMonth) {
        return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
      };
      _proto.lengthOfMonth = function lengthOfMonth() {
        return this.month().length(this.isLeapYear());
      };
      _proto.lengthOfYear = function lengthOfYear() {
        return this.isLeapYear() ? 366 : 365;
      };
      _proto.with = function _with(adjusterOrField, value) {
        if (arguments.length === 1) {
          return this._withAdjuster(adjusterOrField);
        } else {
          return this._withField(adjusterOrField, value);
        }
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          var f = field;
          f.checkValidValue(newValue);
          switch (f) {
            case ChronoField.MONTH_OF_YEAR:
              return this.withMonth(newValue);
            case ChronoField.PROLEPTIC_MONTH:
              return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
            case ChronoField.YEAR_OF_ERA:
              return this.withYear(this._year < 1 ? 1 - newValue : newValue);
            case ChronoField.YEAR:
              return this.withYear(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        ChronoField.YEAR.checkValidValue(year);
        return new YearMonth2(year, this._month);
      };
      _proto.withMonth = function withMonth(month) {
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        return new YearMonth2(this._year, month);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.MONTHS:
              return this.plusMonths(amountToAdd);
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
        return this.withYear(newYear);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        var monthCount = this._year * 12 + (this._month - 1);
        var calcMonths = monthCount + monthsToAdd;
        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
        return new YearMonth2(newYear, newMonth);
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        requireInstance(_query, TemporalQuery, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.MONTHS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, Temporal, "temporal");
        return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        requireInstance(endExclusive, Temporal, "endExclusive");
        requireInstance(unit, TemporalUnit, "unit");
        var end = YearMonth2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();
          switch (unit) {
            case ChronoUnit.MONTHS:
              return monthsUntil;
            case ChronoUnit.YEARS:
              return MathUtil.intDiv(monthsUntil, 12);
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(monthsUntil, 120);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(monthsUntil, 1200);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(monthsUntil, 12e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.atDay = function atDay(dayOfMonth) {
        requireNonNull(dayOfMonth, "dayOfMonth");
        return LocalDate.of(this._year, this._month, dayOfMonth);
      };
      _proto.atEndOfMonth = function atEndOfMonth() {
        return LocalDate.of(this._year, this._month, this.lengthOfMonth());
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, YearMonth2, "other");
        var cmp = this._year - other.year();
        if (cmp === 0) {
          cmp = this._month - other.monthValue();
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(obj) {
        if (this === obj) {
          return true;
        }
        if (obj instanceof YearMonth2) {
          var other = obj;
          return this.year() === other.year() && this.monthValue() === other.monthValue();
        }
        return false;
      };
      _proto.toString = function toString() {
        return PARSER$1.format(this);
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return YearMonth2;
    }(Temporal);
    Year = function(_Temporal) {
      _inheritsLoose(Year2, _Temporal);
      function Year2(value) {
        var _this;
        _this = _Temporal.call(this) || this;
        _this._year = MathUtil.safeToInt(value);
        return _this;
      }
      var _proto = Year2.prototype;
      _proto.value = function value() {
        return this._year;
      };
      Year2.now = function now(zoneIdOrClock) {
        if (zoneIdOrClock === void 0) {
          zoneIdOrClock = void 0;
        }
        if (zoneIdOrClock === void 0) {
          return Year2.now0();
        } else if (zoneIdOrClock instanceof ZoneId) {
          return Year2.nowZoneId(zoneIdOrClock);
        } else {
          return Year2.nowClock(zoneIdOrClock);
        }
      };
      Year2.now0 = function now0() {
        return Year2.nowClock(Clock.systemDefaultZone());
      };
      Year2.nowZoneId = function nowZoneId(zone) {
        requireNonNull(zone, "zone");
        requireInstance(zone, ZoneId, "zone");
        return Year2.nowClock(Clock.system(zone));
      };
      Year2.nowClock = function nowClock(clock) {
        requireNonNull(clock, "clock");
        requireInstance(clock, Clock, "clock");
        var now = LocalDate.now(clock);
        return Year2.of(now.year());
      };
      Year2.of = function of(isoYear) {
        requireNonNull(isoYear, "isoYear");
        ChronoField.YEAR.checkValidValue(isoYear);
        return new Year2(isoYear);
      };
      Year2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        requireInstance(temporal, TemporalAccessor, "temporal");
        if (temporal instanceof Year2) {
          return temporal;
        }
        try {
          return Year2.of(temporal.get(ChronoField.YEAR));
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Year from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      Year2.parse = function parse2(text, formatter) {
        if (arguments.length <= 1) {
          return Year2.parseText(text);
        } else {
          return Year2.parseTextFormatter(text, formatter);
        }
      };
      Year2.parseText = function parseText(text) {
        requireNonNull(text, "text");
        return Year2.parse(text, PARSER);
      };
      Year2.parseTextFormatter = function parseTextFormatter(text, formatter) {
        if (formatter === void 0) {
          formatter = PARSER;
        }
        requireNonNull(text, "text");
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.parse(text, Year2.FROM);
      };
      Year2.isLeap = function isLeap(year) {
        return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
          return this.isSupportedField(fieldOrUnit);
        } else {
          return this.isSupportedUnit(fieldOrUnit);
        }
      };
      _proto.isSupportedField = function isSupportedField(field) {
        if (field instanceof ChronoField) {
          return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
        }
        return field != null && field.isSupportedBy(this);
      };
      _proto.isSupportedUnit = function isSupportedUnit(unit) {
        if (unit instanceof ChronoUnit) {
          return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
        }
        return unit != null && unit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (this.isSupported(field)) {
          return field.range();
        } else if (field instanceof ChronoField) {
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.range(field).checkValidIntValue(this.getLong(field), field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.YEAR_OF_ERA:
              return this._year < 1 ? 1 - this._year : this._year;
            case ChronoField.YEAR:
              return this._year;
            case ChronoField.ERA:
              return this._year < 1 ? 0 : 1;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.isLeap = function isLeap() {
        return Year2.isLeap(this._year);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.YEAR_OF_ERA:
              return Year2.of(this._year < 1 ? 1 - newValue : newValue);
            case ChronoField.YEAR:
              return Year2.of(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : Year2.of(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        return Year2.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.YEAR, this._year);
      };
      _proto.isValidMonthDay = function isValidMonthDay(monthDay) {
        return monthDay != null && monthDay.isValidYear(this._year);
      };
      _proto.length = function length() {
        return this.isLeap() ? 366 : 365;
      };
      _proto.atDay = function atDay(dayOfYear) {
        return LocalDate.ofYearDay(this._year, dayOfYear);
      };
      _proto.atMonth = function atMonth(monthOrNumber) {
        if (arguments.length === 1 && monthOrNumber instanceof Month) {
          return this.atMonthMonth(monthOrNumber);
        } else {
          return this.atMonthNumber(monthOrNumber);
        }
      };
      _proto.atMonthMonth = function atMonthMonth(month) {
        requireNonNull(month, "month");
        requireInstance(month, Month, "month");
        return YearMonth.of(this._year, month);
      };
      _proto.atMonthNumber = function atMonthNumber(month) {
        requireNonNull(month, "month");
        return YearMonth.of(this._year, month);
      };
      _proto.atMonthDay = function atMonthDay(monthDay) {
        requireNonNull(monthDay, "monthDay");
        requireInstance(monthDay, MonthDay, "monthDay");
        return monthDay.atYear(this._year);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query()");
        requireInstance(_query, TemporalQuery, "query()");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.YEARS;
        } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year - other._year;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year > other._year;
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        requireInstance(other, Year2, "other");
        return this._year < other._year;
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return formatter.format(this);
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Year2) {
          return this.value() === other.value();
        }
        return false;
      };
      _proto.toString = function toString() {
        return "" + this._year;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.until = function until(endExclusive, unit) {
        var end = Year2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var yearsUntil = end.value() - this.value();
          switch (unit) {
            case ChronoUnit.YEARS:
              return yearsUntil;
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(yearsUntil, 10);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(yearsUntil, 100);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(yearsUntil, 1e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      return Year2;
    }(Temporal);
    TemporalAdjuster = function() {
      function TemporalAdjuster2() {
      }
      var _proto = TemporalAdjuster2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        abstractMethodFail("adjustInto");
      };
      return TemporalAdjuster2;
    }();
    TemporalAdjusters = function() {
      function TemporalAdjusters2() {
      }
      TemporalAdjusters2.firstDayOfMonth = function firstDayOfMonth() {
        return Impl.FIRST_DAY_OF_MONTH;
      };
      TemporalAdjusters2.lastDayOfMonth = function lastDayOfMonth() {
        return Impl.LAST_DAY_OF_MONTH;
      };
      TemporalAdjusters2.firstDayOfNextMonth = function firstDayOfNextMonth() {
        return Impl.FIRST_DAY_OF_NEXT_MONTH;
      };
      TemporalAdjusters2.firstDayOfYear = function firstDayOfYear() {
        return Impl.FIRST_DAY_OF_YEAR;
      };
      TemporalAdjusters2.lastDayOfYear = function lastDayOfYear() {
        return Impl.LAST_DAY_OF_YEAR;
      };
      TemporalAdjusters2.firstDayOfNextYear = function firstDayOfNextYear() {
        return Impl.FIRST_DAY_OF_NEXT_YEAR;
      };
      TemporalAdjusters2.firstInMonth = function firstInMonth(dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(1, dayOfWeek);
      };
      TemporalAdjusters2.lastInMonth = function lastInMonth(dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(-1, dayOfWeek);
      };
      TemporalAdjusters2.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
        requireNonNull(dayOfWeek, "dayOfWeek");
        return new DayOfWeekInMonth(ordinal, dayOfWeek);
      };
      TemporalAdjusters2.next = function next(dayOfWeek) {
        return new RelativeDayOfWeek(2, dayOfWeek);
      };
      TemporalAdjusters2.nextOrSame = function nextOrSame(dayOfWeek) {
        return new RelativeDayOfWeek(0, dayOfWeek);
      };
      TemporalAdjusters2.previous = function previous(dayOfWeek) {
        return new RelativeDayOfWeek(3, dayOfWeek);
      };
      TemporalAdjusters2.previousOrSame = function previousOrSame(dayOfWeek) {
        return new RelativeDayOfWeek(1, dayOfWeek);
      };
      return TemporalAdjusters2;
    }();
    Impl = function(_TemporalAdjuster) {
      _inheritsLoose(Impl2, _TemporalAdjuster);
      function Impl2(ordinal) {
        var _this;
        _this = _TemporalAdjuster.call(this) || this;
        _this._ordinal = ordinal;
        return _this;
      }
      var _proto = Impl2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        switch (this._ordinal) {
          case 0:
            return temporal.with(ChronoField.DAY_OF_MONTH, 1);
          case 1:
            return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
          case 2:
            return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);
          case 3:
            return temporal.with(ChronoField.DAY_OF_YEAR, 1);
          case 4:
            return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());
          case 5:
            return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
        }
        throw new IllegalStateException("Unreachable");
      };
      return Impl2;
    }(TemporalAdjuster);
    Impl.FIRST_DAY_OF_MONTH = new Impl(0);
    Impl.LAST_DAY_OF_MONTH = new Impl(1);
    Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);
    Impl.FIRST_DAY_OF_YEAR = new Impl(3);
    Impl.LAST_DAY_OF_YEAR = new Impl(4);
    Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);
    DayOfWeekInMonth = function(_TemporalAdjuster2) {
      _inheritsLoose(DayOfWeekInMonth2, _TemporalAdjuster2);
      function DayOfWeekInMonth2(ordinal, dow) {
        var _this2;
        _this2 = _TemporalAdjuster2.call(this) || this;
        _this2._ordinal = ordinal;
        _this2._dowValue = dow.value();
        return _this2;
      }
      var _proto2 = DayOfWeekInMonth2.prototype;
      _proto2.adjustInto = function adjustInto(temporal) {
        if (this._ordinal >= 0) {
          var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
          var curDow = temp.get(ChronoField.DAY_OF_WEEK);
          var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
          dowDiff += (this._ordinal - 1) * 7;
          return temp.plus(dowDiff, ChronoUnit.DAYS);
        } else {
          var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
          var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);
          var daysDiff = this._dowValue - _curDow;
          daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
          daysDiff -= (-this._ordinal - 1) * 7;
          return _temp.plus(daysDiff, ChronoUnit.DAYS);
        }
      };
      return DayOfWeekInMonth2;
    }(TemporalAdjuster);
    RelativeDayOfWeek = function(_TemporalAdjuster3) {
      _inheritsLoose(RelativeDayOfWeek2, _TemporalAdjuster3);
      function RelativeDayOfWeek2(relative, dayOfWeek) {
        var _this3;
        _this3 = _TemporalAdjuster3.call(this) || this;
        requireNonNull(dayOfWeek, "dayOfWeek");
        _this3._relative = relative;
        _this3._dowValue = dayOfWeek.value();
        return _this3;
      }
      var _proto3 = RelativeDayOfWeek2.prototype;
      _proto3.adjustInto = function adjustInto(temporal) {
        var calDow = temporal.get(ChronoField.DAY_OF_WEEK);
        if (this._relative < 2 && calDow === this._dowValue) {
          return temporal;
        }
        if ((this._relative & 1) === 0) {
          var daysDiff = calDow - this._dowValue;
          return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
        } else {
          var _daysDiff = this._dowValue - calDow;
          return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
        }
      };
      return RelativeDayOfWeek2;
    }(TemporalAdjuster);
    IsoChronology = function(_Enum) {
      _inheritsLoose(IsoChronology2, _Enum);
      function IsoChronology2() {
        return _Enum.apply(this, arguments) || this;
      }
      IsoChronology2.isLeapYear = function isLeapYear(prolepticYear) {
        return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
      };
      var _proto = IsoChronology2.prototype;
      _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
        requireNonNull(fieldValues, "fieldValues");
        requireNonNull(field, "field");
        var current = fieldValues.get(field);
        if (current != null && current !== value) {
          throw new DateTimeException("Invalid state, field: " + field + " " + current + " conflicts with " + field + " " + value);
        }
        fieldValues.put(field, value);
      };
      _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {
        if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
          return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
        }
        var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);
        if (prolepticMonth != null) {
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
          }
          this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);
          this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
        }
        var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);
        if (yoeLong != null) {
          if (resolverStyle !== ResolverStyle.LENIENT) {
            ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
          }
          var era = fieldValues.remove(ChronoField.ERA);
          if (era == null) {
            var year = fieldValues.get(ChronoField.YEAR);
            if (resolverStyle === ResolverStyle.STRICT) {
              if (year != null) {
                this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
              } else {
                fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
              }
            } else {
              this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
            }
          } else if (era === 1) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
          } else if (era === 0) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
          } else {
            throw new DateTimeException("Invalid value for era: " + era);
          }
        } else if (fieldValues.containsKey(ChronoField.ERA)) {
          ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
        }
        if (fieldValues.containsKey(ChronoField.YEAR)) {
          if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
            if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
              var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
              var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);
              if (resolverStyle === ResolverStyle.LENIENT) {
                var months = moy - 1;
                var days = dom - 1;
                return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
              } else if (resolverStyle === ResolverStyle.SMART) {
                ChronoField.DAY_OF_MONTH.checkValidValue(dom);
                if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
                  dom = Math.min(dom, 30);
                } else if (moy === 2) {
                  dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
                }
                return LocalDate.of(y, moy, dom);
              } else {
                return LocalDate.of(y, moy, dom);
              }
            }
          }
          if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
            var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
            if (resolverStyle === ResolverStyle.LENIENT) {
              var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);
              return LocalDate.ofYearDay(_y, 1).plusDays(_days);
            }
            var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
            return LocalDate.ofYearDay(_y, doy);
          }
          if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
            if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
              var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              if (resolverStyle === ResolverStyle.LENIENT) {
                var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
                return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
              }
              var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
              var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
              var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));
              if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {
                throw new DateTimeException("Strict mode rejected date parsed to a different year");
              }
              return date;
            }
            if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
              var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
              if (resolverStyle === ResolverStyle.LENIENT) {
                var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
                var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);
                return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
              }
              var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
              var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));
              var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));
              if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {
                throw new DateTimeException("Strict mode rejected date parsed to a different month");
              }
              return _date;
            }
          }
        }
        return null;
      };
      _proto.date = function date(temporal) {
        return LocalDate.from(temporal);
      };
      return IsoChronology2;
    }(Enum);
    OffsetTime = function(_Temporal) {
      _inheritsLoose(OffsetTime2, _Temporal);
      OffsetTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof OffsetTime2) {
          return temporal;
        } else if (temporal instanceof OffsetDateTime) {
          return temporal.toOffsetTime();
        }
        try {
          var time = LocalTime.from(temporal);
          var offset = ZoneOffset.from(temporal);
          return new OffsetTime2(time, offset);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain OffsetTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      OffsetTime2.now = function now(clockOrZone) {
        if (arguments.length === 0) {
          return OffsetTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return OffsetTime2._now(clockOrZone);
        } else {
          return OffsetTime2._now(Clock.system(clockOrZone));
        }
      };
      OffsetTime2._now = function _now(clock) {
        requireNonNull(clock, "clock");
        var now = clock.instant();
        return OffsetTime2.ofInstant(now, clock.zone().rules().offset(now));
      };
      OffsetTime2.of = function of() {
        if (arguments.length <= 2) {
          return OffsetTime2.ofTimeAndOffset.apply(this, arguments);
        } else {
          return OffsetTime2.ofNumbers.apply(this, arguments);
        }
      };
      OffsetTime2.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {
        var time = LocalTime.of(hour, minute, second, nanoOfSecond);
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.ofInstant = function ofInstant(instant, zone) {
        requireNonNull(instant, "instant");
        requireInstance(instant, Instant, "instant");
        requireNonNull(zone, "zone");
        requireInstance(zone, ZoneId, "zone");
        var rules = zone.rules();
        var offset = rules.offset(instant);
        var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;
        secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;
        if (secsOfDay < 0) {
          secsOfDay += LocalTime.SECONDS_PER_DAY;
        }
        var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
        return new OffsetTime2(time, offset);
      };
      OffsetTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_OFFSET_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, OffsetTime2.FROM);
      };
      function OffsetTime2(time, offset) {
        var _this;
        _this = _Temporal.call(this) || this;
        requireNonNull(time, "time");
        requireInstance(time, LocalTime, "time");
        requireNonNull(offset, "offset");
        requireInstance(offset, ZoneOffset, "offset");
        _this._time = time;
        _this._offset = offset;
        return _this;
      }
      var _proto = OffsetTime2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
      };
      _proto.atDate = function atDate(date) {
        return OffsetDateTime.of(date, this._time, this._offset);
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this, OffsetTime2.FROM);
      };
      _proto.get = function get(field) {
        return _Temporal.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return this._offset.totalSeconds();
          }
          return this._time.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.hour = function hour() {
        return this._time.hour();
      };
      _proto.minute = function minute() {
        return this._time.minute();
      };
      _proto.second = function second() {
        return this._time.second();
      };
      _proto.nano = function nano() {
        return this._time.nano();
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() > other._toEpochNano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() < other._toEpochNano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this._toEpochNano() === other._toEpochNano();
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount);
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this.plus(-1 * amountToSubtract, unit);
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount);
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this.offset();
        } else if (_query === TemporalQueries.localTime()) {
          return this._time;
        } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._time.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._time;
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = OffsetTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var nanosUntil = end._toEpochNano() - this._toEpochNano();
          switch (unit) {
            case ChronoUnit.NANOS:
              return nanosUntil;
            case ChronoUnit.MICROS:
              return MathUtil.intDiv(nanosUntil, 1e3);
            case ChronoUnit.MILLIS:
              return MathUtil.intDiv(nanosUntil, 1e6);
            case ChronoUnit.SECONDS:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.withHour = function withHour(hour) {
        return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);
      };
      _proto.withMinute = function withMinute(minute) {
        return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);
      };
      _proto.withSecond = function withSecond(second) {
        return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);
      };
      _proto.withNano = function withNano(nano) {
        return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);
      };
      _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
        requireNonNull(offset, "offset");
        if (offset.equals(this._offset)) {
          return this;
        }
        var difference = offset.totalSeconds() - this._offset.totalSeconds();
        var adjusted = this._time.plusSeconds(difference);
        return new OffsetTime2(adjusted, offset);
      };
      _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
        return offset != null && offset.equals(this._offset) ? this : new OffsetTime2(this._time, offset);
      };
      _proto._toEpochNano = function _toEpochNano() {
        var nod = this._time.toNanoOfDay();
        var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;
        return nod - offsetNanos;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalTime) {
          return this._withLocalTimeOffset(adjuster, this._offset);
        } else if (adjuster instanceof ZoneOffset) {
          return this._withLocalTimeOffset(this._time, adjuster);
        } else if (adjuster instanceof OffsetTime2) {
          return adjuster;
        }
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          if (field === ChronoField.OFFSET_SECONDS) {
            return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));
          }
          return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {
        if (this._time === time && this._offset.equals(offset)) {
          return this;
        }
        return new OffsetTime2(time, offset);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, OffsetTime2, "other");
        if (this._offset.equals(other._offset)) {
          return this._time.compareTo(other._time);
        }
        var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());
        if (compare === 0) {
          return this._time.compareTo(other._time);
        }
        return compare;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof OffsetTime2) {
          return this._time.equals(other._time) && this._offset.equals(other._offset);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._time.hashCode() ^ this._offset.hashCode();
      };
      _proto.toString = function toString() {
        return this._time.toString() + this._offset.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return OffsetTime2;
    }(Temporal);
    ChronoZonedDateTime = function(_Temporal) {
      _inheritsLoose(ChronoZonedDateTime2, _Temporal);
      function ChronoZonedDateTime2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoZonedDateTime2.prototype;
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
          return this.zone();
        } else if (_query === TemporalQueries.chronology()) {
          return this.toLocalDate().chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset()) {
          return this.offset();
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      _proto.toInstant = function toInstant() {
        return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
      };
      _proto.toEpochSecond = function toEpochSecond() {
        var epochDay = this.toLocalDate().toEpochDay();
        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
        secs -= this.offset().totalSeconds();
        return secs;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
        if (cmp === 0) {
          cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
          if (cmp === 0) {
            cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
            if (cmp === 0) {
              cmp = strcmp(this.zone().id(), other.zone().id());
            }
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ChronoZonedDateTime2) {
          return this.compareTo(other) === 0;
        }
        return false;
      };
      return ChronoZonedDateTime2;
    }(Temporal);
    ZonedDateTime = function(_ChronoZonedDateTime) {
      _inheritsLoose(ZonedDateTime2, _ChronoZonedDateTime);
      ZonedDateTime2.now = function now(clockOrZone) {
        var clock;
        if (clockOrZone instanceof ZoneId) {
          clock = Clock.system(clockOrZone);
        } else {
          clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
        }
        return ZonedDateTime2.ofInstant(clock.instant(), clock.zone());
      };
      ZonedDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return ZonedDateTime2.of2.apply(this, arguments);
        } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
          return ZonedDateTime2.of3.apply(this, arguments);
        } else {
          return ZonedDateTime2.of8.apply(this, arguments);
        }
      };
      ZonedDateTime2.of3 = function of3(date, time, zone) {
        return ZonedDateTime2.of2(LocalDateTime.of(date, time), zone);
      };
      ZonedDateTime2.of2 = function of2(localDateTime, zone) {
        return ZonedDateTime2.ofLocal(localDateTime, zone, null);
      };
      ZonedDateTime2.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
        return ZonedDateTime2.ofLocal(dt, zone, null);
      };
      ZonedDateTime2.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(zone, "zone");
        if (zone instanceof ZoneOffset) {
          return new ZonedDateTime2(localDateTime, zone, zone);
        }
        var offset = null;
        var rules = zone.rules();
        var validOffsets = rules.validOffsets(localDateTime);
        if (validOffsets.length === 1) {
          offset = validOffsets[0];
        } else if (validOffsets.length === 0) {
          var trans = rules.transition(localDateTime);
          localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
          offset = trans.offsetAfter();
        } else {
          if (preferredOffset != null && validOffsets.some(function(validOffset) {
            return validOffset.equals(preferredOffset);
          })) {
            offset = preferredOffset;
          } else {
            offset = requireNonNull(validOffsets[0], "offset");
          }
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.ofInstant = function ofInstant() {
        if (arguments.length === 2) {
          return ZonedDateTime2.ofInstant2.apply(this, arguments);
        } else {
          return ZonedDateTime2.ofInstant3.apply(this, arguments);
        }
      };
      ZonedDateTime2.ofInstant2 = function ofInstant2(instant, zone) {
        requireNonNull(instant, "instant");
        requireNonNull(zone, "zone");
        return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), zone);
      };
      ZonedDateTime2.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        return ZonedDateTime2._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
      };
      ZonedDateTime2._create = function _create(epochSecond, nanoOfSecond, zone) {
        var rules = zone.rules();
        var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
        var offset = rules.offset(instant);
        var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
        return new ZonedDateTime2(ldt, offset, zone);
      };
      ZonedDateTime2.ofStrict = function ofStrict(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        var rules = zone.rules();
        if (rules.isValidOffset(localDateTime, offset) === false) {
          var trans = rules.transition(localDateTime);
          if (trans != null && trans.isGap()) {
            throw new DateTimeException("LocalDateTime " + localDateTime + " does not exist in zone " + zone + " due to a gap in the local time-line, typically caused by daylight savings");
          }
          throw new DateTimeException('ZoneOffset "' + offset + '" is not valid for LocalDateTime "' + localDateTime + '" in zone "' + zone + '"');
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.ofLenient = function ofLenient(localDateTime, offset, zone) {
        requireNonNull(localDateTime, "localDateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
          throw new IllegalArgumentException("ZoneId must match ZoneOffset");
        }
        return new ZonedDateTime2(localDateTime, offset, zone);
      };
      ZonedDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof ZonedDateTime2) {
          return temporal;
        }
        var zone = ZoneId.from(temporal);
        if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
          var zdt = ZonedDateTime2._from(temporal, zone);
          if (zdt != null)
            return zdt;
        }
        var ldt = LocalDateTime.from(temporal);
        return ZonedDateTime2.of2(ldt, zone);
      };
      ZonedDateTime2._from = function _from(temporal, zone) {
        try {
          return ZonedDateTime2.__from(temporal, zone);
        } catch (ex) {
          if (!(ex instanceof DateTimeException))
            throw ex;
        }
      };
      ZonedDateTime2.__from = function __from(temporal, zone) {
        var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
        var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
        return ZonedDateTime2._create(epochSecond, nanoOfSecond, zone);
      };
      ZonedDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, ZonedDateTime2.FROM);
      };
      function ZonedDateTime2(dateTime, offset, zone) {
        var _this;
        requireNonNull(dateTime, "dateTime");
        requireNonNull(offset, "offset");
        requireNonNull(zone, "zone");
        _this = _ChronoZonedDateTime.call(this) || this;
        _this._dateTime = dateTime;
        _this._offset = offset;
        _this._zone = zone;
        return _this;
      }
      var _proto = ZonedDateTime2.prototype;
      _proto._resolveLocal = function _resolveLocal(newDateTime) {
        requireNonNull(newDateTime, "newDateTime");
        return ZonedDateTime2.ofLocal(newDateTime, this._zone, this._offset);
      };
      _proto._resolveInstant = function _resolveInstant(newDateTime) {
        return ZonedDateTime2.ofInstant3(newDateTime, this._offset, this._zone);
      };
      _proto._resolveOffset = function _resolveOffset(offset) {
        if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
          return new ZonedDateTime2(this._dateTime, offset, this._zone);
        }
        return this;
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return true;
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._dateTime.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return this.toEpochSecond();
            case ChronoField.OFFSET_SECONDS:
              return this._offset.totalSeconds();
          }
          return this._dateTime.getLong(field);
        }
        requireNonNull(field, "field");
        return field.getFrom(this);
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
        var trans = this._zone.rules().transition(this._dateTime);
        if (trans != null && trans.isOverlap()) {
          var earlierOffset = trans.offsetBefore();
          if (earlierOffset.equals(this._offset) === false) {
            return new ZonedDateTime2(this._dateTime, earlierOffset, this._zone);
          }
        }
        return this;
      };
      _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
        var trans = this._zone.rules().transition(this.toLocalDateTime());
        if (trans != null) {
          var laterOffset = trans.offsetAfter();
          if (laterOffset.equals(this._offset) === false) {
            return new ZonedDateTime2(this._dateTime, laterOffset, this._zone);
          }
        }
        return this;
      };
      _proto.zone = function zone() {
        return this._zone;
      };
      _proto.withZoneSameLocal = function withZoneSameLocal(zone) {
        requireNonNull(zone, "zone");
        return this._zone.equals(zone) ? this : ZonedDateTime2.ofLocal(this._dateTime, zone, this._offset);
      };
      _proto.withZoneSameInstant = function withZoneSameInstant(zone) {
        requireNonNull(zone, "zone");
        return this._zone.equals(zone) ? this : ZonedDateTime2._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
      };
      _proto.withFixedOffsetZone = function withFixedOffsetZone() {
        return this._zone.equals(this._offset) ? this : new ZonedDateTime2(this._dateTime, this._offset, this._offset);
      };
      _proto.year = function year() {
        return this._dateTime.year();
      };
      _proto.monthValue = function monthValue() {
        return this._dateTime.monthValue();
      };
      _proto.month = function month() {
        return this._dateTime.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._dateTime.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._dateTime.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._dateTime.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._dateTime.hour();
      };
      _proto.minute = function minute() {
        return this._dateTime.minute();
      };
      _proto.second = function second() {
        return this._dateTime.second();
      };
      _proto.nano = function nano() {
        return this._dateTime.nano();
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        if (adjuster instanceof LocalDate) {
          return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
        } else if (adjuster instanceof LocalTime) {
          return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
        } else if (adjuster instanceof LocalDateTime) {
          return this._resolveLocal(adjuster);
        } else if (adjuster instanceof Instant) {
          var instant = adjuster;
          return ZonedDateTime2._create(instant.epochSecond(), instant.nano(), this._zone);
        } else if (adjuster instanceof ZoneOffset) {
          return this._resolveOffset(adjuster);
        }
        return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return ZonedDateTime2._create(newValue, this.nano(), this._zone);
            case ChronoField.OFFSET_SECONDS: {
              var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
              return this._resolveOffset(offset);
            }
          }
          return this._resolveLocal(this._dateTime.with(field, newValue));
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        return this._resolveLocal(this._dateTime.withYear(year));
      };
      _proto.withMonth = function withMonth(month) {
        return this._resolveLocal(this._dateTime.withMonth(month));
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
      };
      _proto.withHour = function withHour(hour) {
        return this._resolveLocal(this._dateTime.withHour(hour));
      };
      _proto.withMinute = function withMinute(minute) {
        return this._resolveLocal(this._dateTime.withMinute(minute));
      };
      _proto.withSecond = function withSecond(second) {
        return this._resolveLocal(this._dateTime.withSecond(second));
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._resolveLocal(this._dateTime.truncatedTo(unit));
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          if (unit.isDateBased()) {
            return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
          } else {
            return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
          }
        }
        requireNonNull(unit, "unit");
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        return this._resolveLocal(this._dateTime.plusYears(years));
      };
      _proto.plusMonths = function plusMonths(months) {
        return this._resolveLocal(this._dateTime.plusMonths(months));
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        return this._resolveLocal(this._dateTime.plusWeeks(weeks));
      };
      _proto.plusDays = function plusDays(days) {
        return this._resolveLocal(this._dateTime.plusDays(days));
      };
      _proto.plusHours = function plusHours(hours) {
        return this._resolveInstant(this._dateTime.plusHours(hours));
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._resolveInstant(this._dateTime.plusMinutes(minutes));
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._resolveInstant(this._dateTime.plusSeconds(seconds));
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._resolveInstant(this._dateTime.plusNanos(nanos));
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this.plusYears(-1 * years);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this.plusMonths(-1 * months);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this.plusWeeks(-1 * weeks);
      };
      _proto.minusDays = function minusDays(days) {
        return this.plusDays(-1 * days);
      };
      _proto.minusHours = function minusHours(hours) {
        return this.plusHours(-1 * hours);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this.plusMinutes(-1 * minutes);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this.plusSeconds(-1 * seconds);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this.plusNanos(-1 * nanos);
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        }
        requireNonNull(_query, "query");
        return _ChronoZonedDateTime.prototype.query.call(this, _query);
      };
      _proto.until = function until(endExclusive, unit) {
        var end = ZonedDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          end = end.withZoneSameInstant(this._zone);
          if (unit.isDateBased()) {
            return this._dateTime.until(end._dateTime, unit);
          } else {
            var difference = this._offset.totalSeconds() - end._offset.totalSeconds();
            var adjustedEnd = end._dateTime.plusSeconds(difference);
            return this._dateTime.until(adjustedEnd, unit);
          }
        }
        return unit.between(this, end);
      };
      _proto.toLocalDateTime = function toLocalDateTime() {
        return this._dateTime;
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._dateTime.toLocalDate();
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._dateTime.toLocalTime();
      };
      _proto.toOffsetDateTime = function toOffsetDateTime() {
        return OffsetDateTime.of(this._dateTime, this._offset);
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ZonedDateTime2) {
          return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
      };
      _proto.toString = function toString() {
        var str = this._dateTime.toString() + this._offset.toString();
        if (this._offset !== this._zone) {
          str += "[" + this._zone.toString() + "]";
        }
        return str;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        return _ChronoZonedDateTime.prototype.format.call(this, formatter);
      };
      return ZonedDateTime2;
    }(ChronoZonedDateTime);
    OffsetDateTime = function(_Temporal) {
      _inheritsLoose(OffsetDateTime2, _Temporal);
      OffsetDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof OffsetDateTime2) {
          return temporal;
        }
        try {
          var offset = ZoneOffset.from(temporal);
          try {
            var ldt = LocalDateTime.from(temporal);
            return OffsetDateTime2.of(ldt, offset);
          } catch (_2) {
            var instant = Instant.from(temporal);
            return OffsetDateTime2.ofInstant(instant, offset);
          }
        } catch (ex) {
          throw new DateTimeException("Unable to obtain OffsetDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      OffsetDateTime2.now = function now(clockOrZone) {
        if (arguments.length === 0) {
          return OffsetDateTime2.now(Clock.systemDefaultZone());
        } else {
          requireNonNull(clockOrZone, "clockOrZone");
          if (clockOrZone instanceof ZoneId) {
            return OffsetDateTime2.now(Clock.system(clockOrZone));
          } else if (clockOrZone instanceof Clock) {
            var now2 = clockOrZone.instant();
            return OffsetDateTime2.ofInstant(now2, clockOrZone.zone().rules().offset(now2));
          } else {
            throw new IllegalArgumentException("clockOrZone must be an instance of ZoneId or Clock");
          }
        }
      };
      OffsetDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return OffsetDateTime2.ofDateTime.apply(this, arguments);
        } else if (arguments.length === 3) {
          return OffsetDateTime2.ofDateAndTime.apply(this, arguments);
        } else {
          return OffsetDateTime2.ofNumbers.apply(this, arguments);
        }
      };
      OffsetDateTime2.ofDateTime = function ofDateTime(dateTime, offset) {
        return new OffsetDateTime2(dateTime, offset);
      };
      OffsetDateTime2.ofDateAndTime = function ofDateAndTime(date, time, offset) {
        var dt = LocalDateTime.of(date, time);
        return new OffsetDateTime2(dt, offset);
      };
      OffsetDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
        return new OffsetDateTime2(dt, offset);
      };
      OffsetDateTime2.ofInstant = function ofInstant(instant, zone) {
        requireNonNull(instant, "instant");
        requireNonNull(zone, "zone");
        var rules = zone.rules();
        var offset = rules.offset(instant);
        var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
        return new OffsetDateTime2(ldt, offset);
      };
      OffsetDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, OffsetDateTime2.FROM);
      };
      function OffsetDateTime2(dateTime, offset) {
        var _this;
        _this = _Temporal.call(this) || this;
        requireNonNull(dateTime, "dateTime");
        requireInstance(dateTime, LocalDateTime, "dateTime");
        requireNonNull(offset, "offset");
        requireInstance(offset, ZoneOffset, "offset");
        _this._dateTime = dateTime;
        _this._offset = offset;
        return _this;
      }
      var _proto = OffsetDateTime2.prototype;
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
      };
      _proto.until = function until(endExclusive, unit) {
        var end = OffsetDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          end = end.withOffsetSameInstant(this._offset);
          return this._dateTime.until(end._dateTime, unit);
        }
        return unit.between(this, end);
      };
      _proto.atZoneSameInstant = function atZoneSameInstant(zone) {
        return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);
      };
      _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {
        return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.chronology()) {
          return IsoChronology.INSTANCE;
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
          return this.offset();
        } else if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        } else if (_query === TemporalQueries.zoneId()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.get = function get(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              throw new DateTimeException("Field too large for an int: " + field);
            case ChronoField.OFFSET_SECONDS:
              return this.offset().totalSeconds();
          }
          return this._dateTime.get(field);
        }
        return _Temporal.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.INSTANT_SECONDS:
              return this.toEpochSecond();
            case ChronoField.OFFSET_SECONDS:
              return this.offset().totalSeconds();
          }
          return this._dateTime.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.offset = function offset() {
        return this._offset;
      };
      _proto.year = function year() {
        return this._dateTime.year();
      };
      _proto.monthValue = function monthValue() {
        return this._dateTime.monthValue();
      };
      _proto.month = function month() {
        return this._dateTime.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._dateTime.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._dateTime.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._dateTime.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._dateTime.hour();
      };
      _proto.minute = function minute() {
        return this._dateTime.minute();
      };
      _proto.second = function second() {
        return this._dateTime.second();
      };
      _proto.nano = function nano() {
        return this._dateTime.nano();
      };
      _proto.toLocalDateTime = function toLocalDateTime() {
        return this._dateTime;
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._dateTime.toLocalDate();
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._dateTime.toLocalTime();
      };
      _proto.toOffsetTime = function toOffsetTime() {
        return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);
      };
      _proto.toZonedDateTime = function toZonedDateTime() {
        return ZonedDateTime.of(this._dateTime, this._offset);
      };
      _proto.toInstant = function toInstant() {
        return this._dateTime.toInstant(this._offset);
      };
      _proto.toEpochSecond = function toEpochSecond() {
        return this._dateTime.toEpochSecond(this._offset);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
            return field.range();
          }
          return this._dateTime.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster);
        if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
          return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);
        } else if (adjuster instanceof Instant) {
          return OffsetDateTime2.ofInstant(adjuster, this._offset);
        } else if (adjuster instanceof ZoneOffset) {
          return this._withDateTimeOffset(this._dateTime, adjuster);
        } else if (adjuster instanceof OffsetDateTime2) {
          return adjuster;
        }
        return adjuster.adjustInto(this);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field);
        if (field instanceof ChronoField) {
          var f = field;
          switch (f) {
            case ChronoField.INSTANT_SECONDS:
              return OffsetDateTime2.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);
            case ChronoField.OFFSET_SECONDS: {
              return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
            }
          }
          return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);
        }
        return field.adjustInto(this, newValue);
      };
      _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {
        if (this._dateTime === dateTime && this._offset.equals(offset)) {
          return this;
        }
        return new OffsetDateTime2(dateTime, offset);
      };
      _proto.withYear = function withYear(year) {
        return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);
      };
      _proto.withMonth = function withMonth(month) {
        return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);
      };
      _proto.withHour = function withHour(hour) {
        return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);
      };
      _proto.withMinute = function withMinute(minute) {
        return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);
      };
      _proto.withSecond = function withSecond(second) {
        return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);
      };
      _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
        requireNonNull(offset, "offset");
        return this._withDateTimeOffset(this._dateTime, offset);
      };
      _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
        requireNonNull(offset, "offset");
        if (offset.equals(this._offset)) {
          return this;
        }
        var difference = offset.totalSeconds() - this._offset.totalSeconds();
        var adjusted = this._dateTime.plusSeconds(difference);
        return new OffsetDateTime2(adjusted, offset);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);
      };
      _proto._plusAmount = function _plusAmount(amount) {
        requireNonNull(amount, "amount");
        return amount.addTo(this);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        if (unit instanceof ChronoUnit) {
          return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);
      };
      _proto.plusMonths = function plusMonths(months) {
        return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);
      };
      _proto.plusDays = function plusDays(days) {
        return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);
      };
      _proto._minusAmount = function _minusAmount(amount) {
        requireNonNull(amount);
        return amount.subtractFrom(this);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this.plus(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);
      };
      _proto.minusDays = function minusDays(days) {
        return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, OffsetDateTime2, "other");
        if (this.offset().equals(other.offset())) {
          return this.toLocalDateTime().compareTo(other.toLocalDateTime());
        }
        var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
        if (cmp === 0) {
          cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
          if (cmp === 0) {
            cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
      };
      _proto.isBefore = function isBefore(other) {
        requireNonNull(other, "other");
        var thisEpochSec = this.toEpochSecond();
        var otherEpochSec = other.toEpochSecond();
        return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
      };
      _proto.isEqual = function isEqual(other) {
        requireNonNull(other, "other");
        return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof OffsetDateTime2) {
          return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._dateTime.hashCode() ^ this._offset.hashCode();
      };
      _proto.toString = function toString() {
        return this._dateTime.toString() + this._offset.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return OffsetDateTime2;
    }(Temporal);
    DAYS_PER_CYCLE = 146097;
    DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);
    LocalDate = function(_ChronoLocalDate) {
      _inheritsLoose(LocalDate2, _ChronoLocalDate);
      LocalDate2.now = function now(clockOrZone) {
        var clock;
        if (clockOrZone == null) {
          clock = Clock.systemDefaultZone();
        } else if (clockOrZone instanceof ZoneId) {
          clock = Clock.system(clockOrZone);
        } else {
          clock = clockOrZone;
        }
        return LocalDate2.ofInstant(clock.instant(), clock.zone());
      };
      LocalDate2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        requireNonNull(instant, "instant");
        var offset = zone.rules().offset(instant);
        var epochSec = instant.epochSecond() + offset.totalSeconds();
        var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
        return LocalDate2.ofEpochDay(epochDay);
      };
      LocalDate2.of = function of(year, month, dayOfMonth) {
        return new LocalDate2(year, month, dayOfMonth);
      };
      LocalDate2.ofYearDay = function ofYearDay(year, dayOfYear) {
        ChronoField.YEAR.checkValidValue(year);
        var leap = IsoChronology.isLeapYear(year);
        if (dayOfYear === 366 && leap === false) {
          assert(false, "Invalid date 'DayOfYear 366' as '" + year + "' is not a leap year", DateTimeException);
        }
        var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
        var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;
        if (dayOfYear > monthEnd) {
          moy = moy.plus(1);
        }
        var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
        return new LocalDate2(year, moy.value(), dom);
      };
      LocalDate2.ofEpochDay = function ofEpochDay(epochDay) {
        if (epochDay === void 0) {
          epochDay = 0;
        }
        var adjust, adjustCycles, doyEst, yearEst, zeroDay;
        zeroDay = epochDay + DAYS_0000_TO_1970;
        zeroDay -= 60;
        adjust = 0;
        if (zeroDay < 0) {
          adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
          adjust = adjustCycles * 400;
          zeroDay += -adjustCycles * DAYS_PER_CYCLE;
        }
        yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
        doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
        if (doyEst < 0) {
          yearEst--;
          doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
        }
        yearEst += adjust;
        var marchDoy0 = doyEst;
        var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
        var month = (marchMonth0 + 2) % 12 + 1;
        var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
        yearEst += MathUtil.intDiv(marchMonth0, 10);
        var year = yearEst;
        return new LocalDate2(year, month, dom);
      };
      LocalDate2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var date = temporal.query(TemporalQueries.localDate());
        if (date == null) {
          throw new DateTimeException("Unable to obtain LocalDate from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return date;
      };
      LocalDate2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_DATE;
        }
        assert(formatter != null, "formatter", NullPointerException);
        return formatter.parse(text, LocalDate2.FROM);
      };
      LocalDate2._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
        switch (month) {
          case 2:
            day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
            break;
          case 4:
          case 6:
          case 9:
          case 11:
            day = Math.min(day, 30);
            break;
        }
        return LocalDate2.of(year, month, day);
      };
      function LocalDate2(year, month, dayOfMonth) {
        var _this;
        _this = _ChronoLocalDate.call(this) || this;
        requireNonNull(year, "year");
        requireNonNull(month, "month");
        requireNonNull(dayOfMonth, "dayOfMonth");
        if (month instanceof Month) {
          month = month.value();
        }
        _this._year = MathUtil.safeToInt(year);
        _this._month = MathUtil.safeToInt(month);
        _this._day = MathUtil.safeToInt(dayOfMonth);
        LocalDate2._validate(_this._year, _this._month, _this._day);
        return _this;
      }
      LocalDate2._validate = function _validate(year, month, dayOfMonth) {
        var dom;
        ChronoField.YEAR.checkValidValue(year);
        ChronoField.MONTH_OF_YEAR.checkValidValue(month);
        ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
        if (dayOfMonth > 28) {
          dom = 31;
          switch (month) {
            case 2:
              dom = IsoChronology.isLeapYear(year) ? 29 : 28;
              break;
            case 4:
            case 6:
            case 9:
            case 11:
              dom = 30;
          }
          if (dayOfMonth > dom) {
            if (dayOfMonth === 29) {
              assert(false, "Invalid date 'February 29' as '" + year + "' is not a leap year", DateTimeException);
            } else {
              assert(false, "Invalid date '" + year + "' '" + month + "' '" + dayOfMonth + "'", DateTimeException);
            }
          }
        }
      };
      var _proto = LocalDate2.prototype;
      _proto.isSupported = function isSupported(field) {
        return _ChronoLocalDate.prototype.isSupported.call(this, field);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          if (field.isDateBased()) {
            switch (field) {
              case ChronoField.DAY_OF_MONTH:
                return ValueRange.of(1, this.lengthOfMonth());
              case ChronoField.DAY_OF_YEAR:
                return ValueRange.of(1, this.lengthOfYear());
              case ChronoField.ALIGNED_WEEK_OF_MONTH:
                return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);
              case ChronoField.YEAR_OF_ERA:
                return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
            }
            return field.range();
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        assert(field != null, "", NullPointerException);
        if (field instanceof ChronoField) {
          return this._get0(field);
        }
        return field.getFrom(this);
      };
      _proto._get0 = function _get0(field) {
        switch (field) {
          case ChronoField.DAY_OF_WEEK:
            return this.dayOfWeek().value();
          case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
            return MathUtil.intMod(this._day - 1, 7) + 1;
          case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
            return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;
          case ChronoField.DAY_OF_MONTH:
            return this._day;
          case ChronoField.DAY_OF_YEAR:
            return this.dayOfYear();
          case ChronoField.EPOCH_DAY:
            return this.toEpochDay();
          case ChronoField.ALIGNED_WEEK_OF_MONTH:
            return MathUtil.intDiv(this._day - 1, 7) + 1;
          case ChronoField.ALIGNED_WEEK_OF_YEAR:
            return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;
          case ChronoField.MONTH_OF_YEAR:
            return this._month;
          case ChronoField.PROLEPTIC_MONTH:
            return this._prolepticMonth();
          case ChronoField.YEAR_OF_ERA:
            return this._year >= 1 ? this._year : 1 - this._year;
          case ChronoField.YEAR:
            return this._year;
          case ChronoField.ERA:
            return this._year >= 1 ? 1 : 0;
        }
        throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
      };
      _proto._prolepticMonth = function _prolepticMonth() {
        return this._year * 12 + (this._month - 1);
      };
      _proto.chronology = function chronology() {
        return IsoChronology.INSTANCE;
      };
      _proto.year = function year() {
        return this._year;
      };
      _proto.monthValue = function monthValue() {
        return this._month;
      };
      _proto.month = function month() {
        return Month.of(this._month);
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._day;
      };
      _proto.dayOfYear = function dayOfYear() {
        return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
      };
      _proto.dayOfWeek = function dayOfWeek() {
        var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
        return DayOfWeek.of(dow0 + 1);
      };
      _proto.isLeapYear = function isLeapYear() {
        return IsoChronology.isLeapYear(this._year);
      };
      _proto.lengthOfMonth = function lengthOfMonth() {
        switch (this._month) {
          case 2:
            return this.isLeapYear() ? 29 : 28;
          case 4:
          case 6:
          case 9:
          case 11:
            return 30;
          default:
            return 31;
        }
      };
      _proto.lengthOfYear = function lengthOfYear() {
        return this.isLeapYear() ? 366 : 365;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalDate2) {
          return adjuster;
        }
        return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        assert(field != null, "field", NullPointerException);
        if (field instanceof ChronoField) {
          var f = field;
          f.checkValidValue(newValue);
          switch (f) {
            case ChronoField.DAY_OF_WEEK:
              return this.plusDays(newValue - this.dayOfWeek().value());
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
              return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));
            case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
              return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
            case ChronoField.DAY_OF_MONTH:
              return this.withDayOfMonth(newValue);
            case ChronoField.DAY_OF_YEAR:
              return this.withDayOfYear(newValue);
            case ChronoField.EPOCH_DAY:
              return LocalDate2.ofEpochDay(newValue);
            case ChronoField.ALIGNED_WEEK_OF_MONTH:
              return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));
            case ChronoField.ALIGNED_WEEK_OF_YEAR:
              return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));
            case ChronoField.MONTH_OF_YEAR:
              return this.withMonth(newValue);
            case ChronoField.PROLEPTIC_MONTH:
              return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
            case ChronoField.YEAR_OF_ERA:
              return this.withYear(this._year >= 1 ? newValue : 1 - newValue);
            case ChronoField.YEAR:
              return this.withYear(newValue);
            case ChronoField.ERA:
              return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        if (this._year === year) {
          return this;
        }
        ChronoField.YEAR.checkValidValue(year);
        return LocalDate2._resolvePreviousValid(year, this._month, this._day);
      };
      _proto.withMonth = function withMonth(month) {
        var m = month instanceof Month ? month.value() : month;
        if (this._month === m) {
          return this;
        }
        ChronoField.MONTH_OF_YEAR.checkValidValue(m);
        return LocalDate2._resolvePreviousValid(this._year, m, this._day);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        if (this._day === dayOfMonth) {
          return this;
        }
        return LocalDate2.of(this._year, this._month, dayOfMonth);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        if (this.dayOfYear() === dayOfYear) {
          return this;
        }
        return LocalDate2.ofYearDay(this._year, dayOfYear);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.DAYS:
              return this.plusDays(amountToAdd);
            case ChronoUnit.WEEKS:
              return this.plusWeeks(amountToAdd);
            case ChronoUnit.MONTHS:
              return this.plusMonths(amountToAdd);
            case ChronoUnit.YEARS:
              return this.plusYears(amountToAdd);
            case ChronoUnit.DECADES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
            case ChronoUnit.CENTURIES:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
            case ChronoUnit.MILLENNIA:
              return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1e3));
            case ChronoUnit.ERAS:
              return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(yearsToAdd) {
        if (yearsToAdd === 0) {
          return this;
        }
        var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
        return LocalDate2._resolvePreviousValid(newYear, this._month, this._day);
      };
      _proto.plusMonths = function plusMonths(monthsToAdd) {
        if (monthsToAdd === 0) {
          return this;
        }
        var monthCount = this._year * 12 + (this._month - 1);
        var calcMonths = monthCount + monthsToAdd;
        var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
        var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
        return LocalDate2._resolvePreviousValid(newYear, newMonth, this._day);
      };
      _proto.plusWeeks = function plusWeeks(weeksToAdd) {
        return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
      };
      _proto.plusDays = function plusDays(daysToAdd) {
        if (daysToAdd === 0) {
          return this;
        }
        var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
        return LocalDate2.ofEpochDay(mjDay);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(amountToSubtract, "amountToSubtract");
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(yearsToSubtract) {
        return this.plusYears(yearsToSubtract * -1);
      };
      _proto.minusMonths = function minusMonths(monthsToSubtract) {
        return this.plusMonths(monthsToSubtract * -1);
      };
      _proto.minusWeeks = function minusWeeks(weeksToSubtract) {
        return this.plusWeeks(weeksToSubtract * -1);
      };
      _proto.minusDays = function minusDays(daysToSubtract) {
        return this.plusDays(daysToSubtract * -1);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.localDate()) {
          return this;
        }
        return _ChronoLocalDate.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
      };
      _proto.until = function until(p1, p2) {
        if (arguments.length < 2) {
          return this.until1(p1);
        } else {
          return this.until2(p1, p2);
        }
      };
      _proto.until2 = function until2(endExclusive, unit) {
        var end = LocalDate2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.DAYS:
              return this.daysUntil(end);
            case ChronoUnit.WEEKS:
              return MathUtil.intDiv(this.daysUntil(end), 7);
            case ChronoUnit.MONTHS:
              return this._monthsUntil(end);
            case ChronoUnit.YEARS:
              return MathUtil.intDiv(this._monthsUntil(end), 12);
            case ChronoUnit.DECADES:
              return MathUtil.intDiv(this._monthsUntil(end), 120);
            case ChronoUnit.CENTURIES:
              return MathUtil.intDiv(this._monthsUntil(end), 1200);
            case ChronoUnit.MILLENNIA:
              return MathUtil.intDiv(this._monthsUntil(end), 12e3);
            case ChronoUnit.ERAS:
              return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.daysUntil = function daysUntil(end) {
        return end.toEpochDay() - this.toEpochDay();
      };
      _proto._monthsUntil = function _monthsUntil(end) {
        var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
        var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();
        return MathUtil.intDiv(packed2 - packed1, 32);
      };
      _proto.until1 = function until1(endDate) {
        var end = LocalDate2.from(endDate);
        var totalMonths = end._prolepticMonth() - this._prolepticMonth();
        var days = end._day - this._day;
        if (totalMonths > 0 && days < 0) {
          totalMonths--;
          var calcDate = this.plusMonths(totalMonths);
          days = end.toEpochDay() - calcDate.toEpochDay();
        } else if (totalMonths < 0 && days > 0) {
          totalMonths++;
          days -= end.lengthOfMonth();
        }
        var years = MathUtil.intDiv(totalMonths, 12);
        var months = MathUtil.intMod(totalMonths, 12);
        return Period.of(years, months, days);
      };
      _proto.atTime = function atTime() {
        if (arguments.length === 1) {
          return this.atTime1.apply(this, arguments);
        } else {
          return this.atTime4.apply(this, arguments);
        }
      };
      _proto.atTime1 = function atTime1(time) {
        requireNonNull(time, "time");
        if (time instanceof LocalTime) {
          return LocalDateTime.of(this, time);
        } else if (time instanceof OffsetTime) {
          return this._atTimeOffsetTime(time);
        } else {
          throw new IllegalArgumentException("time must be an instance of LocalTime or OffsetTime" + (time && time.constructor && time.constructor.name ? ", but is " + time.constructor.name : ""));
        }
      };
      _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
      };
      _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {
        return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());
      };
      _proto.atStartOfDay = function atStartOfDay(zone) {
        if (zone != null) {
          return this._atStartOfDayWithZone(zone);
        } else {
          return LocalDateTime.of(this, LocalTime.MIDNIGHT);
        }
      };
      _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {
        requireNonNull(zone, "zone");
        var ldt = this.atTime(LocalTime.MIDNIGHT);
        if (zone instanceof ZoneOffset === false) {
          var trans = zone.rules().transition(ldt);
          if (trans != null && trans.isGap()) {
            ldt = trans.dateTimeAfter();
          }
        }
        return ZonedDateTime.of(ldt, zone);
      };
      _proto.toEpochDay = function toEpochDay() {
        var y = this._year;
        var m = this._month;
        var total = 0;
        total += 365 * y;
        if (y >= 0) {
          total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
        } else {
          total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
        }
        total += MathUtil.intDiv(367 * m - 362, 12);
        total += this.dayOfMonth() - 1;
        if (m > 2) {
          total--;
          if (!IsoChronology.isLeapYear(y)) {
            total--;
          }
        }
        return total - DAYS_0000_TO_1970;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalDate2, "other");
        return this._compareTo0(other);
      };
      _proto._compareTo0 = function _compareTo0(otherDate) {
        var cmp = this._year - otherDate._year;
        if (cmp === 0) {
          cmp = this._month - otherDate._month;
          if (cmp === 0) {
            cmp = this._day - otherDate._day;
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.isEqual = function isEqual(other) {
        return this.compareTo(other) === 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalDate2) {
          return this._compareTo0(other) === 0;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        var yearValue = this._year;
        var monthValue = this._month;
        var dayValue = this._day;
        return MathUtil.hash(yearValue & 4294965248 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
      };
      _proto.toString = function toString() {
        var dayString, monthString, yearString;
        var yearValue = this._year;
        var monthValue = this._month;
        var dayValue = this._day;
        var absYear = Math.abs(yearValue);
        if (absYear < 1e3) {
          if (yearValue < 0) {
            yearString = "-" + ("" + (yearValue - 1e4)).slice(-4);
          } else {
            yearString = ("" + (yearValue + 1e4)).slice(-4);
          }
        } else {
          if (yearValue > 9999) {
            yearString = "+" + yearValue;
          } else {
            yearString = "" + yearValue;
          }
        }
        if (monthValue < 10) {
          monthString = "-0" + monthValue;
        } else {
          monthString = "-" + monthValue;
        }
        if (dayValue < 10) {
          dayString = "-0" + dayValue;
        } else {
          dayString = "-" + dayValue;
        }
        return yearString + monthString + dayString;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        requireInstance(formatter, DateTimeFormatter, "formatter");
        return _ChronoLocalDate.prototype.format.call(this, formatter);
      };
      return LocalDate2;
    }(ChronoLocalDate);
    ChronoLocalDateTime = function(_Temporal) {
      _inheritsLoose(ChronoLocalDateTime2, _Temporal);
      function ChronoLocalDateTime2() {
        return _Temporal.apply(this, arguments) || this;
      }
      var _proto = ChronoLocalDateTime2.prototype;
      _proto.chronology = function chronology() {
        return this.toLocalDate().chronology();
      };
      _proto.query = function query(_query) {
        if (_query === TemporalQueries.chronology()) {
          return this.chronology();
        } else if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.localDate()) {
          return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
        } else if (_query === TemporalQueries.localTime()) {
          return this.toLocalTime();
        } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _Temporal.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
      };
      _proto.toInstant = function toInstant(offset) {
        requireInstance(offset, ZoneOffset, "zoneId");
        return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
      };
      _proto.toEpochSecond = function toEpochSecond(offset) {
        requireNonNull(offset, "offset");
        var epochDay = this.toLocalDate().toEpochDay();
        var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
        secs -= offset.totalSeconds();
        return MathUtil.safeToInt(secs);
      };
      return ChronoLocalDateTime2;
    }(Temporal);
    LocalDateTime = function(_ChronoLocalDateTime) {
      _inheritsLoose(LocalDateTime2, _ChronoLocalDateTime);
      LocalDateTime2.now = function now(clockOrZone) {
        if (clockOrZone == null) {
          return LocalDateTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return LocalDateTime2._now(clockOrZone);
        } else {
          return LocalDateTime2._now(Clock.system(clockOrZone));
        }
      };
      LocalDateTime2._now = function _now(clock) {
        requireNonNull(clock, "clock");
        return LocalDateTime2.ofInstant(clock.instant(), clock.zone());
      };
      LocalDateTime2._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
        var localSecond = MathUtil.floorDiv(epochMilli, 1e3) + offset.totalSeconds();
        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
        var nanoOfSecond = MathUtil.floorMod(epochMilli, 1e3) * 1e6;
        var date = LocalDate.ofEpochDay(localEpochDay);
        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.of = function of() {
        if (arguments.length <= 2) {
          return LocalDateTime2.ofDateAndTime.apply(this, arguments);
        } else {
          return LocalDateTime2.ofNumbers.apply(this, arguments);
        }
      };
      LocalDateTime2.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        var date = LocalDate.of(year, month, dayOfMonth);
        var time = LocalTime.of(hour, minute, second, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.ofDateAndTime = function ofDateAndTime(date, time) {
        requireNonNull(date, "date");
        requireNonNull(time, "time");
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        requireNonNull(instant, "instant");
        requireInstance(instant, Instant, "instant");
        requireNonNull(zone, "zone");
        var offset = zone.rules().offset(instant);
        return LocalDateTime2.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
      };
      LocalDateTime2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {
        if (epochSecond === void 0) {
          epochSecond = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
          offset = nanoOfSecond;
          nanoOfSecond = 0;
        }
        requireNonNull(offset, "offset");
        var localSecond = epochSecond + offset.totalSeconds();
        var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
        var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
        var date = LocalDate.ofEpochDay(localEpochDay);
        var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
        return new LocalDateTime2(date, time);
      };
      LocalDateTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        if (temporal instanceof LocalDateTime2) {
          return temporal;
        } else if (temporal instanceof ZonedDateTime) {
          return temporal.toLocalDateTime();
        }
        try {
          var date = LocalDate.from(temporal);
          var time = LocalTime.from(temporal);
          return new LocalDateTime2(date, time);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain LocalDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
      };
      LocalDateTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, LocalDateTime2.FROM);
      };
      function LocalDateTime2(date, time) {
        var _this;
        _this = _ChronoLocalDateTime.call(this) || this;
        requireInstance(date, LocalDate, "date");
        requireInstance(time, LocalTime, "time");
        _this._date = date;
        _this._time = time;
        return _this;
      }
      var _proto = LocalDateTime2.prototype;
      _proto._withDateTime = function _withDateTime(newDate, newTime) {
        if (this._date.equals(newDate) && this._time.equals(newTime)) {
          return this;
        }
        return new LocalDateTime2(newDate, newTime);
      };
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
        }
        return field.rangeRefinedBy(this);
      };
      _proto.get = function get(field) {
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
        }
        return _ChronoLocalDateTime.prototype.get.call(this, field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
        }
        return field.getFrom(this);
      };
      _proto.year = function year() {
        return this._date.year();
      };
      _proto.monthValue = function monthValue() {
        return this._date.monthValue();
      };
      _proto.month = function month() {
        return this._date.month();
      };
      _proto.dayOfMonth = function dayOfMonth() {
        return this._date.dayOfMonth();
      };
      _proto.dayOfYear = function dayOfYear() {
        return this._date.dayOfYear();
      };
      _proto.dayOfWeek = function dayOfWeek() {
        return this._date.dayOfWeek();
      };
      _proto.hour = function hour() {
        return this._time.hour();
      };
      _proto.minute = function minute() {
        return this._time.minute();
      };
      _proto.second = function second() {
        return this._time.second();
      };
      _proto.nano = function nano() {
        return this._time.nano();
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalDate) {
          return this._withDateTime(adjuster, this._time);
        } else if (adjuster instanceof LocalTime) {
          return this._withDateTime(this._date, adjuster);
        } else if (adjuster instanceof LocalDateTime2) {
          return adjuster;
        }
        return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          if (field.isTimeBased()) {
            return this._withDateTime(this._date, this._time.with(field, newValue));
          } else {
            return this._withDateTime(this._date.with(field, newValue), this._time);
          }
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withYear = function withYear(year) {
        return this._withDateTime(this._date.withYear(year), this._time);
      };
      _proto.withMonth = function withMonth(month) {
        return this._withDateTime(this._date.withMonth(month), this._time);
      };
      _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
        return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
      };
      _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
        return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
      };
      _proto.withHour = function withHour(hour) {
        var newTime = this._time.withHour(hour);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withMinute = function withMinute(minute) {
        var newTime = this._time.withMinute(minute);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withSecond = function withSecond(second) {
        var newTime = this._time.withSecond(second);
        return this._withDateTime(this._date, newTime);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        var newTime = this._time.withNano(nanoOfSecond);
        return this._withDateTime(this._date, newTime);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        return this._withDateTime(this._date, this._time.truncatedTo(unit));
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1e6);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusMinutes(amountToAdd);
            case ChronoUnit.HOURS:
              return this.plusHours(amountToAdd);
            case ChronoUnit.HALF_DAYS:
              return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);
          }
          return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusYears = function plusYears(years) {
        var newDate = this._date.plusYears(years);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusMonths = function plusMonths(months) {
        var newDate = this._date.plusMonths(months);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusWeeks = function plusWeeks(weeks) {
        var newDate = this._date.plusWeeks(weeks);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusDays = function plusDays(days) {
        var newDate = this._date.plusDays(days);
        return this._withDateTime(newDate, this._time);
      };
      _proto.plusHours = function plusHours(hours) {
        return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
      };
      _proto.plusMinutes = function plusMinutes(minutes) {
        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
      };
      _proto.plusSeconds = function plusSeconds(seconds) {
        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
      };
      _proto.plusNanos = function plusNanos(nanos) {
        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusYears = function minusYears(years) {
        return this.plusYears(-1 * years);
      };
      _proto.minusMonths = function minusMonths(months) {
        return this.plusMonths(-1 * months);
      };
      _proto.minusWeeks = function minusWeeks(weeks) {
        return this.plusWeeks(-1 * weeks);
      };
      _proto.minusDays = function minusDays(days) {
        return this.plusDays(-1 * days);
      };
      _proto.minusHours = function minusHours(hours) {
        return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
      };
      _proto.minusMinutes = function minusMinutes(minutes) {
        return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
      };
      _proto.minusSeconds = function minusSeconds(seconds) {
        return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
      };
      _proto.minusNanos = function minusNanos(nanos) {
        return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
      };
      _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {
        if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {
          return this._withDateTime(newDate, this._time);
        }
        var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
        totDays *= sign;
        var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;
        var curNoD = this._time.toNanoOfDay();
        totNanos = totNanos * sign + curNoD;
        totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
        var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
        var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
        return this._withDateTime(newDate.plusDays(totDays), newTime);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.localDate()) {
          return this.toLocalDate();
        }
        return _ChronoLocalDateTime.prototype.query.call(this, _query);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = LocalDateTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          if (unit.isTimeBased()) {
            var daysUntil = this._date.daysUntil(end._date);
            var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();
            if (daysUntil > 0 && timeUntil < 0) {
              daysUntil--;
              timeUntil += LocalTime.NANOS_PER_DAY;
            } else if (daysUntil < 0 && timeUntil > 0) {
              daysUntil++;
              timeUntil -= LocalTime.NANOS_PER_DAY;
            }
            var amount = daysUntil;
            switch (unit) {
              case ChronoUnit.NANOS:
                amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
                return MathUtil.safeAdd(amount, timeUntil);
              case ChronoUnit.MICROS:
                amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e3));
              case ChronoUnit.MILLIS:
                amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1e6));
              case ChronoUnit.SECONDS:
                amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));
              case ChronoUnit.MINUTES:
                amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));
              case ChronoUnit.HOURS:
                amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));
              case ChronoUnit.HALF_DAYS:
                amount = MathUtil.safeMultiply(amount, 2);
                return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
            }
            throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
          }
          var endDate = end._date;
          var endTime = end._time;
          if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
            endDate = endDate.minusDays(1);
          } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
            endDate = endDate.plusDays(1);
          }
          return this._date.until(endDate, unit);
        }
        return unit.between(this, end);
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetDateTime.of(this, offset);
      };
      _proto.atZone = function atZone(zone) {
        return ZonedDateTime.of(this, zone);
      };
      _proto.toLocalDate = function toLocalDate() {
        return this._date;
      };
      _proto.toLocalTime = function toLocalTime() {
        return this._time;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalDateTime2, "other");
        return this._compareTo0(other);
      };
      _proto._compareTo0 = function _compareTo0(other) {
        var cmp = this._date.compareTo(other.toLocalDate());
        if (cmp === 0) {
          cmp = this._time.compareTo(other.toLocalTime());
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.isEqual = function isEqual(other) {
        return this.compareTo(other) === 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalDateTime2) {
          return this._date.equals(other._date) && this._time.equals(other._time);
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._date.hashCode() ^ this._time.hashCode();
      };
      _proto.toString = function toString() {
        return this._date.toString() + "T" + this._time.toString();
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return LocalDateTime2;
    }(ChronoLocalDateTime);
    LocalTime = function(_Temporal) {
      _inheritsLoose(LocalTime2, _Temporal);
      LocalTime2.now = function now(clockOrZone) {
        if (clockOrZone == null) {
          return LocalTime2._now(Clock.systemDefaultZone());
        } else if (clockOrZone instanceof Clock) {
          return LocalTime2._now(clockOrZone);
        } else {
          return LocalTime2._now(Clock.system(clockOrZone));
        }
      };
      LocalTime2._now = function _now(clock) {
        if (clock === void 0) {
          clock = Clock.systemDefaultZone();
        }
        requireNonNull(clock, "clock");
        return LocalTime2.ofInstant(clock.instant(), clock.zone());
      };
      LocalTime2.ofInstant = function ofInstant(instant, zone) {
        if (zone === void 0) {
          zone = ZoneId.systemDefault();
        }
        var offset = zone.rules().offset(instant);
        var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime2.SECONDS_PER_DAY);
        secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime2.SECONDS_PER_DAY);
        if (secsOfDay < 0) {
          secsOfDay += LocalTime2.SECONDS_PER_DAY;
        }
        return LocalTime2.ofSecondOfDay(secsOfDay, instant.nano());
      };
      LocalTime2.of = function of(hour, minute, second, nanoOfSecond) {
        return new LocalTime2(hour, minute, second, nanoOfSecond);
      };
      LocalTime2.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {
        if (secondOfDay === void 0) {
          secondOfDay = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
        var hours = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_HOUR);
        secondOfDay -= hours * LocalTime2.SECONDS_PER_HOUR;
        var minutes = MathUtil.intDiv(secondOfDay, LocalTime2.SECONDS_PER_MINUTE);
        secondOfDay -= minutes * LocalTime2.SECONDS_PER_MINUTE;
        return new LocalTime2(hours, minutes, secondOfDay, nanoOfSecond);
      };
      LocalTime2.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {
        if (nanoOfDay === void 0) {
          nanoOfDay = 0;
        }
        ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
        var hours = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_HOUR);
        nanoOfDay -= hours * LocalTime2.NANOS_PER_HOUR;
        var minutes = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_MINUTE);
        nanoOfDay -= minutes * LocalTime2.NANOS_PER_MINUTE;
        var seconds = MathUtil.intDiv(nanoOfDay, LocalTime2.NANOS_PER_SECOND);
        nanoOfDay -= seconds * LocalTime2.NANOS_PER_SECOND;
        return new LocalTime2(hours, minutes, seconds, nanoOfDay);
      };
      LocalTime2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var time = temporal.query(TemporalQueries.localTime());
        if (time == null) {
          throw new DateTimeException("Unable to obtain LocalTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return time;
      };
      LocalTime2.parse = function parse2(text, formatter) {
        if (formatter === void 0) {
          formatter = DateTimeFormatter.ISO_LOCAL_TIME;
        }
        requireNonNull(formatter, "formatter");
        return formatter.parse(text, LocalTime2.FROM);
      };
      function LocalTime2(hour, minute, second, nanoOfSecond) {
        var _this;
        if (hour === void 0) {
          hour = 0;
        }
        if (minute === void 0) {
          minute = 0;
        }
        if (second === void 0) {
          second = 0;
        }
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        _this = _Temporal.call(this) || this;
        var _hour = MathUtil.safeToInt(hour);
        var _minute = MathUtil.safeToInt(minute);
        var _second = MathUtil.safeToInt(second);
        var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);
        LocalTime2._validate(_hour, _minute, _second, _nanoOfSecond);
        if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {
          if (!LocalTime2.HOURS[_hour]) {
            _this._hour = _hour;
            _this._minute = _minute;
            _this._second = _second;
            _this._nano = _nanoOfSecond;
            LocalTime2.HOURS[_hour] = _assertThisInitialized(_this);
          }
          return LocalTime2.HOURS[_hour] || _assertThisInitialized(_this);
        }
        _this._hour = _hour;
        _this._minute = _minute;
        _this._second = _second;
        _this._nano = _nanoOfSecond;
        return _this;
      }
      LocalTime2._validate = function _validate(hour, minute, second, nanoOfSecond) {
        ChronoField.HOUR_OF_DAY.checkValidValue(hour);
        ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
        ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
        ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
      };
      var _proto = LocalTime2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit.isTimeBased();
        } else if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased();
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        requireNonNull(field);
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          return this._get0(field);
        }
        return field.getFrom(this);
      };
      _proto._get0 = function _get0(field) {
        switch (field) {
          case ChronoField.NANO_OF_SECOND:
            return this._nano;
          case ChronoField.NANO_OF_DAY:
            return this.toNanoOfDay();
          case ChronoField.MICRO_OF_SECOND:
            return MathUtil.intDiv(this._nano, 1e3);
          case ChronoField.MICRO_OF_DAY:
            return MathUtil.intDiv(this.toNanoOfDay(), 1e3);
          case ChronoField.MILLI_OF_SECOND:
            return MathUtil.intDiv(this._nano, 1e6);
          case ChronoField.MILLI_OF_DAY:
            return MathUtil.intDiv(this.toNanoOfDay(), 1e6);
          case ChronoField.SECOND_OF_MINUTE:
            return this._second;
          case ChronoField.SECOND_OF_DAY:
            return this.toSecondOfDay();
          case ChronoField.MINUTE_OF_HOUR:
            return this._minute;
          case ChronoField.MINUTE_OF_DAY:
            return this._hour * 60 + this._minute;
          case ChronoField.HOUR_OF_AMPM:
            return MathUtil.intMod(this._hour, 12);
          case ChronoField.CLOCK_HOUR_OF_AMPM: {
            var ham = MathUtil.intMod(this._hour, 12);
            return ham % 12 === 0 ? 12 : ham;
          }
          case ChronoField.HOUR_OF_DAY:
            return this._hour;
          case ChronoField.CLOCK_HOUR_OF_DAY:
            return this._hour === 0 ? 24 : this._hour;
          case ChronoField.AMPM_OF_DAY:
            return MathUtil.intDiv(this._hour, 12);
        }
        throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
      };
      _proto.hour = function hour() {
        return this._hour;
      };
      _proto.minute = function minute() {
        return this._minute;
      };
      _proto.second = function second() {
        return this._second;
      };
      _proto.nano = function nano() {
        return this._nano;
      };
      _proto._withAdjuster = function _withAdjuster(adjuster) {
        requireNonNull(adjuster, "adjuster");
        if (adjuster instanceof LocalTime2) {
          return adjuster;
        }
        return _Temporal.prototype._withAdjuster.call(this, adjuster);
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        requireInstance(field, TemporalField, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.NANO_OF_SECOND:
              return this.withNano(newValue);
            case ChronoField.NANO_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue);
            case ChronoField.MICRO_OF_SECOND:
              return this.withNano(newValue * 1e3);
            case ChronoField.MICRO_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue * 1e3);
            case ChronoField.MILLI_OF_SECOND:
              return this.withNano(newValue * 1e6);
            case ChronoField.MILLI_OF_DAY:
              return LocalTime2.ofNanoOfDay(newValue * 1e6);
            case ChronoField.SECOND_OF_MINUTE:
              return this.withSecond(newValue);
            case ChronoField.SECOND_OF_DAY:
              return this.plusSeconds(newValue - this.toSecondOfDay());
            case ChronoField.MINUTE_OF_HOUR:
              return this.withMinute(newValue);
            case ChronoField.MINUTE_OF_DAY:
              return this.plusMinutes(newValue - (this._hour * 60 + this._minute));
            case ChronoField.HOUR_OF_AMPM:
              return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));
            case ChronoField.CLOCK_HOUR_OF_AMPM:
              return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));
            case ChronoField.HOUR_OF_DAY:
              return this.withHour(newValue);
            case ChronoField.CLOCK_HOUR_OF_DAY:
              return this.withHour(newValue === 24 ? 0 : newValue);
            case ChronoField.AMPM_OF_DAY:
              return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.withHour = function withHour(hour) {
        if (hour === void 0) {
          hour = 0;
        }
        if (this._hour === hour) {
          return this;
        }
        return new LocalTime2(hour, this._minute, this._second, this._nano);
      };
      _proto.withMinute = function withMinute(minute) {
        if (minute === void 0) {
          minute = 0;
        }
        if (this._minute === minute) {
          return this;
        }
        return new LocalTime2(this._hour, minute, this._second, this._nano);
      };
      _proto.withSecond = function withSecond(second) {
        if (second === void 0) {
          second = 0;
        }
        if (this._second === second) {
          return this;
        }
        return new LocalTime2(this._hour, this._minute, second, this._nano);
      };
      _proto.withNano = function withNano(nanoOfSecond) {
        if (nanoOfSecond === void 0) {
          nanoOfSecond = 0;
        }
        if (this._nano === nanoOfSecond) {
          return this;
        }
        return new LocalTime2(this._hour, this._minute, this._second, nanoOfSecond);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.NANOS) {
          return this;
        }
        var unitDur = unit.duration();
        if (unitDur.seconds() > LocalTime2.SECONDS_PER_DAY) {
          throw new DateTimeException("Unit is too large to be used for truncation");
        }
        var dur = unitDur.toNanos();
        if (MathUtil.intMod(LocalTime2.NANOS_PER_DAY, dur) !== 0) {
          throw new DateTimeException("Unit must divide into a standard day without remainder");
        }
        var nod = this.toNanoOfDay();
        return LocalTime2.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(unit, "unit");
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MICROS_PER_DAY) * 1e3);
            case ChronoUnit.MILLIS:
              return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime2.MILLIS_PER_DAY) * 1e6);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusMinutes(amountToAdd);
            case ChronoUnit.HOURS:
              return this.plusHours(amountToAdd);
            case ChronoUnit.HALF_DAYS:
              return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusHours = function plusHours(hoursToAdd) {
        if (hoursToAdd === 0) {
          return this;
        }
        var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime2.HOURS_PER_DAY) + this._hour + LocalTime2.HOURS_PER_DAY, LocalTime2.HOURS_PER_DAY);
        return new LocalTime2(newHour, this._minute, this._second, this._nano);
      };
      _proto.plusMinutes = function plusMinutes(minutesToAdd) {
        if (minutesToAdd === 0) {
          return this;
        }
        var mofd = this._hour * LocalTime2.MINUTES_PER_HOUR + this._minute;
        var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime2.MINUTES_PER_DAY) + mofd + LocalTime2.MINUTES_PER_DAY, LocalTime2.MINUTES_PER_DAY);
        if (mofd === newMofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newMofd, LocalTime2.MINUTES_PER_HOUR);
        var newMinute = MathUtil.intMod(newMofd, LocalTime2.MINUTES_PER_HOUR);
        return new LocalTime2(newHour, newMinute, this._second, this._nano);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        if (secondsToAdd === 0) {
          return this;
        }
        var sofd = this._hour * LocalTime2.SECONDS_PER_HOUR + this._minute * LocalTime2.SECONDS_PER_MINUTE + this._second;
        var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime2.SECONDS_PER_DAY) + sofd + LocalTime2.SECONDS_PER_DAY, LocalTime2.SECONDS_PER_DAY);
        if (sofd === newSofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_HOUR);
        var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime2.SECONDS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
        var newSecond = MathUtil.intMod(newSofd, LocalTime2.SECONDS_PER_MINUTE);
        return new LocalTime2(newHour, newMinute, newSecond, this._nano);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        if (nanosToAdd === 0) {
          return this;
        }
        var nofd = this.toNanoOfDay();
        var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime2.NANOS_PER_DAY) + nofd + LocalTime2.NANOS_PER_DAY, LocalTime2.NANOS_PER_DAY);
        if (nofd === newNofd) {
          return this;
        }
        var newHour = MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_HOUR);
        var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_MINUTE), LocalTime2.MINUTES_PER_HOUR);
        var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime2.NANOS_PER_SECOND), LocalTime2.SECONDS_PER_MINUTE);
        var newNano = MathUtil.intMod(newNofd, LocalTime2.NANOS_PER_SECOND);
        return new LocalTime2(newHour, newMinute, newSecond, newNano);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        requireNonNull(unit, "unit");
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusHours = function minusHours(hoursToSubtract) {
        return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime2.HOURS_PER_DAY));
      };
      _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
        return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime2.MINUTES_PER_DAY));
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime2.SECONDS_PER_DAY));
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime2.NANOS_PER_DAY));
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        } else if (_query === TemporalQueries.localTime()) {
          return this;
        }
        if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        return temporal.with(LocalTime2.NANO_OF_DAY, this.toNanoOfDay());
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = LocalTime2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();
          switch (unit) {
            case ChronoUnit.NANOS:
              return nanosUntil;
            case ChronoUnit.MICROS:
              return MathUtil.intDiv(nanosUntil, 1e3);
            case ChronoUnit.MILLIS:
              return MathUtil.intDiv(nanosUntil, 1e6);
            case ChronoUnit.SECONDS:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_SECOND);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(nanosUntil, LocalTime2.NANOS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(nanosUntil, 12 * LocalTime2.NANOS_PER_HOUR);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto.atDate = function atDate(date) {
        return LocalDateTime.of(date, this);
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetTime.of(this, offset);
      };
      _proto.toSecondOfDay = function toSecondOfDay() {
        var total = this._hour * LocalTime2.SECONDS_PER_HOUR;
        total += this._minute * LocalTime2.SECONDS_PER_MINUTE;
        total += this._second;
        return total;
      };
      _proto.toNanoOfDay = function toNanoOfDay() {
        var total = this._hour * LocalTime2.NANOS_PER_HOUR;
        total += this._minute * LocalTime2.NANOS_PER_MINUTE;
        total += this._second * LocalTime2.NANOS_PER_SECOND;
        total += this._nano;
        return total;
      };
      _proto.compareTo = function compareTo(other) {
        requireNonNull(other, "other");
        requireInstance(other, LocalTime2, "other");
        var cmp = MathUtil.compareNumbers(this._hour, other._hour);
        if (cmp === 0) {
          cmp = MathUtil.compareNumbers(this._minute, other._minute);
          if (cmp === 0) {
            cmp = MathUtil.compareNumbers(this._second, other._second);
            if (cmp === 0) {
              cmp = MathUtil.compareNumbers(this._nano, other._nano);
            }
          }
        }
        return cmp;
      };
      _proto.isAfter = function isAfter(other) {
        return this.compareTo(other) > 0;
      };
      _proto.isBefore = function isBefore(other) {
        return this.compareTo(other) < 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof LocalTime2) {
          return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        var nod = this.toNanoOfDay();
        return MathUtil.hash(nod);
      };
      _proto.toString = function toString() {
        var buf = "";
        var hourValue = this._hour;
        var minuteValue = this._minute;
        var secondValue = this._second;
        var nanoValue = this._nano;
        buf += hourValue < 10 ? "0" : "";
        buf += hourValue;
        buf += minuteValue < 10 ? ":0" : ":";
        buf += minuteValue;
        if (secondValue > 0 || nanoValue > 0) {
          buf += secondValue < 10 ? ":0" : ":";
          buf += secondValue;
          if (nanoValue > 0) {
            buf += ".";
            if (MathUtil.intMod(nanoValue, 1e6) === 0) {
              buf += ("" + (MathUtil.intDiv(nanoValue, 1e6) + 1e3)).substring(1);
            } else if (MathUtil.intMod(nanoValue, 1e3) === 0) {
              buf += ("" + (MathUtil.intDiv(nanoValue, 1e3) + 1e6)).substring(1);
            } else {
              buf += ("" + (nanoValue + 1e9)).substring(1);
            }
          }
        }
        return buf;
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      _proto.format = function format(formatter) {
        requireNonNull(formatter, "formatter");
        return formatter.format(this);
      };
      return LocalTime2;
    }(Temporal);
    LocalTime.HOURS_PER_DAY = 24;
    LocalTime.MINUTES_PER_HOUR = 60;
    LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;
    LocalTime.SECONDS_PER_MINUTE = 60;
    LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
    LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;
    LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e3;
    LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1e6;
    LocalTime.NANOS_PER_SECOND = 1e9;
    LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;
    LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
    LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;
    NANOS_PER_MILLI = 1e6;
    Instant = function(_Temporal) {
      _inheritsLoose(Instant2, _Temporal);
      Instant2.now = function now(clock) {
        if (clock === void 0) {
          clock = Clock.systemUTC();
        }
        return clock.instant();
      };
      Instant2.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {
        if (nanoAdjustment === void 0) {
          nanoAdjustment = 0;
        }
        var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
        return Instant2._create(secs, nos);
      };
      Instant2.ofEpochMilli = function ofEpochMilli(epochMilli) {
        var secs = MathUtil.floorDiv(epochMilli, 1e3);
        var mos = MathUtil.floorMod(epochMilli, 1e3);
        return Instant2._create(secs, mos * 1e6);
      };
      Instant2.ofEpochMicro = function ofEpochMicro(epochMicro) {
        var secs = MathUtil.floorDiv(epochMicro, 1e6);
        var mos = MathUtil.floorMod(epochMicro, 1e6);
        return Instant2._create(secs, mos * 1e3);
      };
      Instant2.from = function from(temporal) {
        try {
          var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
          var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
          return Instant2.ofEpochSecond(instantSecs, nanoOfSecond);
        } catch (ex) {
          throw new DateTimeException("Unable to obtain Instant from TemporalAccessor: " + temporal + ", type " + typeof temporal, ex);
        }
      };
      Instant2.parse = function parse2(text) {
        return DateTimeFormatter.ISO_INSTANT.parse(text, Instant2.FROM);
      };
      Instant2._create = function _create(seconds, nanoOfSecond) {
        if (seconds === 0 && nanoOfSecond === 0) {
          return Instant2.EPOCH;
        }
        return new Instant2(seconds, nanoOfSecond);
      };
      Instant2._validate = function _validate(seconds, nanoOfSecond) {
        if (seconds < Instant2.MIN_SECONDS || seconds > Instant2.MAX_SECONDS) {
          throw new DateTimeException("Instant exceeds minimum or maximum instant");
        }
        if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
          throw new DateTimeException("Instant exceeds minimum or maximum instant");
        }
      };
      function Instant2(seconds, nanoOfSecond) {
        var _this;
        _this = _Temporal.call(this) || this;
        Instant2._validate(seconds, nanoOfSecond);
        _this._seconds = MathUtil.safeToInt(seconds);
        _this._nanos = MathUtil.safeToInt(nanoOfSecond);
        return _this;
      }
      var _proto = Instant2.prototype;
      _proto.isSupported = function isSupported(fieldOrUnit) {
        if (fieldOrUnit instanceof ChronoField) {
          return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
        }
        if (fieldOrUnit instanceof ChronoUnit) {
          return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
        }
        return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
      };
      _proto.range = function range(field) {
        return _Temporal.prototype.range.call(this, field);
      };
      _proto.get = function get(field) {
        return this.getLong(field);
      };
      _proto.getLong = function getLong(field) {
        if (field instanceof ChronoField) {
          switch (field) {
            case ChronoField.NANO_OF_SECOND:
              return this._nanos;
            case ChronoField.MICRO_OF_SECOND:
              return MathUtil.intDiv(this._nanos, 1e3);
            case ChronoField.MILLI_OF_SECOND:
              return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
            case ChronoField.INSTANT_SECONDS:
              return this._seconds;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.getFrom(this);
      };
      _proto.epochSecond = function epochSecond() {
        return this._seconds;
      };
      _proto.nano = function nano() {
        return this._nanos;
      };
      _proto._withField = function _withField(field, newValue) {
        requireNonNull(field, "field");
        if (field instanceof ChronoField) {
          field.checkValidValue(newValue);
          switch (field) {
            case ChronoField.MILLI_OF_SECOND: {
              var nval = newValue * NANOS_PER_MILLI;
              return nval !== this._nanos ? Instant2._create(this._seconds, nval) : this;
            }
            case ChronoField.MICRO_OF_SECOND: {
              var _nval = newValue * 1e3;
              return _nval !== this._nanos ? Instant2._create(this._seconds, _nval) : this;
            }
            case ChronoField.NANO_OF_SECOND:
              return newValue !== this._nanos ? Instant2._create(this._seconds, newValue) : this;
            case ChronoField.INSTANT_SECONDS:
              return newValue !== this._seconds ? Instant2._create(newValue, this._nanos) : this;
          }
          throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
        }
        return field.adjustInto(this, newValue);
      };
      _proto.truncatedTo = function truncatedTo(unit) {
        requireNonNull(unit, "unit");
        if (unit === ChronoUnit.NANOS) {
          return this;
        }
        var unitDur = unit.duration();
        if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
          throw new DateTimeException("Unit is too large to be used for truncation");
        }
        var dur = unitDur.toNanos();
        if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
          throw new DateTimeException("Unit must divide into a standard day without remainder");
        }
        var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;
        var result = MathUtil.intDiv(nod, dur) * dur;
        return this.plusNanos(result - nod);
      };
      _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
        requireNonNull(amountToAdd, "amountToAdd");
        requireNonNull(unit, "unit");
        requireInstance(unit, TemporalUnit);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this.plusNanos(amountToAdd);
            case ChronoUnit.MICROS:
              return this.plusMicros(amountToAdd);
            case ChronoUnit.MILLIS:
              return this.plusMillis(amountToAdd);
            case ChronoUnit.SECONDS:
              return this.plusSeconds(amountToAdd);
            case ChronoUnit.MINUTES:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));
            case ChronoUnit.HOURS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));
            case ChronoUnit.HALF_DAYS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));
            case ChronoUnit.DAYS:
              return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.addTo(this, amountToAdd);
      };
      _proto.plusSeconds = function plusSeconds(secondsToAdd) {
        return this._plus(secondsToAdd, 0);
      };
      _proto.plusMillis = function plusMillis(millisToAdd) {
        return this._plus(MathUtil.intDiv(millisToAdd, 1e3), MathUtil.intMod(millisToAdd, 1e3) * NANOS_PER_MILLI);
      };
      _proto.plusNanos = function plusNanos(nanosToAdd) {
        return this._plus(0, nanosToAdd);
      };
      _proto.plusMicros = function plusMicros(microsToAdd) {
        return this._plus(MathUtil.intDiv(microsToAdd, 1e6), MathUtil.intMod(microsToAdd, 1e6) * 1e3);
      };
      _proto._plus = function _plus(secondsToAdd, nanosToAdd) {
        if (secondsToAdd === 0 && nanosToAdd === 0) {
          return this;
        }
        var epochSec = this._seconds + secondsToAdd;
        epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
        var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
        return Instant2.ofEpochSecond(epochSec, nanoAdjustment);
      };
      _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
        return this._plusUnit(-1 * amountToSubtract, unit);
      };
      _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
        return this.plusSeconds(secondsToSubtract * -1);
      };
      _proto.minusMillis = function minusMillis(millisToSubtract) {
        return this.plusMillis(-1 * millisToSubtract);
      };
      _proto.minusNanos = function minusNanos(nanosToSubtract) {
        return this.plusNanos(-1 * nanosToSubtract);
      };
      _proto.minusMicros = function minusMicros(microsToSubtract) {
        return this.plusMicros(-1 * microsToSubtract);
      };
      _proto.query = function query(_query) {
        requireNonNull(_query, "query");
        if (_query === TemporalQueries.precision()) {
          return ChronoUnit.NANOS;
        }
        if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
          return null;
        }
        return _query.queryFrom(this);
      };
      _proto.adjustInto = function adjustInto(temporal) {
        requireNonNull(temporal, "temporal");
        return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
      };
      _proto.until = function until(endExclusive, unit) {
        requireNonNull(endExclusive, "endExclusive");
        requireNonNull(unit, "unit");
        var end = Instant2.from(endExclusive);
        if (unit instanceof ChronoUnit) {
          switch (unit) {
            case ChronoUnit.NANOS:
              return this._nanosUntil(end);
            case ChronoUnit.MICROS:
              return this._microsUntil(end);
            case ChronoUnit.MILLIS:
              return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());
            case ChronoUnit.SECONDS:
              return this._secondsUntil(end);
            case ChronoUnit.MINUTES:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);
            case ChronoUnit.HOURS:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);
            case ChronoUnit.HALF_DAYS:
              return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);
            case ChronoUnit.DAYS:
              return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);
          }
          throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
        }
        return unit.between(this, end);
      };
      _proto._microsUntil = function _microsUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var totalMicros = MathUtil.safeMultiply(secsDiff, 1e6);
        return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1e3));
      };
      _proto._nanosUntil = function _nanosUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
        return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());
      };
      _proto._secondsUntil = function _secondsUntil(end) {
        var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
        var nanosDiff = end.nano() - this.nano();
        if (secsDiff > 0 && nanosDiff < 0) {
          secsDiff--;
        } else if (secsDiff < 0 && nanosDiff > 0) {
          secsDiff++;
        }
        return secsDiff;
      };
      _proto.atOffset = function atOffset(offset) {
        return OffsetDateTime.ofInstant(this, offset);
      };
      _proto.atZone = function atZone(zone) {
        return ZonedDateTime.ofInstant(this, zone);
      };
      _proto.toEpochMilli = function toEpochMilli() {
        var millis = MathUtil.safeMultiply(this._seconds, 1e3);
        return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
      };
      _proto.compareTo = function compareTo(otherInstant) {
        requireNonNull(otherInstant, "otherInstant");
        requireInstance(otherInstant, Instant2, "otherInstant");
        var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);
        if (cmp !== 0) {
          return cmp;
        }
        return this._nanos - otherInstant._nanos;
      };
      _proto.isAfter = function isAfter(otherInstant) {
        return this.compareTo(otherInstant) > 0;
      };
      _proto.isBefore = function isBefore(otherInstant) {
        return this.compareTo(otherInstant) < 0;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof Instant2) {
          return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return MathUtil.hashCode(this._seconds, this._nanos);
      };
      _proto.toString = function toString() {
        return DateTimeFormatter.ISO_INSTANT.format(this);
      };
      _proto.toJSON = function toJSON() {
        return this.toString();
      };
      return Instant2;
    }(Temporal);
    Clock = function() {
      function Clock2() {
      }
      Clock2.systemUTC = function systemUTC() {
        return new SystemClock(ZoneOffset.UTC);
      };
      Clock2.systemDefaultZone = function systemDefaultZone() {
        return new SystemClock(ZoneId.systemDefault());
      };
      Clock2.system = function system(zone) {
        return new SystemClock(zone);
      };
      Clock2.fixed = function fixed(fixedInstant, zoneId) {
        return new FixedClock(fixedInstant, zoneId);
      };
      Clock2.offset = function offset(baseClock, duration) {
        return new OffsetClock(baseClock, duration);
      };
      var _proto = Clock2.prototype;
      _proto.millis = function millis() {
        abstractMethodFail("Clock.millis");
      };
      _proto.instant = function instant() {
        abstractMethodFail("Clock.instant");
      };
      _proto.zone = function zone() {
        abstractMethodFail("Clock.zone");
      };
      _proto.withZone = function withZone() {
        abstractMethodFail("Clock.withZone");
      };
      return Clock2;
    }();
    SystemClock = function(_Clock) {
      _inheritsLoose(SystemClock2, _Clock);
      function SystemClock2(zone) {
        var _this;
        requireNonNull(zone, "zone");
        _this = _Clock.call(this) || this;
        _this._zone = zone;
        return _this;
      }
      var _proto2 = SystemClock2.prototype;
      _proto2.zone = function zone() {
        return this._zone;
      };
      _proto2.millis = function millis() {
        return (/* @__PURE__ */ new Date()).getTime();
      };
      _proto2.instant = function instant() {
        return Instant.ofEpochMilli(this.millis());
      };
      _proto2.equals = function equals(obj) {
        if (obj instanceof SystemClock2) {
          return this._zone.equals(obj._zone);
        }
        return false;
      };
      _proto2.withZone = function withZone(zone) {
        if (zone.equals(this._zone)) {
          return this;
        }
        return new SystemClock2(zone);
      };
      _proto2.toString = function toString() {
        return "SystemClock[" + this._zone.toString() + "]";
      };
      return SystemClock2;
    }(Clock);
    FixedClock = function(_Clock2) {
      _inheritsLoose(FixedClock2, _Clock2);
      function FixedClock2(fixedInstant, zoneId) {
        var _this2;
        _this2 = _Clock2.call(this) || this;
        _this2._instant = fixedInstant;
        _this2._zoneId = zoneId;
        return _this2;
      }
      var _proto3 = FixedClock2.prototype;
      _proto3.instant = function instant() {
        return this._instant;
      };
      _proto3.millis = function millis() {
        return this._instant.toEpochMilli();
      };
      _proto3.zone = function zone() {
        return this._zoneId;
      };
      _proto3.toString = function toString() {
        return "FixedClock[]";
      };
      _proto3.equals = function equals(obj) {
        if (obj instanceof FixedClock2) {
          return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);
        }
        return false;
      };
      _proto3.withZone = function withZone(zone) {
        if (zone.equals(this._zoneId)) {
          return this;
        }
        return new FixedClock2(this._instant, zone);
      };
      return FixedClock2;
    }(Clock);
    OffsetClock = function(_Clock3) {
      _inheritsLoose(OffsetClock2, _Clock3);
      function OffsetClock2(baseClock, offset) {
        var _this3;
        _this3 = _Clock3.call(this) || this;
        _this3._baseClock = baseClock;
        _this3._offset = offset;
        return _this3;
      }
      var _proto4 = OffsetClock2.prototype;
      _proto4.zone = function zone() {
        return this._baseClock.zone();
      };
      _proto4.withZone = function withZone(zone) {
        if (zone.equals(this._baseClock.zone())) {
          return this;
        }
        return new OffsetClock2(this._baseClock.withZone(zone), this._offset);
      };
      _proto4.millis = function millis() {
        return this._baseClock.millis() + this._offset.toMillis();
      };
      _proto4.instant = function instant() {
        return this._baseClock.instant().plus(this._offset);
      };
      _proto4.equals = function equals(obj) {
        if (obj instanceof OffsetClock2) {
          return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);
        }
        return false;
      };
      _proto4.toString = function toString() {
        return "OffsetClock[" + this._baseClock + "," + this._offset + "]";
      };
      return OffsetClock2;
    }(Clock);
    ZoneOffsetTransition = function() {
      ZoneOffsetTransition2.of = function of(transition, offsetBefore, offsetAfter) {
        return new ZoneOffsetTransition2(transition, offsetBefore, offsetAfter);
      };
      function ZoneOffsetTransition2(transition, offsetBefore, offsetAfter) {
        requireNonNull(transition, "transition");
        requireNonNull(offsetBefore, "offsetBefore");
        requireNonNull(offsetAfter, "offsetAfter");
        if (offsetBefore.equals(offsetAfter)) {
          throw new IllegalArgumentException("Offsets must not be equal");
        }
        if (transition.nano() !== 0) {
          throw new IllegalArgumentException("Nano-of-second must be zero");
        }
        if (transition instanceof LocalDateTime) {
          this._transition = transition;
        } else {
          this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
        }
        this._offsetBefore = offsetBefore;
        this._offsetAfter = offsetAfter;
      }
      var _proto = ZoneOffsetTransition2.prototype;
      _proto.instant = function instant() {
        return this._transition.toInstant(this._offsetBefore);
      };
      _proto.toEpochSecond = function toEpochSecond() {
        return this._transition.toEpochSecond(this._offsetBefore);
      };
      _proto.dateTimeBefore = function dateTimeBefore() {
        return this._transition;
      };
      _proto.dateTimeAfter = function dateTimeAfter() {
        return this._transition.plusSeconds(this.durationSeconds());
      };
      _proto.offsetBefore = function offsetBefore() {
        return this._offsetBefore;
      };
      _proto.offsetAfter = function offsetAfter() {
        return this._offsetAfter;
      };
      _proto.duration = function duration() {
        return Duration.ofSeconds(this.durationSeconds());
      };
      _proto.durationSeconds = function durationSeconds() {
        return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
      };
      _proto.isGap = function isGap() {
        return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
      };
      _proto.isOverlap = function isOverlap() {
        return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
      };
      _proto.isValidOffset = function isValidOffset(offset) {
        return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
      };
      _proto.validOffsets = function validOffsets() {
        if (this.isGap()) {
          return [];
        } else {
          return [this._offsetBefore, this._offsetAfter];
        }
      };
      _proto.compareTo = function compareTo(transition) {
        return this.instant().compareTo(transition.instant());
      };
      _proto.equals = function equals(other) {
        if (other === this) {
          return true;
        }
        if (other instanceof ZoneOffsetTransition2) {
          var d = other;
          return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
        }
        return false;
      };
      _proto.hashCode = function hashCode() {
        return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
      };
      _proto.toString = function toString() {
        return "Transition[" + (this.isGap() ? "Gap" : "Overlap") + " at " + this._transition.toString() + this._offsetBefore.toString() + " to " + this._offsetAfter + "]";
      };
      return ZoneOffsetTransition2;
    }();
    SystemDefaultZoneRules = function(_ZoneRules) {
      _inheritsLoose(SystemDefaultZoneRules2, _ZoneRules);
      function SystemDefaultZoneRules2() {
        return _ZoneRules.apply(this, arguments) || this;
      }
      var _proto = SystemDefaultZoneRules2.prototype;
      _proto.isFixedOffset = function isFixedOffset() {
        return false;
      };
      _proto.offsetOfInstant = function offsetOfInstant(instant) {
        var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
      };
      _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
        var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
      };
      _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
        var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1e3;
        var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
        var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 6e4;
        var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
        return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
      };
      _proto.validOffsets = function validOffsets(localDateTime) {
        return [this.offsetOfLocalDateTime(localDateTime)];
      };
      _proto.transition = function transition() {
        return null;
      };
      _proto.standardOffset = function standardOffset(instant) {
        return this.offsetOfInstant(instant);
      };
      _proto.daylightSavings = function daylightSavings() {
        this._throwNotSupported();
      };
      _proto.isDaylightSavings = function isDaylightSavings() {
        this._throwNotSupported();
      };
      _proto.isValidOffset = function isValidOffset(dateTime, offset) {
        return this.offsetOfLocalDateTime(dateTime).equals(offset);
      };
      _proto.nextTransition = function nextTransition() {
        this._throwNotSupported();
      };
      _proto.previousTransition = function previousTransition() {
        this._throwNotSupported();
      };
      _proto.transitions = function transitions() {
        this._throwNotSupported();
      };
      _proto.transitionRules = function transitionRules() {
        this._throwNotSupported();
      };
      _proto._throwNotSupported = function _throwNotSupported() {
        throw new DateTimeException("not supported operation");
      };
      _proto.equals = function equals(other) {
        if (this === other || other instanceof SystemDefaultZoneRules2) {
          return true;
        } else {
          return false;
        }
      };
      _proto.toString = function toString() {
        return "SYSTEM";
      };
      return SystemDefaultZoneRules2;
    }(ZoneRules);
    SystemDefaultZoneId = function(_ZoneId) {
      _inheritsLoose(SystemDefaultZoneId2, _ZoneId);
      function SystemDefaultZoneId2() {
        var _this;
        _this = _ZoneId.call(this) || this;
        _this._rules = new SystemDefaultZoneRules();
        return _this;
      }
      var _proto = SystemDefaultZoneId2.prototype;
      _proto.rules = function rules() {
        return this._rules;
      };
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        return false;
      };
      _proto.id = function id() {
        return "SYSTEM";
      };
      return SystemDefaultZoneId2;
    }(ZoneId);
    ZoneIdFactory = function() {
      function ZoneIdFactory2() {
      }
      ZoneIdFactory2.systemDefault = function systemDefault() {
        return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
      };
      ZoneIdFactory2.getAvailableZoneIds = function getAvailableZoneIds() {
        return ZoneRulesProvider.getAvailableZoneIds();
      };
      ZoneIdFactory2.of = function of(zoneId) {
        requireNonNull(zoneId, "zoneId");
        if (zoneId === "Z") {
          return ZoneOffset.UTC;
        }
        if (zoneId.length === 1) {
          throw new DateTimeException("Invalid zone: " + zoneId);
        }
        if (StringUtil.startsWith(zoneId, "+") || StringUtil.startsWith(zoneId, "-")) {
          return ZoneOffset.of(zoneId);
        }
        if (zoneId === "UTC" || zoneId === "GMT" || zoneId === "GMT0" || zoneId === "UT") {
          return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
        }
        if (StringUtil.startsWith(zoneId, "UTC+") || StringUtil.startsWith(zoneId, "GMT+") || StringUtil.startsWith(zoneId, "UTC-") || StringUtil.startsWith(zoneId, "GMT-")) {
          var offset = ZoneOffset.of(zoneId.substring(3));
          if (offset.totalSeconds() === 0) {
            return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
          }
          return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
        }
        if (StringUtil.startsWith(zoneId, "UT+") || StringUtil.startsWith(zoneId, "UT-")) {
          var _offset = ZoneOffset.of(zoneId.substring(2));
          if (_offset.totalSeconds() === 0) {
            return new ZoneRegion("UT", _offset.rules());
          }
          return new ZoneRegion("UT" + _offset.id(), _offset.rules());
        }
        if (zoneId === "SYSTEM") {
          return ZoneId.systemDefault();
        }
        return ZoneRegion.ofId(zoneId);
      };
      ZoneIdFactory2.ofOffset = function ofOffset(prefix, offset) {
        requireNonNull(prefix, "prefix");
        requireNonNull(offset, "offset");
        if (prefix.length === 0) {
          return offset;
        }
        if (prefix === "GMT" || prefix === "UTC" || prefix === "UT") {
          if (offset.totalSeconds() === 0) {
            return new ZoneRegion(prefix, offset.rules());
          }
          return new ZoneRegion(prefix + offset.id(), offset.rules());
        }
        throw new IllegalArgumentException("Invalid prefix, must be GMT, UTC or UT: " + prefix);
      };
      ZoneIdFactory2.from = function from(temporal) {
        requireNonNull(temporal, "temporal");
        var obj = temporal.query(TemporalQueries.zone());
        if (obj == null) {
          throw new DateTimeException("Unable to obtain ZoneId from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ""));
        }
        return obj;
      };
      return ZoneIdFactory2;
    }();
    SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;
    isInit = false;
    init();
    ToNativeJsConverter = function() {
      function ToNativeJsConverter2(temporal, zone) {
        var zonedDateTime;
        if (temporal instanceof Instant) {
          this.instant = temporal;
          return;
        } else if (temporal instanceof LocalDate) {
          zone = zone == null ? ZoneId.systemDefault() : zone;
          zonedDateTime = temporal.atStartOfDay(zone);
        } else if (temporal instanceof LocalDateTime) {
          zone = zone == null ? ZoneId.systemDefault() : zone;
          zonedDateTime = temporal.atZone(zone);
        } else if (temporal instanceof ZonedDateTime) {
          if (zone == null) {
            zonedDateTime = temporal;
          } else {
            zonedDateTime = temporal.withZoneSameInstant(zone);
          }
        } else {
          throw new IllegalArgumentException("unsupported instance for convert operation:" + temporal);
        }
        this.instant = zonedDateTime.toInstant();
      }
      var _proto = ToNativeJsConverter2.prototype;
      _proto.toDate = function toDate() {
        return new Date(this.instant.toEpochMilli());
      };
      _proto.toEpochMilli = function toEpochMilli() {
        return this.instant.toEpochMilli();
      };
      return ToNativeJsConverter2;
    }();
    _ = {
      assert: assert$1,
      DateTimeBuilder,
      DateTimeParseContext,
      DateTimePrintContext,
      MathUtil,
      StringUtil,
      StringBuilder
    };
    jsJodaExports = {
      _,
      convert,
      nativeJs,
      ArithmeticException,
      DateTimeException,
      DateTimeParseException,
      IllegalArgumentException,
      IllegalStateException,
      UnsupportedTemporalTypeException,
      NullPointerException,
      Clock,
      DayOfWeek,
      Duration,
      Instant,
      LocalDate,
      LocalTime,
      LocalDateTime,
      OffsetTime,
      OffsetDateTime,
      Month,
      MonthDay,
      ParsePosition,
      Period,
      Year,
      YearConstants,
      YearMonth,
      ZonedDateTime,
      ZoneOffset,
      ZoneId,
      ZoneRegion,
      ZoneOffsetTransition,
      ZoneRules,
      ZoneRulesProvider,
      ChronoLocalDate,
      ChronoLocalDateTime,
      ChronoZonedDateTime,
      IsoChronology,
      ChronoField,
      ChronoUnit,
      IsoFields,
      Temporal,
      TemporalAccessor,
      TemporalAdjuster,
      TemporalAdjusters,
      TemporalAmount,
      TemporalField,
      TemporalQueries,
      TemporalQuery,
      TemporalUnit,
      ValueRange,
      DateTimeFormatter,
      DateTimeFormatterBuilder,
      DecimalStyle,
      ResolverStyle,
      SignStyle,
      TextStyle
    };
    use = bindUse(jsJodaExports);
    jsJodaExports.use = use;
  }
});

// node_modules/tedious/lib/data-types/datetime.js
var require_datetime = __commonJS({
  "node_modules/tedious/lib/data-types/datetime.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1900, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([8]);
    var DateTime = {
      id: 61,
      type: "DATETIME",
      name: "DateTime",
      declaration: function() {
        return "datetime";
      },
      generateTypeInfo() {
        return Buffer.from([_datetimen.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        let days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        let milliseconds, threeHundredthsOfSecond;
        if (options.useUTC) {
          let seconds = value.getUTCHours() * 60 * 60;
          seconds += value.getUTCMinutes() * 60;
          seconds += value.getUTCSeconds();
          milliseconds = seconds * 1e3 + value.getUTCMilliseconds();
        } else {
          let seconds = value.getHours() * 60 * 60;
          seconds += value.getMinutes() * 60;
          seconds += value.getSeconds();
          milliseconds = seconds * 1e3 + value.getMilliseconds();
        }
        threeHundredthsOfSecond = milliseconds / (3 + 1 / 3);
        threeHundredthsOfSecond = Math.round(threeHundredthsOfSecond);
        if (threeHundredthsOfSecond === 2592e4) {
          days += 1;
          threeHundredthsOfSecond = 0;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeInt32LE(days, 0);
        buffer.writeUInt32LE(threeHundredthsOfSecond, 4);
        yield buffer;
      },
      // TODO: type 'any' needs to be revisited.
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1753 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = DateTime;
    module.exports = DateTime;
  }
});

// node_modules/tedious/lib/data-types/float.js
var require_float = __commonJS({
  "node_modules/tedious/lib/data-types/float.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _floatn = _interopRequireDefault(require_floatn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Float = {
      id: 62,
      type: "FLT8",
      name: "Float",
      declaration: function() {
        return "float";
      },
      generateTypeInfo() {
        return Buffer.from([_floatn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return Buffer.from([8]);
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(8);
        buffer.writeDoubleLE(parseFloat(parameter.value), 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports.default = Float;
    module.exports = Float;
  }
});

// node_modules/tedious/lib/data-types/decimaln.js
var require_decimaln = __commonJS({
  "node_modules/tedious/lib/data-types/decimaln.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var DecimalN = {
      id: 106,
      type: "DECIMALN",
      name: "DecimalN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = DecimalN;
    module.exports = DecimalN;
  }
});

// node_modules/tedious/lib/data-types/decimal.js
var require_decimal = __commonJS({
  "node_modules/tedious/lib/data-types/decimal.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Decimal = {
      id: 55,
      type: "DECIMAL",
      name: "Decimal",
      declaration: function(parameter) {
        return "decimal(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter, _options) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_decimaln.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        const precision = parameter.precision;
        if (precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(9);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(13);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(17);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports.default = Decimal;
    module.exports = Decimal;
  }
});

// node_modules/tedious/lib/data-types/numericn.js
var require_numericn = __commonJS({
  "node_modules/tedious/lib/data-types/numericn.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NumericN = {
      id: 108,
      type: "NUMERICN",
      name: "NumericN",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = NumericN;
    module.exports = NumericN;
  }
});

// node_modules/tedious/lib/data-types/numeric.js
var require_numeric = __commonJS({
  "node_modules/tedious/lib/data-types/numeric.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _numericn = _interopRequireDefault(require_numericn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Numeric = {
      id: 63,
      type: "NUMERIC",
      name: "Numeric",
      declaration: function(parameter) {
        return "numeric(" + this.resolvePrecision(parameter) + ", " + this.resolveScale(parameter) + ")";
      },
      resolvePrecision: function(parameter) {
        if (parameter.precision != null) {
          return parameter.precision;
        } else if (parameter.value === null) {
          return 1;
        } else {
          return 18;
        }
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else {
          return 0;
        }
      },
      generateTypeInfo(parameter) {
        let precision;
        if (parameter.precision <= 9) {
          precision = 5;
        } else if (parameter.precision <= 19) {
          precision = 9;
        } else if (parameter.precision <= 28) {
          precision = 13;
        } else {
          precision = 17;
        }
        return Buffer.from([_numericn.default.id, precision, parameter.precision, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const precision = parameter.precision;
        if (precision <= 9) {
          return Buffer.from([5]);
        } else if (precision <= 19) {
          return Buffer.from([9]);
        } else if (precision <= 28) {
          return Buffer.from([13]);
        } else {
          return Buffer.from([17]);
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const sign = parameter.value < 0 ? 0 : 1;
        const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
        if (parameter.precision <= 9) {
          const buffer = Buffer.alloc(5);
          buffer.writeUInt8(sign, 0);
          buffer.writeUInt32LE(value, 1);
          yield buffer;
        } else if (parameter.precision <= 19) {
          const buffer = new _writableTrackingBuffer.default(10);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          yield buffer.data;
        } else if (parameter.precision <= 28) {
          const buffer = new _writableTrackingBuffer.default(14);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        } else {
          const buffer = new _writableTrackingBuffer.default(18);
          buffer.writeUInt8(sign);
          buffer.writeUInt64LE(value);
          buffer.writeUInt32LE(0);
          buffer.writeUInt32LE(0);
          yield buffer.data;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        return value;
      }
    };
    var _default = exports.default = Numeric;
    module.exports = Numeric;
  }
});

// node_modules/tedious/lib/data-types/smallmoney.js
var require_smallmoney = __commonJS({
  "node_modules/tedious/lib/data-types/smallmoney.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _moneyn = _interopRequireDefault(require_moneyn());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([4]);
    var NULL_LENGTH = Buffer.from([0]);
    var SmallMoney = {
      id: 122,
      type: "MONEY4",
      name: "SmallMoney",
      declaration: function() {
        return "smallmoney";
      },
      generateTypeInfo: function() {
        return Buffer.from([_moneyn.default.id, 4]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value * 1e4, 0);
        yield buffer;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        value = parseFloat(value);
        if (isNaN(value)) {
          throw new TypeError("Invalid number.");
        }
        if (value < -214748.3648 || value > 214748.3647) {
          throw new TypeError("Value must be between -214748.3648 and 214748.3647.");
        }
        return value;
      }
    };
    var _default = exports.default = SmallMoney;
    module.exports = SmallMoney;
  }
});

// node_modules/tedious/lib/data-types/bigint.js
var require_bigint = __commonJS({
  "node_modules/tedious/lib/data-types/bigint.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _intn = _interopRequireDefault(require_intn());
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var DATA_LENGTH = Buffer.from([8]);
    var NULL_LENGTH = Buffer.from([0]);
    var MAX_SAFE_BIGINT = 9223372036854775807n;
    var MIN_SAFE_BIGINT = -9223372036854775808n;
    var BigInt2 = {
      id: 127,
      type: "INT8",
      name: "BigInt",
      declaration: function() {
        return "bigint";
      },
      generateTypeInfo() {
        return Buffer.from([_intn.default.id, 8]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(8);
        buffer.writeInt64LE(Number(parameter.value));
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "bigint") {
          value = globalThis.BigInt(value);
        }
        if (value < MIN_SAFE_BIGINT || value > MAX_SAFE_BIGINT) {
          throw new TypeError(`Value must be between ${MIN_SAFE_BIGINT} and ${MAX_SAFE_BIGINT}, inclusive.`);
        }
        return value;
      }
    };
    var _default = exports.default = BigInt2;
    module.exports = BigInt2;
  }
});

// node_modules/tedious/lib/data-types/image.js
var require_image = __commonJS({
  "node_modules/tedious/lib/data-types/image.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Image = {
      id: 34,
      type: "IMAGE",
      name: "Image",
      hasTableName: true,
      declaration: function() {
        return "image";
      },
      resolveLength: function(parameter) {
        if (parameter.value != null) {
          const value = parameter.value;
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(5);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(parameter.value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports.default = Image;
    module.exports = Image;
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module.exports = safer;
  }
});

// node_modules/tedious/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/lib/bom-handling.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var BOMChar = "\uFEFF";
    exports.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res)
        return res;
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function")
          this.options.stripBOM();
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/internal.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safer().Buffer;
    module.exports = {
      // Encodings
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      // Codec.
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
      else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require_string_decoder().StringDecoder;
    if (!StringDecoder.prototype.end)
      StringDecoder.prototype.end = function() {
      };
    function InternalDecoder(options, codec) {
      this.decoder = new StringDecoder(codec.enc);
    }
    InternalDecoder.prototype.write = function(buf) {
      if (!Buffer2.isBuffer(buf)) {
        buf = Buffer2.from(buf);
      }
      return this.decoder.write(buf);
    };
    InternalDecoder.prototype.end = function() {
      return this.decoder.end();
    };
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer2.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer2.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer2.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128)
          buf[bufIdx++] = charCode;
        else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0)
                res += this.defaultCharUnicode;
              else if (accBytes === 3 && acc < 2048)
                res += this.defaultCharUnicode;
              else
                res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0)
        res += this.defaultCharUnicode;
      return res;
    };
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/utf32.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safer().Buffer;
    exports._utf32 = Utf32Codec;
    function Utf32Codec(codecOptions, iconv) {
      this.iconv = iconv;
      this.bomAware = true;
      this.isLE = codecOptions.isLE;
    }
    exports.utf32le = { type: "_utf32", isLE: true };
    exports.utf32be = { type: "_utf32", isLE: false };
    exports.ucs4le = "utf32le";
    exports.ucs4be = "utf32be";
    Utf32Codec.prototype.encoder = Utf32Encoder;
    Utf32Codec.prototype.decoder = Utf32Decoder;
    function Utf32Encoder(options, codec) {
      this.isLE = codec.isLE;
      this.highSurrogate = 0;
    }
    Utf32Encoder.prototype.write = function(str) {
      var src = Buffer2.from(str, "ucs2");
      var dst = Buffer2.alloc(src.length * 2);
      var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
      var offset = 0;
      for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate = 55296 <= code && code < 56320;
        var isLowSurrogate = 56320 <= code && code < 57344;
        if (this.highSurrogate) {
          if (isHighSurrogate || !isLowSurrogate) {
            write32.call(dst, this.highSurrogate, offset);
            offset += 4;
          } else {
            var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
            write32.call(dst, codepoint, offset);
            offset += 4;
            this.highSurrogate = 0;
            continue;
          }
        }
        if (isHighSurrogate)
          this.highSurrogate = code;
        else {
          write32.call(dst, code, offset);
          offset += 4;
          this.highSurrogate = 0;
        }
      }
      if (offset < dst.length)
        dst = dst.slice(0, offset);
      return dst;
    };
    Utf32Encoder.prototype.end = function() {
      if (!this.highSurrogate)
        return;
      var buf = Buffer2.alloc(4);
      if (this.isLE)
        buf.writeUInt32LE(this.highSurrogate, 0);
      else
        buf.writeUInt32BE(this.highSurrogate, 0);
      this.highSurrogate = 0;
      return buf;
    };
    function Utf32Decoder(options, codec) {
      this.isLE = codec.isLE;
      this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
      this.overflow = [];
    }
    Utf32Decoder.prototype.write = function(src) {
      if (src.length === 0)
        return "";
      var i = 0;
      var codepoint = 0;
      var dst = Buffer2.alloc(src.length + 4);
      var offset = 0;
      var isLE = this.isLE;
      var overflow = this.overflow;
      var badChar = this.badChar;
      if (overflow.length > 0) {
        for (; i < src.length && overflow.length < 4; i++)
          overflow.push(src[i]);
        if (overflow.length === 4) {
          if (isLE) {
            codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
          } else {
            codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
          }
          overflow.length = 0;
          offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
      }
      for (; i < src.length - 3; i += 4) {
        if (isLE) {
          codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
        } else {
          codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
        }
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
      for (; i < src.length; i++) {
        overflow.push(src[i]);
      }
      return dst.slice(0, offset).toString("ucs2");
    };
    function _writeCodepoint(dst, offset, codepoint, badChar) {
      if (codepoint < 0 || codepoint > 1114111) {
        codepoint = badChar;
      }
      if (codepoint >= 65536) {
        codepoint -= 65536;
        var high = 55296 | codepoint >> 10;
        dst[offset++] = high & 255;
        dst[offset++] = high >> 8;
        var codepoint = 56320 | codepoint & 1023;
      }
      dst[offset++] = codepoint & 255;
      dst[offset++] = codepoint >> 8;
      return offset;
    }
    Utf32Decoder.prototype.end = function() {
      this.overflow.length = 0;
    };
    exports.utf32 = Utf32AutoCodec;
    exports.ucs4 = "utf32";
    function Utf32AutoCodec(options, iconv) {
      this.iconv = iconv;
    }
    Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
    Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
    function Utf32AutoEncoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
    }
    Utf32AutoEncoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf32AutoEncoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf32AutoDecoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf32AutoDecoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 32)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf32AutoDecoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var invalidLE = 0, invalidBE = 0;
      var bmpCharsLE = 0, bmpCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                  return "utf-32le";
                }
                if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                  return "utf-32be";
                }
              }
              if (b[0] !== 0 || b[1] > 16)
                invalidBE++;
              if (b[3] !== 0 || b[2] > 16)
                invalidLE++;
              if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0))
                bmpCharsBE++;
              if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0)
                bmpCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)
        return "utf-32be";
      if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)
        return "utf-32le";
      return defaultEncoding || "utf-32le";
    }
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/utf16.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safer().Buffer;
    exports.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer2.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0)
        return "";
      var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
      this.overflowByte = -1;
    };
    exports.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder("utf-16le", options);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 16)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var asciiCharsLE = 0, asciiCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254)
                  return "utf-16le";
                if (b[0] === 254 && b[1] === 255)
                  return "utf-16be";
              }
              if (b[0] === 0 && b[1] !== 0)
                asciiCharsBE++;
              if (b[0] !== 0 && b[1] === 0)
                asciiCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (asciiCharsBE > asciiCharsLE)
        return "utf-16be";
      if (asciiCharsBE < asciiCharsLE)
        return "utf-16le";
      return defaultEncoding || "utf-16le";
    }
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/utf7.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safer().Buffer;
    exports.utf7 = Utf7Codec;
    exports.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer2.from(str.replace(nonDirectChars, (function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }).bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (i = 0; i < 256; i++)
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var i;
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer2.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (32 <= uChar && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar)
              buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer2.alloc(10), bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/sbcs-codec.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safer().Buffer;
    exports._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions)
        throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
          asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length);
      for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer2.alloc(buf.length * 2);
      var idx1 = 0, idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/sbcs-data.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = {
      // Not supported by iconv, not sure why.
      "10029": "maccenteuro",
      "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
      },
      "808": "cp808",
      "ibm808": "cp808",
      "cp808": {
        "type": "_sbcs",
        "chars": ""
      },
      "mik": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp720": {
        "type": "_sbcs",
        "chars": ""
      },
      // Aliases of generated encodings.
      "ascii8bit": "ascii",
      "usascii": "ascii",
      "ansix34": "ascii",
      "ansix341968": "ascii",
      "ansix341986": "ascii",
      "csascii": "ascii",
      "cp367": "ascii",
      "ibm367": "ascii",
      "isoir6": "ascii",
      "iso646us": "ascii",
      "iso646irv": "ascii",
      "us": "ascii",
      "latin1": "iso88591",
      "latin2": "iso88592",
      "latin3": "iso88593",
      "latin4": "iso88594",
      "latin5": "iso88599",
      "latin6": "iso885910",
      "latin7": "iso885913",
      "latin8": "iso885914",
      "latin9": "iso885915",
      "latin10": "iso885916",
      "csisolatin1": "iso88591",
      "csisolatin2": "iso88592",
      "csisolatin3": "iso88593",
      "csisolatin4": "iso88594",
      "csisolatincyrillic": "iso88595",
      "csisolatinarabic": "iso88596",
      "csisolatingreek": "iso88597",
      "csisolatinhebrew": "iso88598",
      "csisolatin5": "iso88599",
      "csisolatin6": "iso885910",
      "l1": "iso88591",
      "l2": "iso88592",
      "l3": "iso88593",
      "l4": "iso88594",
      "l5": "iso88599",
      "l6": "iso885910",
      "l7": "iso885913",
      "l8": "iso885914",
      "l9": "iso885915",
      "l10": "iso885916",
      "isoir14": "iso646jp",
      "isoir57": "iso646cn",
      "isoir100": "iso88591",
      "isoir101": "iso88592",
      "isoir109": "iso88593",
      "isoir110": "iso88594",
      "isoir144": "iso88595",
      "isoir127": "iso88596",
      "isoir126": "iso88597",
      "isoir138": "iso88598",
      "isoir148": "iso88599",
      "isoir157": "iso885910",
      "isoir166": "tis620",
      "isoir179": "iso885913",
      "isoir199": "iso885914",
      "isoir203": "iso885915",
      "isoir226": "iso885916",
      "cp819": "iso88591",
      "ibm819": "iso88591",
      "cyrillic": "iso88595",
      "arabic": "iso88596",
      "arabic8": "iso88596",
      "ecma114": "iso88596",
      "asmo708": "iso88596",
      "greek": "iso88597",
      "greek8": "iso88597",
      "ecma118": "iso88597",
      "elot928": "iso88597",
      "hebrew": "iso88598",
      "hebrew8": "iso88598",
      "turkish": "iso88599",
      "turkish8": "iso88599",
      "thai": "iso885911",
      "thai8": "iso885911",
      "celtic": "iso885914",
      "celtic8": "iso885914",
      "isoceltic": "iso885914",
      "tis6200": "tis620",
      "tis62025291": "tis620",
      "tis62025330": "tis620",
      "10000": "macroman",
      "10006": "macgreek",
      "10007": "maccyrillic",
      "10079": "maciceland",
      "10081": "macturkish",
      "cspc8codepage437": "cp437",
      "cspc775baltic": "cp775",
      "cspc850multilingual": "cp850",
      "cspcp852": "cp852",
      "cspc862latinhebrew": "cp862",
      "cpgr": "cp869",
      "msee": "cp1250",
      "mscyrl": "cp1251",
      "msansi": "cp1252",
      "msgreek": "cp1253",
      "msturk": "cp1254",
      "mshebr": "cp1255",
      "msarab": "cp1256",
      "winbaltrim": "cp1257",
      "cp20866": "koi8r",
      "20866": "koi8r",
      "ibm878": "koi8r",
      "cskoi8r": "koi8r",
      "cp21866": "koi8u",
      "21866": "koi8u",
      "ibm1168": "koi8u",
      "strk10482002": "rk1048",
      "tcvn5712": "tcvn",
      "tcvn57121": "tcvn",
      "gb198880": "iso646cn",
      "cn": "iso646cn",
      "csiso14jisc6220ro": "iso646jp",
      "jisc62201969ro": "iso646jp",
      "jp": "iso646jp",
      "cshproman8": "hproman8",
      "r8": "hproman8",
      "roman8": "hproman8",
      "xroman8": "hproman8",
      "ibm1051": "hproman8",
      "mac": "macintosh",
      "csmacintosh": "macintosh"
    };
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": ""
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": ""
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": ""
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": ""
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": ""
      },
      "macroman": {
        "type": "_sbcs",
        "chars": ""
      },
      "macromania": {
        "type": "_sbcs",
        "chars": ""
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "\uFEFF"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": ""
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": ""
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": ")(.,-"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": ""
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": ""
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": ""
      },
      "pt154": {
        "type": "_sbcs",
        "chars": ""
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": ""
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": ""
      },
      "ascii": {
        "type": "_sbcs",
        "chars": ""
      },
      "tis620": {
        "type": "_sbcs",
        "chars": ""
      }
    };
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/dbcs-codec.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safer().Buffer;
    exports._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (i = 0; i < 256; i++)
      UNASSIGNED_NODE[i] = UNASSIGNED;
    var i;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions)
        throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++)
        this._addDecodeChunk(mappingTable[i2]);
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var firstByteNode = this.decodeTables[0];
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
          for (var j = 48; j <= 57; j++) {
            if (secondByteNode[j] === UNASSIGNED) {
              secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
            } else if (secondByteNode[j] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 2");
            }
            var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
            for (var k = 129; k <= 254; k++) {
              if (thirdByteNode[k] === UNASSIGNED) {
                thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
              } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                continue;
              } else if (thirdByteNode[k] > NODE_START) {
                throw new Error("gb18030 decode tables conflict at byte 3");
              }
              var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
              for (var l = 48; l <= 57; l++) {
                if (fourthByteNode[l] === UNASSIGNED)
                  fourthByteNode[l] = GB18030_CODE;
              }
            }
          }
        }
      }
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals)
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number")
            skipEncodeChars[val] = true;
          else
            for (var j = val.from; j <= val.to; j++)
              skipEncodeChars[j] = true;
        }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED)
        this.defCharSB = "?".charCodeAt(0);
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes = [];
      for (; addr > 0; addr >>>= 8)
        bytes.push(addr & 255);
      if (bytes.length == 0)
        bytes.push(0);
      var node = this.decodeTables[0];
      for (var i2 = bytes.length - 1; i2 > 0; i2--) {
        var val = node[bytes[i2]];
        if (val == UNASSIGNED) {
          node[bytes[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (55296 <= code && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (56320 <= codeTrail && codeTrail < 57344)
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              else
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (4080 < code && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++)
                seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else
              writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++)
            writeTable[curAddr++] = charCode++;
        } else
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 255)
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED)
          node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object")
          node = oldVal;
        else {
          node = node[uCode] = {};
          if (oldVal !== void 0)
            node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      var hasValues = false;
      var subNodeEmpty = {};
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode])
          continue;
        if (uCode >= 0) {
          this._setEncodeChar(uCode, mbCode);
          hasValues = true;
        } else if (uCode <= NODE_START) {
          var subNodeIdx = NODE_START - uCode;
          if (!subNodeEmpty[subNodeIdx]) {
            var newPrefix = mbCode << 8 >>> 0;
            if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
              hasValues = true;
            else
              subNodeEmpty[subNodeIdx] = true;
          }
        } else if (uCode <= SEQ_START) {
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
          hasValues = true;
        }
      }
      return hasValues;
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length)
            break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (55296 <= uCode && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0)
            dbcsCode = subtable[uCode & 255];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED)
          dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else if (dbcsCode < 16777216) {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >>> 24;
          newBuf[j++] = dbcsCode >>> 16 & 255;
          newBuf[j++] = dbcsCode >>> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0)
        return;
      var newBuf = Buffer2.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBytes = [];
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          uCode = this.defaultCharUnicode.charCodeAt(0);
          i2 = seqStart;
        } else if (uCode === GB18030_CODE) {
          if (i2 >= 3) {
            var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
          } else {
            var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
          }
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode >= 65536) {
          uCode -= 65536;
          var uCodeLead = 55296 | uCode >> 10;
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 | uCode & 1023;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret = "";
      while (this.prevBytes.length > 0) {
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0)
          ret += this.write(bytesArr);
      }
      this.prevBytes = [];
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val)
        return -1;
      var l = 0, r = table.length;
      while (l < r - 1) {
        var mid = l + (r - l + 1 >> 1);
        if (table[mid] <= val)
          l = mid;
        else
          r = mid;
      }
      return l;
    }
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports, module) {
    module.exports = [
      ["0", "\0", 128],
      ["a1", "", 62],
      ["8140", "", 9, ""],
      ["8180", ""],
      ["81b8", ""],
      ["81c8", ""],
      ["81da", ""],
      ["81f0", ""],
      ["81fc", ""],
      ["824f", "", 9],
      ["8260", "", 25],
      ["8281", "", 25],
      ["829f", "", 82],
      ["8340", "", 62],
      ["8380", "", 22],
      ["839f", "", 16, "", 6],
      ["83bf", "", 16, "", 6],
      ["8440", "", 5, "", 25],
      ["8470", "", 5, "", 7],
      ["8480", "", 17],
      ["849f", ""],
      ["8740", "", 19, "", 9],
      ["875f", ""],
      ["877e", ""],
      ["8780", "", 4, ""],
      ["889f", ""],
      ["8940", ""],
      ["8980", ""],
      ["8a40", ""],
      ["8a80", ""],
      ["8b40", ""],
      ["8b80", ""],
      ["8c40", ""],
      ["8c80", ""],
      ["8d40", ""],
      ["8d80", ""],
      ["8e40", ""],
      ["8e80", ""],
      ["8f40", ""],
      ["8f80", ""],
      ["9040", ""],
      ["9080", ""],
      ["9140", ""],
      ["9180", ""],
      ["9240", ""],
      ["9280", ""],
      ["9340", ""],
      ["9380", ""],
      ["9440", ""],
      ["9480", ""],
      ["9540", ""],
      ["9580", ""],
      ["9640", ""],
      ["9680", ""],
      ["9740", ""],
      ["9780", ""],
      ["9840", ""],
      ["989f", ""],
      ["9940", ""],
      ["9980", ""],
      ["9a40", ""],
      ["9a80", ""],
      ["9b40", ""],
      ["9b80", ""],
      ["9c40", ""],
      ["9c80", ""],
      ["9d40", ""],
      ["9d80", ""],
      ["9e40", ""],
      ["9e80", ""],
      ["9f40", ""],
      ["9f80", ""],
      ["e040", ""],
      ["e080", ""],
      ["e140", ""],
      ["e180", ""],
      ["e240", ""],
      ["e280", ""],
      ["e340", ""],
      ["e380", ""],
      ["e440", ""],
      ["e480", ""],
      ["e540", ""],
      ["e580", ""],
      ["e640", ""],
      ["e680", ""],
      ["e740", ""],
      ["e780", ""],
      ["e840", ""],
      ["e880", ""],
      ["e940", ""],
      ["e980", ""],
      ["ea40", ""],
      ["ea80", ""],
      ["ed40", ""],
      ["ed80", ""],
      ["ee40", ""],
      ["ee80", ""],
      ["eeef", "", 9, ""],
      ["f040", "", 62],
      ["f080", "", 124],
      ["f140", "", 62],
      ["f180", "", 124],
      ["f240", "", 62],
      ["f280", "", 124],
      ["f340", "", 62],
      ["f380", "", 124],
      ["f440", "", 62],
      ["f480", "", 124],
      ["f540", "", 62],
      ["f580", "", 124],
      ["f640", "", 62],
      ["f680", "", 124],
      ["f740", "", 62],
      ["f780", "", 124],
      ["f840", "", 62],
      ["f880", "", 124],
      ["f940", ""],
      ["fa40", "", 9, "", 9, ""],
      ["fa80", ""],
      ["fb40", ""],
      ["fb80", ""],
      ["fc40", ""]
    ];
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/tables/eucjp.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127],
      ["8ea1", "", 62],
      ["a1a1", "", 9, ""],
      ["a2a1", ""],
      ["a2ba", ""],
      ["a2ca", ""],
      ["a2dc", ""],
      ["a2f2", ""],
      ["a2fe", ""],
      ["a3b0", "", 9],
      ["a3c1", "", 25],
      ["a3e1", "", 25],
      ["a4a1", "", 82],
      ["a5a1", "", 85],
      ["a6a1", "", 16, "", 6],
      ["a6c1", "", 16, "", 6],
      ["a7a1", "", 5, "", 25],
      ["a7d1", "", 5, "", 25],
      ["a8a1", ""],
      ["ada1", "", 19, "", 9],
      ["adc0", ""],
      ["addf", "", 4, ""],
      ["b0a1", ""],
      ["b1a1", ""],
      ["b2a1", ""],
      ["b3a1", ""],
      ["b4a1", ""],
      ["b5a1", ""],
      ["b6a1", ""],
      ["b7a1", ""],
      ["b8a1", ""],
      ["b9a1", ""],
      ["baa1", ""],
      ["bba1", ""],
      ["bca1", ""],
      ["bda1", ""],
      ["bea1", ""],
      ["bfa1", ""],
      ["c0a1", ""],
      ["c1a1", ""],
      ["c2a1", ""],
      ["c3a1", ""],
      ["c4a1", ""],
      ["c5a1", ""],
      ["c6a1", ""],
      ["c7a1", ""],
      ["c8a1", ""],
      ["c9a1", ""],
      ["caa1", ""],
      ["cba1", ""],
      ["cca1", ""],
      ["cda1", ""],
      ["cea1", ""],
      ["cfa1", ""],
      ["d0a1", ""],
      ["d1a1", ""],
      ["d2a1", ""],
      ["d3a1", ""],
      ["d4a1", ""],
      ["d5a1", ""],
      ["d6a1", ""],
      ["d7a1", ""],
      ["d8a1", ""],
      ["d9a1", ""],
      ["daa1", ""],
      ["dba1", ""],
      ["dca1", ""],
      ["dda1", ""],
      ["dea1", ""],
      ["dfa1", ""],
      ["e0a1", ""],
      ["e1a1", ""],
      ["e2a1", ""],
      ["e3a1", ""],
      ["e4a1", ""],
      ["e5a1", ""],
      ["e6a1", ""],
      ["e7a1", ""],
      ["e8a1", ""],
      ["e9a1", ""],
      ["eaa1", ""],
      ["eba1", ""],
      ["eca1", ""],
      ["eda1", ""],
      ["eea1", ""],
      ["efa1", ""],
      ["f0a1", ""],
      ["f1a1", ""],
      ["f2a1", ""],
      ["f3a1", ""],
      ["f4a1", ""],
      ["f9a1", ""],
      ["faa1", ""],
      ["fba1", ""],
      ["fca1", ""],
      ["fcf1", "", 9, ""],
      ["8fa2af", ""],
      ["8fa2c2", ""],
      ["8fa2eb", ""],
      ["8fa6e1", ""],
      ["8fa6e7", ""],
      ["8fa6e9", ""],
      ["8fa6ec", ""],
      ["8fa6f1", ""],
      ["8fa7c2", "", 10, ""],
      ["8fa7f2", "", 10, ""],
      ["8fa9a1", ""],
      ["8fa9a4", ""],
      ["8fa9a6", ""],
      ["8fa9a8", ""],
      ["8fa9ab", ""],
      ["8fa9af", ""],
      ["8fa9c1", ""],
      ["8faaa1", ""],
      ["8faaba", ""],
      ["8faba1", ""],
      ["8fabbd", ""],
      ["8fabc5", ""],
      ["8fb0a1", ""],
      ["8fb1a1", ""],
      ["8fb2a1", "", 4, ""],
      ["8fb3a1", ""],
      ["8fb4a1", ""],
      ["8fb5a1", ""],
      ["8fb6a1", "", 5, "", 4, ""],
      ["8fb7a1", "", 4, ""],
      ["8fb8a1", ""],
      ["8fb9a1", ""],
      ["8fbaa1", "", 4, ""],
      ["8fbba1", ""],
      ["8fbca1", "", 4, ""],
      ["8fbda1", "", 4, ""],
      ["8fbea1", "", 4, ""],
      ["8fbfa1", ""],
      ["8fc0a1", ""],
      ["8fc1a1", ""],
      ["8fc2a1", ""],
      ["8fc3a1", "", 4, ""],
      ["8fc4a1", ""],
      ["8fc5a1", ""],
      ["8fc6a1", ""],
      ["8fc7a1", ""],
      ["8fc8a1", ""],
      ["8fc9a1", "", 4, "", 4, ""],
      ["8fcaa1", ""],
      ["8fcba1", ""],
      ["8fcca1", "", 9, ""],
      ["8fcda1", "", 5, ""],
      ["8fcea1", "", 6, ""],
      ["8fcfa1", ""],
      ["8fd0a1", ""],
      ["8fd1a1", ""],
      ["8fd2a1", "", 5],
      ["8fd3a1", ""],
      ["8fd4a1", "", 4, ""],
      ["8fd5a1", ""],
      ["8fd6a1", ""],
      ["8fd7a1", ""],
      ["8fd8a1", ""],
      ["8fd9a1", "", 4, "", 6, ""],
      ["8fdaa1", "", 4, ""],
      ["8fdba1", "", 6, ""],
      ["8fdca1", "", 4, ""],
      ["8fdda1", "", 4, ""],
      ["8fdea1", "", 4, ""],
      ["8fdfa1", ""],
      ["8fe0a1", ""],
      ["8fe1a1", "", 4, ""],
      ["8fe2a1", ""],
      ["8fe3a1", "", 5, "", 4, ""],
      ["8fe4a1", "", 4, ""],
      ["8fe5a1", "", 4, ""],
      ["8fe6a1", ""],
      ["8fe7a1", ""],
      ["8fe8a1", "", 4, ""],
      ["8fe9a1", "", 4],
      ["8feaa1", "", 4, ""],
      ["8feba1", "", 4, ""],
      ["8feca1", ""],
      ["8feda1", "", 4, "", 4, ""]
    ];
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/tables/cp936.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127, ""],
      ["8140", "", 5, "", 9, "", 6, ""],
      ["8180", "", 6, "", 4, "", 4, "", 5, ""],
      ["8240", "", 4, "", 8, "", 4, "", 11],
      ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
      ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
      ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
      ["8440", "", 5, "", 5, ""],
      ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
      ["8540", "", 9, ""],
      ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
      ["8640", "", 4, "", 5, "", 4, "", 5, ""],
      ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
      ["8740", "", 7, "", 11, "", 4, "", 4],
      ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
      ["8840", "", 9, "", 4, "", 4, ""],
      ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
      ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
      ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
      ["8a40", "", 4, "", 12, ""],
      ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
      ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
      ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
      ["8c40", "", 7, ""],
      ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
      ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
      ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
      ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
      ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
      ["8f40", "", 5, "", 11, "", 8, ""],
      ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
      ["9040", "", 4, "", 4, "", 6, ""],
      ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
      ["9140", "", 6, "", 6, "", 18, "", 4, ""],
      ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
      ["9240", "", 6, "", 5, ""],
      ["9280", "", 5, "", 7, "", 6, ""],
      ["9340", "", 6, "", 4, "", 4, "", 5, ""],
      ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
      ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
      ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
      ["9540", "", 4, "", 4, "", 6, ""],
      ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
      ["9640", "", 5, "", 4, ""],
      ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
      ["9740", "", 7, "", 8, "", 7, "", 9, ""],
      ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
      ["9840", "", 4, "", 5, "", 9, ""],
      ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
      ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
      ["9980", "", 114, "", 6],
      ["9a40", "", 11, "", 7, "", 13, ""],
      ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
      ["9b40", "", 4, ""],
      ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
      ["9c40", "", 7, ""],
      ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
      ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
      ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
      ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
      ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
      ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
      ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
      ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
      ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
      ["a1a1", "", 7, ""],
      ["a2a1", "", 9],
      ["a2b1", "", 19, "", 19, "", 9],
      ["a2e5", "", 9],
      ["a2f1", "", 11],
      ["a3a1", "", 88, ""],
      ["a4a1", "", 82],
      ["a5a1", "", 85],
      ["a6a1", "", 16, "", 6],
      ["a6c1", "", 16, "", 6],
      ["a6e0", ""],
      ["a6ee", ""],
      ["a6f4", ""],
      ["a7a1", "", 5, "", 25],
      ["a7d1", "", 5, "", 25],
      ["a840", "", 35, "", 6],
      ["a880", "", 7, ""],
      ["a8a1", ""],
      ["a8bd", ""],
      ["a8c0", ""],
      ["a8c5", "", 36],
      ["a940", "", 8, ""],
      ["a959", ""],
      ["a95c", ""],
      ["a960", "", 9, "", 8],
      ["a980", "", 4, ""],
      ["a996", ""],
      ["a9a4", "", 75],
      ["aa40", "", 5, "", 5, "", 8],
      ["aa80", "", 7, "", 10, ""],
      ["ab40", "", 11, "", 4, "", 5, "", 4],
      ["ab80", "", 6, "", 4],
      ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
      ["ac80", "", 6, "", 12, "", 4, ""],
      ["ad40", "", 10, "", 7, "", 15, "", 12],
      ["ad80", "", 9, "", 8, "", 6, ""],
      ["ae40", "", 6, "", 7, "", 4, ""],
      ["ae80", "", 7, "", 6, "", 4, ""],
      ["af40", "", 4, ""],
      ["af80", ""],
      ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
      ["b080", "", 7, "", 8, "", 9, ""],
      ["b140", "", 4, "", 7, "", 10, ""],
      ["b180", "", 4, "", 7, "", 7, ""],
      ["b240", "", 11, "", 5, "", 11, "", 4],
      ["b280", "", 12, "", 8, "", 4, ""],
      ["b340", "", 5, ""],
      ["b380", "", 11, "", 7, "", 6, ""],
      ["b440", "", 7, "", 9],
      ["b480", "", 4, "", 5, "", 6, ""],
      ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
      ["b580", "", 6, "", 4, ""],
      ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
      ["b680", "", 6, "", 4, ""],
      ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
      ["b780", "", 6, ""],
      ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
      ["b880", "", 4, ""],
      ["b940", "", 5, "", 10, "", 6, ""],
      ["b980", "", 7, ""],
      ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
      ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
      ["bb40", "", 9, "", 36, "", 5, "", 9],
      ["bb80", "", 6, "", 4, ""],
      ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
      ["bc80", "", 14, "", 6, ""],
      ["bd40", "", 54, "", 7],
      ["bd80", "", 32, ""],
      ["be40", "", 12, "", 6, "", 42],
      ["be80", "", 32, ""],
      ["bf40", "", 62],
      ["bf80", "", 4, "", 4, "", 21, ""],
      ["c040", "", 35, "", 23, ""],
      ["c080", "", 6, "", 9, ""],
      ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
      ["c180", "", 4, "", 4, "", 5, ""],
      ["c240", "", 6, "", 5, ""],
      ["c280", "", 13, "", 5, "", 11, ""],
      ["c340", "", 5, "", 4, "", 6, ""],
      ["c380", "", 12, "", 4, ""],
      ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
      ["c480", "", 7, "", 5, "", 6, ""],
      ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
      ["c580", "", 7, "", 7, ""],
      ["c640", ""],
      ["c680", "", 4, "", 9, ""],
      ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
      ["c780", ""],
      ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
      ["c880", "", 6, "", 4, "", 4, ""],
      ["c940", "", 4, "", 7, "", 12, ""],
      ["c980", "", 4, "", 4, "", 10, ""],
      ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
      ["ca80", "", 4, "", 8, ""],
      ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
      ["cb80", "", 5, "", 6, "", 14, ""],
      ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
      ["cc80", "", 11, "", 4, "", 7, ""],
      ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
      ["cd80", ""],
      ["ce40", "", 6, "", 5, "", 7, ""],
      ["ce80", "", 4, "", 6, "", 4, ""],
      ["cf40", "", 4, "", 4, "", 6, "", 9],
      ["cf80", "", 5, "", 7, "", 4, ""],
      ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
      ["d080", "", 4, "", 4, "", 5, ""],
      ["d140", "", 4, "", 4, "", 6, "", 5],
      ["d180", "", 4, "", 4, "", 4, ""],
      ["d240", "", 8, "", 24, "", 5, "", 19, ""],
      ["d280", "", 26, ""],
      ["d340", "", 30, "", 6],
      ["d380", "", 4, "", 5, "", 21, ""],
      ["d440", "", 31, "", 8, "", 21],
      ["d480", "", 25, "", 6, ""],
      ["d540", "", 7, "", 7, "", 46],
      ["d580", "", 32, ""],
      ["d640", "", 34, "", 27],
      ["d680", "", 30, ""],
      ["d740", "", 31, "", 4, "", 25],
      ["d780", "", 24, ""],
      ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
      ["d880", "", 6, "", 20, ""],
      ["d940", "", 62],
      ["d980", "", 32, ""],
      ["da40", "", 14, "", 8, "", 4, "", 9, ""],
      ["da80", "", 12, ""],
      ["db40", "", 6, "", 7, "", 4, ""],
      ["db80", "", 4, "", 5, "", 11, ""],
      ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
      ["dc80", "", 10, "", 21, ""],
      ["dd40", "", 62],
      ["dd80", "", 32, ""],
      ["de40", "", 32, ""],
      ["de80", "", 4, ""],
      ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
      ["df80", "", 4, ""],
      ["e040", "", 19, ""],
      ["e080", "", 10, "", 6, "", 8, ""],
      ["e140", "", 4, "", 6, "", 5, "", 5, ""],
      ["e180", "", 10, "", 9, "", 8, ""],
      ["e240", "", 62],
      ["e280", "", 32, "", 5, ""],
      ["e340", "", 45, "", 16],
      ["e380", "", 7, "", 24, ""],
      ["e440", "", 5, "", 24, "", 31],
      ["e480", "", 32, ""],
      ["e540", "", 51, "", 10],
      ["e580", "", 31, ""],
      ["e640", "", 34, "", 27],
      ["e680", "", 29, ""],
      ["e740", "", 7, "", 54],
      ["e780", "", 32, "", 6, "", 4, ""],
      ["e840", "", 14, "", 43, ""],
      ["e880", "", 20, ""],
      ["e940", "", 7, "", 42],
      ["e980", "", 32, ""],
      ["ea40", "", 27, "", 6, ""],
      ["ea80", "", 4, "", 12, ""],
      ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
      ["eb80", "", 4, ""],
      ["ec40", "", 8, "", 4, "", 18, "", 7],
      ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
      ["ed40", "", 6, "", 46],
      ["ed80", "", 4, "", 23, ""],
      ["ee40", "", 62],
      ["ee80", "", 32, "", 4, "", 6, ""],
      ["ef40", "", 5, "", 37, "", 4],
      ["ef80", "", 30, "", 4, "", 8, ""],
      ["f040", "", 4, "", 28, "", 26],
      ["f080", "", 9, "", 12, "", 4, "", 6, ""],
      ["f140", "", 10, "", 47],
      ["f180", "", 32, ""],
      ["f240", "", 62],
      ["f280", "", 32, ""],
      ["f340", "", 17, "", 6, "", 4, ""],
      ["f380", "", 8, "", 6, ""],
      ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
      ["f480", "", 32, ""],
      ["f540", "", 62],
      ["f580", "", 32, ""],
      ["f640", "", 62],
      ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
      ["f740", "", 62],
      ["f780", "", 4, "", 4, ""],
      ["f840", "", 62],
      ["f880", "", 32],
      ["f940", "", 62],
      ["f980", "", 32],
      ["fa40", "", 62],
      ["fa80", "", 32],
      ["fb40", "", 27, "", 9, ""],
      ["fb80", "", 5, "", 8, "", 5, ""],
      ["fc40", "", 8, "", 4, "", 8, "", 6],
      ["fc80", "", 4, "", 5, "", 8, ""],
      ["fd40", "", 4, "", 4, "", 10, "", 38],
      ["fd80", "", 5, "", 11, "", 4, ""],
      ["fe40", ""]
    ];
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports, module) {
    module.exports = [
      ["a140", "", 62],
      ["a180", "", 32],
      ["a240", "", 62],
      ["a280", "", 32],
      ["a2ab", "", 5],
      ["a2e3", ""],
      ["a2ef", ""],
      ["a2fd", ""],
      ["a340", "", 62],
      ["a380", "", 31, ""],
      ["a440", "", 62],
      ["a480", "", 32],
      ["a4f4", "", 10],
      ["a540", "", 62],
      ["a580", "", 32],
      ["a5f7", "", 7],
      ["a640", "", 62],
      ["a680", "", 32],
      ["a6b9", "", 7],
      ["a6d9", "", 6],
      ["a6ec", ""],
      ["a6f3", ""],
      ["a6f6", "", 8],
      ["a740", "", 62],
      ["a780", "", 32],
      ["a7c2", "", 14],
      ["a7f2", "", 12],
      ["a896", "", 10],
      ["a8bc", ""],
      ["a8bf", ""],
      ["a8c1", ""],
      ["a8ea", "", 20],
      ["a958", ""],
      ["a95b", ""],
      ["a95d", ""],
      ["a989", "", 11],
      ["a997", "", 12],
      ["a9f0", "", 14],
      ["aaa1", "", 93],
      ["aba1", "", 93],
      ["aca1", "", 93],
      ["ada1", "", 93],
      ["aea1", "", 93],
      ["afa1", "", 93],
      ["d7fa", "", 4],
      ["f8a1", "", 93],
      ["f9a1", "", 93],
      ["faa1", "", 93],
      ["fba1", "", 93],
      ["fca1", "", 93],
      ["fda1", "", 93],
      ["fe50", ""],
      ["fe80", "", 6, "", 93],
      ["8135f437", ""]
    ];
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports, module) {
    module.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/tables/cp949.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127],
      ["8141", "", 4, "", 6, ""],
      ["8161", "", 9, "", 5, ""],
      ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
      ["8241", "", 7, "", 5],
      ["8261", "", 6, "", 5, ""],
      ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
      ["8341", "", 5, "", 5, "", 7],
      ["8361", "", 18, ""],
      ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
      ["8441", "", 5, "", 8],
      ["8461", "", 18],
      ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
      ["8541", "", 5, "", 4, "", 6, "", 4],
      ["8561", "", 5, "", 5, "", 6, ""],
      ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
      ["8641", "", 6, "", 5, ""],
      ["8661", "", 6, "", 10],
      ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
      ["8741", "", 9, "", 15],
      ["8761", "", 18, ""],
      ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
      ["8841", "", 4, "", 5, "", 6, "", 4],
      ["8861", "", 4, ""],
      ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
      ["8941", "", 6, "", 5, ""],
      ["8961", "", 10, "", 5, ""],
      ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
      ["8a41", "", 10, "", 6, ""],
      ["8a61", "", 4, "", 18, ""],
      ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
      ["8b41", "", 5, "", 4, "", 6, ""],
      ["8b61", "", 6, "", 8],
      ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
      ["8c41", "", 15, "", 4],
      ["8c61", "", 6, "", 5, "", 6, "", 5],
      ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
      ["8d41", "", 16, "", 8],
      ["8d61", "", 17, ""],
      ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
      ["8e41", "", 6, "", 5, "", 8],
      ["8e61", "", 4, "", 19],
      ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
      ["8f41", "", 7, "", 17],
      ["8f61", "", 7, "", 6, "", 4],
      ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
      ["9041", "", 6, "", 5, ""],
      ["9061", "", 5, "", 15],
      ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
      ["9141", "", 6, "", 5],
      ["9161", "", 9, "", 5],
      ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
      ["9241", "", 7, "", 4, ""],
      ["9261", "", 7, "", 7, "", 4],
      ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
      ["9341", "", 4, ""],
      ["9361", "", 6, "", 8],
      ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
      ["9441", "", 5, "", 5, "", 8],
      ["9461", "", 5, "", 6, "", 12],
      ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
      ["9541", "", 11, "", 5, ""],
      ["9561", "", 6, "", 5, ""],
      ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
      ["9641", "", 23, ""],
      ["9661", "", 6, "", 5, "", 8],
      ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
      ["9741", "", 16, "", 8],
      ["9761", "", 17, "", 7],
      ["9781", "", 11, "", 5, "", 6, "", 89, ""],
      ["9841", "", 16, "", 5, ""],
      ["9861", "", 6, "", 15],
      ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
      ["9941", "", 6, "", 5, ""],
      ["9961", "", 6, "", 5, ""],
      ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
      ["9a41", "", 16],
      ["9a61", "", 6, "", 6, ""],
      ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
      ["9b41", "", 6, "", 8],
      ["9b61", "", 17, "", 7],
      ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
      ["9c41", "", 4, "", 5, "", 5],
      ["9c61", "", 8, "", 6, "", 9],
      ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
      ["9d41", "", 13, "", 8],
      ["9d61", "", 25],
      ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
      ["9e41", "", 7, "", 9, ""],
      ["9e61", "", 4, "", 6, ""],
      ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
      ["9f41", "", 5, "", 4, "", 5, ""],
      ["9f61", "", 6, "", 5, ""],
      ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
      ["a041", "", 5, "", 6, ""],
      ["a061", "", 5, "", 13],
      ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
      ["a141", "", 18, ""],
      ["a161", "", 6, "", 5, ""],
      ["a181", "", 14, "", 5, "", 4, "", 9, ""],
      ["a241", "", 5, "", 18],
      ["a261", "", 6, "", 18],
      ["a281", "", 7, "", 6, "", 7, ""],
      ["a341", "", 6, "", 10, ""],
      ["a361", "", 6, "", 16],
      ["a381", "", 16, "", 4, "", 58, "", 32, ""],
      ["a441", "", 5, ""],
      ["a461", "", 5, "", 12],
      ["a481", "", 28, "", 93],
      ["a541", "", 4, "", 6, "", 5, ""],
      ["a561", "", 17, "", 5, ""],
      ["a581", "", 16, "", 14, "", 9],
      ["a5b0", "", 9],
      ["a5c1", "", 16, "", 6],
      ["a5e1", "", 16, "", 6],
      ["a641", "", 19, ""],
      ["a661", "", 5, "", 5, "", 6],
      ["a681", "", 6, "", 18, "", 7],
      ["a741", "", 4, "", 6, "", 7],
      ["a761", "", 22, ""],
      ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
      ["a841", "", 10, "", 14],
      ["a861", "", 18, "", 6],
      ["a881", "", 19, "", 11, ""],
      ["a8a6", ""],
      ["a8a8", ""],
      ["a8b1", "", 27, "", 25, "", 14, ""],
      ["a941", "", 14, "", 10],
      ["a961", "", 18],
      ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
      ["aa41", "", 6, "", 4, ""],
      ["aa61", "", 4, "", 5, "", 6, ""],
      ["aa81", "", 29, "", 82],
      ["ab41", "", 6, "", 5, ""],
      ["ab61", "", 6, "", 5, "", 5],
      ["ab81", "", 8, "", 6, "", 12, "", 85],
      ["ac41", "", 5, "", 6, ""],
      ["ac61", "", 11, "", 4],
      ["ac81", "", 28, "", 5, "", 25],
      ["acd1", "", 5, "", 25],
      ["ad41", "", 6, "", 5, "", 7],
      ["ad61", "", 6, "", 10, ""],
      ["ad81", "", 5, "", 18, ""],
      ["ae41", "", 5, "", 16],
      ["ae61", "", 5, "", 6, "", 4],
      ["ae81", "", 6, "", 5, ""],
      ["af41", "", 19],
      ["af61", "", 13, "", 5, ""],
      ["af81", "", 5, "", 6, "", 5, ""],
      ["b041", "", 5, "", 5, "", 12],
      ["b061", "", 5, "", 19],
      ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
      ["b141", "", 6, "", 5, ""],
      ["b161", "", 6, "", 5, "", 11],
      ["b181", "", 14, "", 6, ""],
      ["b241", "", 6, "", 5, ""],
      ["b261", "", 18, "", 5, ""],
      ["b281", "", 5, "", 18, "", 6, ""],
      ["b341", "", 19, ""],
      ["b361", "", 5, "", 5, "", 5],
      ["b381", "", 5, "", 5, "", 19, "", 4, ""],
      ["b441", "", 5, "", 6, "", 5],
      ["b461", "", 6, "", 10, ""],
      ["b481", "", 6, "", 18, "", 4, "", 4, ""],
      ["b541", "", 14, "", 5],
      ["b561", "", 5, "", 5, "", 4],
      ["b581", "", 6, "", 5, "", 11, ""],
      ["b641", "", 7, "", 17],
      ["b661", "", 15, ""],
      ["b681", "", 5, "", 6, "", 5, ""],
      ["b741", "", 13, "", 6, ""],
      ["b761", "", 20, ""],
      ["b781", "", 6, "", 14, ""],
      ["b841", "", 7, "", 17],
      ["b861", "", 8, "", 13],
      ["b881", "", 5, "", 24, "", 4, ""],
      ["b941", "", 6, "", 5, ""],
      ["b961", "", 14, "", 6, ""],
      ["b981", "", 22, "", 4, "", 4, ""],
      ["ba41", "", 5, "", 6, ""],
      ["ba61", "", 5, "", 4, "", 5],
      ["ba81", "", 6, "", 9, ""],
      ["bb41", "", 4, "", 5, "", 4, ""],
      ["bb61", "", 6, "", 5, ""],
      ["bb81", "", 31, ""],
      ["bc41", "", 17, ""],
      ["bc61", "", 5, "", 6, ""],
      ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
      ["bd41", "", 7, "", 7, ""],
      ["bd61", "", 5, "", 13],
      ["bd81", "", 5, "", 25, ""],
      ["be41", "", 7, "", 14],
      ["be61", "", 7, "", 7, ""],
      ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
      ["bf41", "", 10, "", 14],
      ["bf61", "", 18, ""],
      ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
      ["c041", "", 5, "", 6, "", 5],
      ["c061", "", 25],
      ["c081", "", 6, "", 5, "", 7, ""],
      ["c141", "", 5, "", 6, ""],
      ["c161", "", 19, ""],
      ["c181", "", 31, ""],
      ["c241", "", 4, "", 5, ""],
      ["c261", "", 4, "", 5, "", 6, ""],
      ["c281", "", 5, "", 7, "", 9, ""],
      ["c341", "", 4],
      ["c361", "", 4, "", 5, "", 11],
      ["c381", "", 5, "", 7, "", 5, ""],
      ["c441", "", 7, "", 7, ""],
      ["c461", "", 5, "", 4],
      ["c481", "", 5, "", 11, ""],
      ["c541", "", 6, "", 5, ""],
      ["c561", "", 6, "", 5, "", 4],
      ["c581", "", 6, "", 5, ""],
      ["c641", "", 6, "", 5],
      ["c6a1", ""],
      ["c7a1", ""],
      ["c8a1", ""],
      ["caa1", ""],
      ["cba1", ""],
      ["cca1", ""],
      ["cda1", ""],
      ["cea1", ""],
      ["cfa1", ""],
      ["d0a1", ""],
      ["d1a1", "", 5, "", 4, ""],
      ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
      ["d3a1", ""],
      ["d4a1", ""],
      ["d5a1", ""],
      ["d6a1", ""],
      ["d7a1", ""],
      ["d8a1", ""],
      ["d9a1", ""],
      ["daa1", ""],
      ["dba1", ""],
      ["dca1", ""],
      ["dda1", ""],
      ["dea1", ""],
      ["dfa1", ""],
      ["e0a1", ""],
      ["e1a1", ""],
      ["e2a1", ""],
      ["e3a1", ""],
      ["e4a1", ""],
      ["e5a1", ""],
      ["e6a1", ""],
      ["e7a1", ""],
      ["e8a1", ""],
      ["e9a1", ""],
      ["eaa1", ""],
      ["eba1", ""],
      ["eca1", ""],
      ["eda1", ""],
      ["eea1", ""],
      ["efa1", ""],
      ["f0a1", ""],
      ["f1a1", ""],
      ["f2a1", ""],
      ["f3a1", ""],
      ["f4a1", ""],
      ["f5a1", ""],
      ["f6a1", ""],
      ["f7a1", ""],
      ["f8a1", ""],
      ["f9a1", ""],
      ["faa1", ""],
      ["fba1", ""],
      ["fca1", ""],
      ["fda1", ""]
    ];
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/tables/cp950.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127],
      ["a140", ""],
      ["a1a1", "", 4, ""],
      ["a240", "", 7, ""],
      ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
      ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
      ["a3a1", "", 25, ""],
      ["a3e1", ""],
      ["a440", ""],
      ["a4a1", ""],
      ["a540", ""],
      ["a5a1", ""],
      ["a640", ""],
      ["a6a1", ""],
      ["a740", ""],
      ["a7a1", ""],
      ["a840", ""],
      ["a8a1", ""],
      ["a940", ""],
      ["a9a1", ""],
      ["aa40", ""],
      ["aaa1", ""],
      ["ab40", ""],
      ["aba1", ""],
      ["ac40", ""],
      ["aca1", ""],
      ["ad40", ""],
      ["ada1", ""],
      ["ae40", ""],
      ["aea1", ""],
      ["af40", ""],
      ["afa1", ""],
      ["b040", ""],
      ["b0a1", ""],
      ["b140", ""],
      ["b1a1", ""],
      ["b240", ""],
      ["b2a1", ""],
      ["b340", ""],
      ["b3a1", ""],
      ["b440", ""],
      ["b4a1", ""],
      ["b540", ""],
      ["b5a1", ""],
      ["b640", ""],
      ["b6a1", ""],
      ["b740", ""],
      ["b7a1", ""],
      ["b840", ""],
      ["b8a1", ""],
      ["b940", ""],
      ["b9a1", ""],
      ["ba40", ""],
      ["baa1", ""],
      ["bb40", ""],
      ["bba1", ""],
      ["bc40", ""],
      ["bca1", ""],
      ["bd40", ""],
      ["bda1", ""],
      ["be40", ""],
      ["bea1", ""],
      ["bf40", ""],
      ["bfa1", ""],
      ["c040", ""],
      ["c0a1", ""],
      ["c140", ""],
      ["c1a1", ""],
      ["c240", ""],
      ["c2a1", ""],
      ["c340", ""],
      ["c3a1", ""],
      ["c440", ""],
      ["c4a1", ""],
      ["c540", ""],
      ["c5a1", ""],
      ["c640", ""],
      ["c940", ""],
      ["c9a1", ""],
      ["ca40", ""],
      ["caa1", ""],
      ["cb40", ""],
      ["cba1", ""],
      ["cc40", ""],
      ["cca1", ""],
      ["cd40", ""],
      ["cda1", ""],
      ["ce40", ""],
      ["cea1", ""],
      ["cf40", ""],
      ["cfa1", ""],
      ["d040", ""],
      ["d0a1", ""],
      ["d140", ""],
      ["d1a1", ""],
      ["d240", ""],
      ["d2a1", ""],
      ["d340", ""],
      ["d3a1", ""],
      ["d440", ""],
      ["d4a1", ""],
      ["d540", ""],
      ["d5a1", ""],
      ["d640", ""],
      ["d6a1", ""],
      ["d740", ""],
      ["d7a1", ""],
      ["d840", ""],
      ["d8a1", ""],
      ["d940", ""],
      ["d9a1", ""],
      ["da40", ""],
      ["daa1", ""],
      ["db40", ""],
      ["dba1", ""],
      ["dc40", ""],
      ["dca1", ""],
      ["dd40", ""],
      ["dda1", ""],
      ["de40", ""],
      ["dea1", ""],
      ["df40", ""],
      ["dfa1", ""],
      ["e040", ""],
      ["e0a1", ""],
      ["e140", ""],
      ["e1a1", ""],
      ["e240", ""],
      ["e2a1", ""],
      ["e340", ""],
      ["e3a1", ""],
      ["e440", ""],
      ["e4a1", ""],
      ["e540", ""],
      ["e5a1", ""],
      ["e640", ""],
      ["e6a1", ""],
      ["e740", ""],
      ["e7a1", ""],
      ["e840", ""],
      ["e8a1", ""],
      ["e940", ""],
      ["e9a1", ""],
      ["ea40", ""],
      ["eaa1", ""],
      ["eb40", ""],
      ["eba1", ""],
      ["ec40", ""],
      ["eca1", ""],
      ["ed40", ""],
      ["eda1", ""],
      ["ee40", ""],
      ["eea1", ""],
      ["ef40", ""],
      ["efa1", ""],
      ["f040", ""],
      ["f0a1", ""],
      ["f140", ""],
      ["f1a1", ""],
      ["f240", ""],
      ["f2a1", ""],
      ["f340", ""],
      ["f3a1", ""],
      ["f440", ""],
      ["f4a1", ""],
      ["f540", ""],
      ["f5a1", ""],
      ["f640", ""],
      ["f6a1", ""],
      ["f740", ""],
      ["f7a1", ""],
      ["f840", ""],
      ["f8a1", ""],
      ["f940", ""],
      ["f9a1", ""]
    ];
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/tables/big5-added.json"(exports, module) {
    module.exports = [
      ["8740", ""],
      ["8767", ""],
      ["87a1", ""],
      ["8840", "", 4, ""],
      ["88a1", ""],
      ["8940", ""],
      ["8943", ""],
      ["8946", ""],
      ["894c", ""],
      ["89a1", ""],
      ["89ab", ""],
      ["89b0", ""],
      ["89b5", ""],
      ["89c1", ""],
      ["89c5", ""],
      ["8a40", ""],
      ["8a43", ""],
      ["8a64", ""],
      ["8a76", ""],
      ["8aa1", ""],
      ["8aac", ""],
      ["8ab2", ""],
      ["8abb", ""],
      ["8ac9", ""],
      ["8ace", ""],
      ["8adf", ""],
      ["8af6", ""],
      ["8b40", ""],
      ["8b55", ""],
      ["8ba1", ""],
      ["8bde", ""],
      ["8c40", ""],
      ["8ca1", ""],
      ["8ca7", ""],
      ["8cc9", ""],
      ["8cce", ""],
      ["8ce6", ""],
      ["8d40", ""],
      ["8d42", ""],
      ["8da1", ""],
      ["8e40", ""],
      ["8ea1", ""],
      ["8f40", ""],
      ["8fa1", ""],
      ["9040", ""],
      ["90a1", ""],
      ["9140", ""],
      ["91a1", ""],
      ["9240", ""],
      ["92a1", ""],
      ["9340", ""],
      ["93a1", ""],
      ["9440", ""],
      ["94a1", ""],
      ["9540", ""],
      ["95a1", ""],
      ["9640", ""],
      ["96a1", ""],
      ["9740", ""],
      ["97a1", ""],
      ["9840", ""],
      ["98a1", ""],
      ["9940", ""],
      ["99a1", ""],
      ["9a40", ""],
      ["9aa1", ""],
      ["9b40", ""],
      ["9b62", ""],
      ["9ba1", ""],
      ["9c40", ""],
      ["9ca1", ""],
      ["9d40", ""],
      ["9da1", ""],
      ["9e40", ""],
      ["9ea1", ""],
      ["9ead", ""],
      ["9ec5", ""],
      ["9ef5", ""],
      ["9f40", ""],
      ["9f4f", ""],
      ["9fa1", ""],
      ["9fae", ""],
      ["9fb2", ""],
      ["9fc1", ""],
      ["9fc9", ""],
      ["9fdb", ""],
      ["9fe7", ""],
      ["9feb", ""],
      ["9ff0", ""],
      ["a040", ""],
      ["a055", ""],
      ["a058", ""],
      ["a05b", ""],
      ["a063", ""],
      ["a073", ""],
      ["a0a1", ""],
      ["a0a6", ""],
      ["a0ae", ""],
      ["a0b0", ""],
      ["a0d4", ""],
      ["a0e2", ""],
      ["a3c0", "", 31, ""],
      ["c6a1", "", 9, "", 9, "", 9, "", 23],
      ["c740", "", 58, ""],
      ["c7a1", "", 81, "", 5, "", 4],
      ["c840", "", 26, "", 25, ""],
      ["c8a1", ""],
      ["c8cd", ""],
      ["c8f5", ""],
      ["f9fe", ""],
      ["fa40", ""],
      ["faa1", ""],
      ["fb40", ""],
      ["fba1", ""],
      ["fc40", ""],
      ["fca1", ""],
      ["fd40", ""],
      ["fda1", ""],
      ["fe40", ""],
      ["fea1", ""]
    ];
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/dbcs-data.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    module.exports = {
      // == Japanese/ShiftJIS ====================================================
      // All japanese encodings are based on JIS X set of standards:
      // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
      // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
      //              Has several variations in 1978, 1983, 1990 and 1997.
      // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
      // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
      //              2 planes, first is superset of 0208, second - revised 0212.
      //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
      // Byte encodings are:
      //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
      //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
      //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
      //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
      //               0x00-0x7F       - lower part of 0201
      //               0x8E, 0xA1-0xDF - upper part of 0201
      //               (0xA1-0xFE)x2   - 0208 plane (94x94).
      //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
      //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
      //               Used as-is in ISO2022 family.
      //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
      //                0201-1976 Roman, 0208-1978, 0208-1983.
      //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
      //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
      //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
      //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
      //
      // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
      //
      // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
      "shiftjis": {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "": 92, "": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      "csshiftjis": "shiftjis",
      "mskanji": "shiftjis",
      "sjis": "shiftjis",
      "windows31j": "shiftjis",
      "ms31j": "shiftjis",
      "xsjis": "shiftjis",
      "windows932": "shiftjis",
      "ms932": "shiftjis",
      "932": "shiftjis",
      "cp932": "shiftjis",
      "eucjp": {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "": 92, "": 126 }
      },
      // TODO: KDDI extension to Shift_JIS
      // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
      // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
      // == Chinese/GBK ==========================================================
      // http://en.wikipedia.org/wiki/GBK
      // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
      // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
      "gb2312": "cp936",
      "gb231280": "cp936",
      "gb23121980": "cp936",
      "csgb2312": "cp936",
      "csiso58gb231280": "cp936",
      "euccn": "cp936",
      // Microsoft's CP936 is a subset and approximation of GBK.
      "windows936": "cp936",
      "ms936": "cp936",
      "936": "cp936",
      "cp936": {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
      "gbk": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      "xgbk": "gbk",
      "isoir58": "gbk",
      // GB18030 is an algorithmic extension of GBK.
      // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
      // http://icu-project.org/docs/papers/gb18030.html
      // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
      // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
      "gb18030": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "": 41699 }
      },
      "chinese": "gb18030",
      // == Korean ===============================================================
      // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
      "windows949": "cp949",
      "ms949": "cp949",
      "949": "cp949",
      "cp949": {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      "cseuckr": "cp949",
      "csksc56011987": "cp949",
      "euckr": "cp949",
      "isoir149": "cp949",
      "korean": "cp949",
      "ksc56011987": "cp949",
      "ksc56011989": "cp949",
      "ksc5601": "cp949",
      // == Big5/Taiwan/Hong Kong ================================================
      // There are lots of tables for Big5 and cp950. Please see the following links for history:
      // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
      // Variations, in roughly number of defined chars:
      //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
      //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
      //  * Big5-2003 (Taiwan standard) almost superset of cp950.
      //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
      //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
      //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
      //    Plus, it has 4 combining sequences.
      //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
      //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
      //    Implementations are not consistent within browsers; sometimes labeled as just big5.
      //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
      //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
      //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
      //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
      //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
      // 
      // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
      // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
      "windows950": "cp950",
      "ms950": "cp950",
      "950": "cp950",
      "cp950": {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
      "big5": "big5hkscs",
      "big5hkscs": {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [
          // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
          // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
          // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
          36457,
          36463,
          36478,
          36523,
          36532,
          36557,
          36560,
          36695,
          36713,
          36718,
          36811,
          36862,
          36973,
          36986,
          37060,
          37084,
          37105,
          37311,
          37551,
          37552,
          37553,
          37554,
          37585,
          37959,
          38090,
          38361,
          38652,
          39285,
          39798,
          39800,
          39803,
          39878,
          39902,
          39916,
          39926,
          40002,
          40019,
          40034,
          40040,
          40043,
          40055,
          40124,
          40125,
          40144,
          40279,
          40282,
          40388,
          40431,
          40443,
          40617,
          40687,
          40701,
          40800,
          40907,
          41079,
          41180,
          41183,
          36812,
          37576,
          38468,
          38637,
          // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
          41636,
          41637,
          41639,
          41638,
          41676,
          41678
        ]
      },
      "cnbig5": "big5hkscs",
      "csbig5": "big5hkscs",
      "xxbig5": "big5hkscs"
    };
  }
});

// node_modules/tedious/node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/encodings/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var modules = [
      require_internal(),
      require_utf32(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (i = 0; i < modules.length; i++) {
      module = modules[i];
      for (enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
    var module;
    var enc;
    var i;
  }
});

// node_modules/tedious/node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/lib/streams.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safer().Buffer;
    module.exports = function(stream_module) {
      var Transform = stream_module.Transform;
      function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false;
        Transform.call(this, options);
      }
      IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
      });
      IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != "string")
          return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length)
            this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length)
            this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on("error", cb);
        this.on("data", function(chunk) {
          chunks.push(chunk);
        });
        this.on("end", function() {
          cb(null, Buffer2.concat(chunks));
        });
        return this;
      };
      function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = "utf8";
        Transform.call(this, options);
      }
      IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
      });
      IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
          return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length)
            this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length)
            this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = "";
        this.on("error", cb);
        this.on("data", function(chunk) {
          res += chunk;
        });
        this.on("end", function() {
          cb(null, res);
        });
        return this;
      };
      return {
        IconvLiteEncoderStream,
        IconvLiteDecoderStream
      };
    };
  }
});

// browser-external:stream
var require_stream3 = __commonJS({
  "browser-external:stream"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tedious/node_modules/iconv-lite/lib/index.js
var require_lib = __commonJS({
  "node_modules/tedious/node_modules/iconv-lite/lib/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var Buffer2 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = require_encodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv.supportsStreams)
        return;
      var streams = require_streams()(stream_module2);
      iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require_stream3();
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
    if (false) {
      console.error("iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// node_modules/tedious/lib/data-types/text.js
var require_text = __commonJS({
  "node_modules/tedious/lib/data-types/text.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var Text = {
      id: 35,
      type: "TEXT",
      name: "Text",
      hasTableName: true,
      declaration: function() {
        return "text";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(value.length, 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        yield value;
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports.default = Text;
    module.exports = Text;
  }
});

// node_modules/tedious/lib/guid-parser.js
var require_guid_parser = __commonJS({
  "node_modules/tedious/lib/guid-parser.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bufferToLowerCaseGuid = bufferToLowerCaseGuid;
    exports.bufferToUpperCaseGuid = bufferToUpperCaseGuid;
    exports.guidToArray = guidToArray;
    var UPPER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0A", "0B", "0C", "0D", "0E", "0F", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1A", "1B", "1C", "1D", "1E", "1F", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2A", "2B", "2C", "2D", "2E", "2F", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3A", "3B", "3C", "3D", "3E", "3F", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4A", "4B", "4C", "4D", "4E", "4F", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5A", "5B", "5C", "5D", "5E", "5F", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6A", "6B", "6C", "6D", "6E", "6F", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7A", "7B", "7C", "7D", "7E", "7F", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8A", "8B", "8C", "8D", "8E", "8F", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9A", "9B", "9C", "9D", "9E", "9F", "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF", "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF", "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF", "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF", "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF", "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"];
    var LOWER_CASE_MAP = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
    function bufferToUpperCaseGuid(buffer) {
      return UPPER_CASE_MAP[buffer[3]] + UPPER_CASE_MAP[buffer[2]] + UPPER_CASE_MAP[buffer[1]] + UPPER_CASE_MAP[buffer[0]] + "-" + UPPER_CASE_MAP[buffer[5]] + UPPER_CASE_MAP[buffer[4]] + "-" + UPPER_CASE_MAP[buffer[7]] + UPPER_CASE_MAP[buffer[6]] + "-" + UPPER_CASE_MAP[buffer[8]] + UPPER_CASE_MAP[buffer[9]] + "-" + UPPER_CASE_MAP[buffer[10]] + UPPER_CASE_MAP[buffer[11]] + UPPER_CASE_MAP[buffer[12]] + UPPER_CASE_MAP[buffer[13]] + UPPER_CASE_MAP[buffer[14]] + UPPER_CASE_MAP[buffer[15]];
    }
    function bufferToLowerCaseGuid(buffer) {
      return LOWER_CASE_MAP[buffer[3]] + LOWER_CASE_MAP[buffer[2]] + LOWER_CASE_MAP[buffer[1]] + LOWER_CASE_MAP[buffer[0]] + "-" + LOWER_CASE_MAP[buffer[5]] + LOWER_CASE_MAP[buffer[4]] + "-" + LOWER_CASE_MAP[buffer[7]] + LOWER_CASE_MAP[buffer[6]] + "-" + LOWER_CASE_MAP[buffer[8]] + LOWER_CASE_MAP[buffer[9]] + "-" + LOWER_CASE_MAP[buffer[10]] + LOWER_CASE_MAP[buffer[11]] + LOWER_CASE_MAP[buffer[12]] + LOWER_CASE_MAP[buffer[13]] + LOWER_CASE_MAP[buffer[14]] + LOWER_CASE_MAP[buffer[15]];
    }
    var CHARCODEMAP = {};
    var hexDigits2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"].map((d) => d.charCodeAt(0));
    for (let i = 0; i < hexDigits2.length; i++) {
      const map = CHARCODEMAP[hexDigits2[i]] = {};
      for (let j = 0; j < hexDigits2.length; j++) {
        const hex = String.fromCharCode(hexDigits2[i], hexDigits2[j]);
        const value = parseInt(hex, 16);
        map[hexDigits2[j]] = value;
      }
    }
    function guidToArray(guid) {
      return [CHARCODEMAP[guid.charCodeAt(6)][guid.charCodeAt(7)], CHARCODEMAP[guid.charCodeAt(4)][guid.charCodeAt(5)], CHARCODEMAP[guid.charCodeAt(2)][guid.charCodeAt(3)], CHARCODEMAP[guid.charCodeAt(0)][guid.charCodeAt(1)], CHARCODEMAP[guid.charCodeAt(11)][guid.charCodeAt(12)], CHARCODEMAP[guid.charCodeAt(9)][guid.charCodeAt(10)], CHARCODEMAP[guid.charCodeAt(16)][guid.charCodeAt(17)], CHARCODEMAP[guid.charCodeAt(14)][guid.charCodeAt(15)], CHARCODEMAP[guid.charCodeAt(19)][guid.charCodeAt(20)], CHARCODEMAP[guid.charCodeAt(21)][guid.charCodeAt(22)], CHARCODEMAP[guid.charCodeAt(24)][guid.charCodeAt(25)], CHARCODEMAP[guid.charCodeAt(26)][guid.charCodeAt(27)], CHARCODEMAP[guid.charCodeAt(28)][guid.charCodeAt(29)], CHARCODEMAP[guid.charCodeAt(30)][guid.charCodeAt(31)], CHARCODEMAP[guid.charCodeAt(32)][guid.charCodeAt(33)], CHARCODEMAP[guid.charCodeAt(34)][guid.charCodeAt(35)]];
    }
  }
});

// node_modules/tedious/lib/data-types/uniqueidentifier.js
var require_uniqueidentifier = __commonJS({
  "node_modules/tedious/lib/data-types/uniqueidentifier.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _guidParser = require_guid_parser();
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([16]);
    var UniqueIdentifier = {
      id: 36,
      type: "GUIDN",
      name: "UniqueIdentifier",
      declaration: function() {
        return "uniqueidentifier";
      },
      resolveLength: function() {
        return 16;
      },
      generateTypeInfo() {
        return Buffer.from([this.id, 16]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from((0, _guidParser.guidToArray)(parameter.value));
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
          throw new TypeError("Invalid GUID.");
        }
        return value;
      }
    };
    var _default = exports.default = UniqueIdentifier;
    module.exports = UniqueIdentifier;
  }
});

// node_modules/tedious/lib/data-types/ntext.js
var require_ntext = __commonJS({
  "node_modules/tedious/lib/data-types/ntext.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255, 255, 255]);
    var NText = {
      id: 99,
      type: "NTEXT",
      name: "NText",
      hasTableName: true,
      declaration: function() {
        return "ntext";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return -1;
        }
      },
      generateTypeInfo(parameter, _options) {
        const buffer = Buffer.alloc(10);
        buffer.writeUInt8(this.id, 0);
        buffer.writeInt32LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(4);
        buffer.writeInt32LE(Buffer.byteLength(parameter.value, "ucs2"), 0);
        return buffer;
      },
      generateParameterData: function* (parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value.toString(), "ucs2");
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports.default = NText;
    module.exports = NText;
  }
});

// node_modules/tedious/lib/data-types/varbinary.js
var require_varbinary = __commonJS({
  "node_modules/tedious/lib/data-types/varbinary.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarBinary = {
      id: 165,
      type: "BIGVARBIN",
      name: "VarBinary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varbinary(" + length + ")";
        } else {
          return "varbinary(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (!Buffer.isBuffer(value)) {
          value = value.toString();
        }
        const length = Buffer.byteLength(value, "ucs2");
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (Buffer.isBuffer(value)) {
            yield value;
          } else {
            yield Buffer.from(value.toString(), "ucs2");
          }
        } else {
          if (!Buffer.isBuffer(value)) {
            value = value.toString();
          }
          const length = Buffer.byteLength(value, "ucs2");
          if (length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(length, 0);
            yield buffer;
            if (Buffer.isBuffer(value)) {
              yield value;
            } else {
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports.default = VarBinary;
    module.exports = VarBinary;
  }
});

// node_modules/tedious/lib/data-types/varchar.js
var require_varchar = __commonJS({
  "node_modules/tedious/lib/data-types/varchar.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var VarChar = {
      id: 167,
      type: "BIGVARCHR",
      name: "VarChar",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "varchar(" + length + ")";
        } else {
          return "varchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        if (parameter.length <= this.maximumLength) {
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(value.length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return;
        }
        if (parameter.length <= this.maximumLength) {
          yield value;
        } else {
          if (value.length > 0) {
            const buffer = Buffer.alloc(4);
            buffer.writeUInt32LE(value.length, 0);
            yield buffer;
            yield value;
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports.default = VarChar;
    module.exports = VarChar;
  }
});

// node_modules/tedious/lib/data-types/binary.js
var require_binary = __commonJS({
  "node_modules/tedious/lib/data-types/binary.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Binary = {
      id: 173,
      type: "BIGBinary",
      name: "Binary",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        return "binary(" + length + ")";
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (value != null) {
          return value.length;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(3);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(parameter.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield parameter.value.slice(0, parameter.length !== void 0 ? Math.min(parameter.length, this.maximumLength) : this.maximumLength);
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!Buffer.isBuffer(value)) {
          throw new TypeError("Invalid buffer.");
        }
        return value;
      }
    };
    var _default = exports.default = Binary;
    module.exports = Binary;
  }
});

// node_modules/tedious/lib/data-types/char.js
var require_char = __commonJS({
  "node_modules/tedious/lib/data-types/char.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _iconvLite = _interopRequireDefault(require_lib());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([255, 255]);
    var Char = {
      id: 175,
      type: "BIGCHAR",
      name: "Char",
      maximumLength: 8e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "char(" + length + ")";
        } else {
          return "char(" + this.maximumLength + ")";
        }
      },
      // ParameterData<any> is temporary solution. TODO: need to understand what type ParameterData<...> can be.
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          return value.length || 1;
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        const value = parameter.value;
        if (value == null) {
          return NULL_LENGTH;
        }
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(value.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        yield Buffer.from(parameter.value, "ascii");
      },
      validate: function(value, collation) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        if (!collation) {
          throw new Error("No collation was set by the server for the current connection.");
        }
        if (!collation.codepage) {
          throw new Error("The collation set by the server has no associated encoding.");
        }
        return _iconvLite.default.encode(value, collation.codepage);
      }
    };
    var _default = exports.default = Char;
    module.exports = Char;
  }
});

// node_modules/tedious/lib/data-types/nvarchar.js
var require_nvarchar = __commonJS({
  "node_modules/tedious/lib/data-types/nvarchar.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var MAX = (1 << 16) - 1;
    var UNKNOWN_PLP_LEN = Buffer.from([254, 255, 255, 255, 255, 255, 255, 255]);
    var PLP_TERMINATOR = Buffer.from([0, 0, 0, 0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var MAX_NULL_LENGTH = Buffer.from([255, 255, 255, 255, 255, 255, 255, 255]);
    var NVarChar = {
      id: 231,
      type: "NVARCHAR",
      name: "NVarChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (value != null) {
          length = value.toString().length || 1;
        } else if (value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length <= this.maximumLength) {
          return "nvarchar(" + length + ")";
        } else {
          return "nvarchar(max)";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (value != null) {
          if (Buffer.isBuffer(value)) {
            return value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        if (parameter.length <= this.maximumLength) {
          buffer.writeUInt16LE(parameter.length * 2, 1);
        } else {
          buffer.writeUInt16LE(MAX, 1);
        }
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          if (parameter.length <= this.maximumLength) {
            return NULL_LENGTH;
          } else {
            return MAX_NULL_LENGTH;
          }
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          let length;
          if (value instanceof Buffer) {
            length = value.length;
          } else {
            value = value.toString();
            length = Buffer.byteLength(value, "ucs2");
          }
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          return UNKNOWN_PLP_LEN;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        let value = parameter.value;
        if (parameter.length <= this.maximumLength) {
          if (value instanceof Buffer) {
            yield value;
          } else {
            value = value.toString();
            yield Buffer.from(value, "ucs2");
          }
        } else {
          if (value instanceof Buffer) {
            const length = value.length;
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield value;
            }
          } else {
            value = value.toString();
            const length = Buffer.byteLength(value, "ucs2");
            if (length > 0) {
              const buffer = Buffer.alloc(4);
              buffer.writeUInt32LE(length, 0);
              yield buffer;
              yield Buffer.from(value, "ucs2");
            }
          }
          yield PLP_TERMINATOR;
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports.default = NVarChar;
    module.exports = NVarChar;
  }
});

// node_modules/tedious/lib/data-types/nchar.js
var require_nchar = __commonJS({
  "node_modules/tedious/lib/data-types/nchar.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var NULL_LENGTH = Buffer.from([255, 255]);
    var NChar = {
      id: 239,
      type: "NCHAR",
      name: "NChar",
      maximumLength: 4e3,
      declaration: function(parameter) {
        const value = parameter.value;
        let length;
        if (parameter.length) {
          length = parameter.length;
        } else if (parameter.value != null) {
          length = value.toString().length || 1;
        } else if (parameter.value === null && !parameter.output) {
          length = 1;
        } else {
          length = this.maximumLength;
        }
        if (length < this.maximumLength) {
          return "nchar(" + length + ")";
        } else {
          return "nchar(" + this.maximumLength + ")";
        }
      },
      resolveLength: function(parameter) {
        const value = parameter.value;
        if (parameter.length != null) {
          return parameter.length;
        } else if (parameter.value != null) {
          if (Buffer.isBuffer(parameter.value)) {
            return parameter.value.length / 2 || 1;
          } else {
            return value.toString().length || 1;
          }
        } else {
          return this.maximumLength;
        }
      },
      generateTypeInfo: function(parameter) {
        const buffer = Buffer.alloc(8);
        buffer.writeUInt8(this.id, 0);
        buffer.writeUInt16LE(parameter.length * 2, 1);
        if (parameter.collation) {
          parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
        }
        return buffer;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          value
        } = parameter;
        if (value instanceof Buffer) {
          const length = value.length;
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        } else {
          const length = Buffer.byteLength(value.toString(), "ucs2");
          const buffer = Buffer.alloc(2);
          buffer.writeUInt16LE(length, 0);
          return buffer;
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        if (value instanceof Buffer) {
          yield value;
        } else {
          yield Buffer.from(value, "ucs2");
        }
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "string") {
          throw new TypeError("Invalid string.");
        }
        return value;
      }
    };
    var _default = exports.default = NChar;
    module.exports = NChar;
  }
});

// node_modules/tedious/lib/data-types/xml.js
var require_xml = __commonJS({
  "node_modules/tedious/lib/data-types/xml.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var XML = {
      id: 241,
      type: "XML",
      name: "Xml",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = XML;
    module.exports = XML;
  }
});

// node_modules/tedious/lib/data-types/time.js
var require_time = __commonJS({
  "node_modules/tedious/lib/data-types/time.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL_LENGTH = Buffer.from([0]);
    var Time = {
      id: 41,
      type: "TIMEN",
      name: "Time",
      declaration: function(parameter) {
        return "time(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([3]);
          case 3:
          case 4:
            return Buffer.from([4]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([5]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const buffer = new _writableTrackingBuffer.default(16);
        const time = parameter.value;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((time.getUTCHours() * 60 + time.getUTCMinutes()) * 60 + time.getUTCSeconds()) * 1e3 + time.getUTCMilliseconds();
        } else {
          timestamp = ((time.getHours() * 60 + time.getMinutes()) * 60 + time.getSeconds()) * 1e3 + time.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, parameter.scale - 3);
        timestamp += (parameter.value.nanosecondDelta != null ? parameter.value.nanosecondDelta : 0) * Math.pow(10, parameter.scale);
        timestamp = Math.round(timestamp);
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        yield buffer.data;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid time.");
        }
        return value;
      }
    };
    var _default = exports.default = Time;
    module.exports = Time;
  }
});

// node_modules/tedious/lib/data-types/date.js
var require_date = __commonJS({
  "node_modules/tedious/lib/data-types/date.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    var globalDate = globalThis.Date;
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DATA_LENGTH = Buffer.from([3]);
    var Date2 = {
      id: 40,
      type: "DATEN",
      name: "Date",
      declaration: function() {
        return "date";
      },
      generateTypeInfo: function() {
        return Buffer.from([this.id]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        return DATA_LENGTH;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        const buffer = Buffer.alloc(3);
        buffer.writeUIntLE(days, 0, 3);
        yield buffer;
      },
      // TODO: value is technically of type 'unknown'.
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof globalDate)) {
          value = new globalDate(globalDate.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = Date2;
    module.exports = Date2;
  }
});

// node_modules/tedious/lib/data-types/datetime2.js
var require_datetime2 = __commonJS({
  "node_modules/tedious/lib/data-types/datetime2.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTime2 = {
      id: 42,
      type: "DATETIME2N",
      name: "DateTime2",
      declaration: function(parameter) {
        return "datetime2(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter, _options) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([6]);
          case 3:
          case 4:
            return Buffer.from([7]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([8]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        if (options.useUTC) {
          timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getUTCMilliseconds();
        } else {
          timestamp = ((value.getHours() * 60 + value.getMinutes()) * 60 + value.getSeconds()) * 1e3 + value.getMilliseconds();
        }
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        let date;
        if (options.useUTC) {
          date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        } else {
          date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
        }
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        yield buffer.data;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = DateTime2;
    module.exports = DateTime2;
  }
});

// node_modules/tedious/lib/data-types/datetimeoffset.js
var require_datetimeoffset = __commonJS({
  "node_modules/tedious/lib/data-types/datetimeoffset.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _core = (init_js_joda_esm(), __toCommonJS(js_joda_esm_exports));
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
    var NULL_LENGTH = Buffer.from([0]);
    var DateTimeOffset = {
      id: 43,
      type: "DATETIMEOFFSETN",
      name: "DateTimeOffset",
      declaration: function(parameter) {
        return "datetimeoffset(" + this.resolveScale(parameter) + ")";
      },
      resolveScale: function(parameter) {
        if (parameter.scale != null) {
          return parameter.scale;
        } else if (parameter.value === null) {
          return 0;
        } else {
          return 7;
        }
      },
      generateTypeInfo(parameter) {
        return Buffer.from([this.id, parameter.scale]);
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        switch (parameter.scale) {
          case 0:
          case 1:
          case 2:
            return Buffer.from([8]);
          case 3:
          case 4:
            return Buffer.from([9]);
          case 5:
          case 6:
          case 7:
            return Buffer.from([10]);
          default:
            throw new Error("invalid scale");
        }
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          return;
        }
        const value = parameter.value;
        let scale = parameter.scale;
        const buffer = new _writableTrackingBuffer.default(16);
        scale = scale;
        let timestamp;
        timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1e3 + value.getMilliseconds();
        timestamp = timestamp * Math.pow(10, scale - 3);
        timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
        timestamp = Math.round(timestamp);
        switch (scale) {
          case 0:
          case 1:
          case 2:
            buffer.writeUInt24LE(timestamp);
            break;
          case 3:
          case 4:
            buffer.writeUInt32LE(timestamp);
            break;
          case 5:
          case 6:
          case 7:
            buffer.writeUInt40LE(timestamp);
        }
        const date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
        const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
        buffer.writeUInt24LE(days);
        const offset = -value.getTimezoneOffset();
        buffer.writeInt16LE(offset);
        yield buffer.data;
      },
      validate: function(value, collation, options) {
        if (value == null) {
          return null;
        }
        if (!(value instanceof Date)) {
          value = new Date(Date.parse(value));
        }
        value = value;
        let year;
        if (options && options.useUTC) {
          year = value.getUTCFullYear();
        } else {
          year = value.getFullYear();
        }
        if (year < 1 || year > 9999) {
          throw new TypeError("Out of range.");
        }
        if (isNaN(value)) {
          throw new TypeError("Invalid date.");
        }
        return value;
      }
    };
    var _default = exports.default = DateTimeOffset;
    module.exports = DateTimeOffset;
  }
});

// node_modules/tedious/lib/data-types/udt.js
var require_udt = __commonJS({
  "node_modules/tedious/lib/data-types/udt.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UDT = {
      id: 240,
      type: "UDTTYPE",
      name: "UDT",
      declaration() {
        throw new Error("not implemented");
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = UDT;
    module.exports = UDT;
  }
});

// node_modules/tedious/lib/data-types/tvp.js
var require_tvp = __commonJS({
  "node_modules/tedious/lib/data-types/tvp.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TVP_ROW_TOKEN = Buffer.from([1]);
    var TVP_END_TOKEN = Buffer.from([0]);
    var NULL_LENGTH = Buffer.from([255, 255]);
    var TVP = {
      id: 243,
      type: "TVPTYPE",
      name: "TVP",
      declaration: function(parameter) {
        const value = parameter.value;
        return value.name + " readonly";
      },
      generateTypeInfo(parameter) {
        var _a3, _b2;
        const databaseName = "";
        const schema = ((_a3 = parameter.value) == null ? void 0 : _a3.schema) ?? "";
        const typeName = ((_b2 = parameter.value) == null ? void 0 : _b2.name) ?? "";
        const bufferLength = 1 + 1 + Buffer.byteLength(databaseName, "ucs2") + 1 + Buffer.byteLength(schema, "ucs2") + 1 + Buffer.byteLength(typeName, "ucs2");
        const buffer = new _writableTrackingBuffer.default(bufferLength, "ucs2");
        buffer.writeUInt8(this.id);
        buffer.writeBVarchar(databaseName);
        buffer.writeBVarchar(schema);
        buffer.writeBVarchar(typeName);
        return buffer.data;
      },
      generateParameterLength(parameter, options) {
        if (parameter.value == null) {
          return NULL_LENGTH;
        }
        const {
          columns
        } = parameter.value;
        const buffer = Buffer.alloc(2);
        buffer.writeUInt16LE(columns.length, 0);
        return buffer;
      },
      *generateParameterData(parameter, options) {
        if (parameter.value == null) {
          yield TVP_END_TOKEN;
          yield TVP_END_TOKEN;
          return;
        }
        const {
          columns,
          rows
        } = parameter.value;
        for (let i = 0, len = columns.length; i < len; i++) {
          const column = columns[i];
          const buff = Buffer.alloc(6);
          buff.writeUInt32LE(0, 0);
          buff.writeUInt16LE(0, 4);
          yield buff;
          yield column.type.generateTypeInfo(column);
          yield Buffer.from([0]);
        }
        yield TVP_END_TOKEN;
        for (let i = 0, length = rows.length; i < length; i++) {
          yield TVP_ROW_TOKEN;
          const row = rows[i];
          for (let k = 0, len2 = row.length; k < len2; k++) {
            const column = columns[k];
            const value = row[k];
            const param = {
              value: column.type.validate(value, parameter.collation),
              length: column.length,
              scale: column.scale,
              precision: column.precision
            };
            yield column.type.generateParameterLength(param, options);
            yield* column.type.generateParameterData(param, options);
          }
        }
        yield TVP_END_TOKEN;
      },
      validate: function(value) {
        if (value == null) {
          return null;
        }
        if (typeof value !== "object") {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.columns)) {
          throw new TypeError("Invalid table.");
        }
        if (!Array.isArray(value.rows)) {
          throw new TypeError("Invalid table.");
        }
        return value;
      }
    };
    var _default = exports.default = TVP;
    module.exports = TVP;
  }
});

// node_modules/tedious/lib/data-types/sql-variant.js
var require_sql_variant = __commonJS({
  "node_modules/tedious/lib/data-types/sql-variant.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var Variant = {
      id: 98,
      type: "SSVARIANTTYPE",
      name: "Variant",
      declaration: function() {
        return "sql_variant";
      },
      generateTypeInfo() {
        throw new Error("not implemented");
      },
      generateParameterLength() {
        throw new Error("not implemented");
      },
      generateParameterData() {
        throw new Error("not implemented");
      },
      validate() {
        throw new Error("not implemented");
      }
    };
    var _default = exports.default = Variant;
    module.exports = Variant;
  }
});

// node_modules/tedious/lib/data-type.js
var require_data_type = __commonJS({
  "node_modules/tedious/lib/data-type.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.typeByName = exports.TYPES = exports.TYPE = void 0;
    var _null = _interopRequireDefault(require_null());
    var _tinyint = _interopRequireDefault(require_tinyint());
    var _bit = _interopRequireDefault(require_bit());
    var _smallint = _interopRequireDefault(require_smallint());
    var _int = _interopRequireDefault(require_int());
    var _smalldatetime = _interopRequireDefault(require_smalldatetime());
    var _real = _interopRequireDefault(require_real());
    var _money = _interopRequireDefault(require_money());
    var _datetime = _interopRequireDefault(require_datetime());
    var _float = _interopRequireDefault(require_float());
    var _decimal = _interopRequireDefault(require_decimal());
    var _numeric = _interopRequireDefault(require_numeric());
    var _smallmoney = _interopRequireDefault(require_smallmoney());
    var _bigint = _interopRequireDefault(require_bigint());
    var _image = _interopRequireDefault(require_image());
    var _text = _interopRequireDefault(require_text());
    var _uniqueidentifier = _interopRequireDefault(require_uniqueidentifier());
    var _intn = _interopRequireDefault(require_intn());
    var _ntext = _interopRequireDefault(require_ntext());
    var _bitn = _interopRequireDefault(require_bitn());
    var _decimaln = _interopRequireDefault(require_decimaln());
    var _numericn = _interopRequireDefault(require_numericn());
    var _floatn = _interopRequireDefault(require_floatn());
    var _moneyn = _interopRequireDefault(require_moneyn());
    var _datetimen = _interopRequireDefault(require_datetimen());
    var _varbinary = _interopRequireDefault(require_varbinary());
    var _varchar = _interopRequireDefault(require_varchar());
    var _binary = _interopRequireDefault(require_binary());
    var _char = _interopRequireDefault(require_char());
    var _nvarchar = _interopRequireDefault(require_nvarchar());
    var _nchar = _interopRequireDefault(require_nchar());
    var _xml = _interopRequireDefault(require_xml());
    var _time = _interopRequireDefault(require_time());
    var _date = _interopRequireDefault(require_date());
    var _datetime2 = _interopRequireDefault(require_datetime2());
    var _datetimeoffset = _interopRequireDefault(require_datetimeoffset());
    var _udt = _interopRequireDefault(require_udt());
    var _tvp = _interopRequireDefault(require_tvp());
    var _sqlVariant = _interopRequireDefault(require_sql_variant());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var TYPE = exports.TYPE = {
      [_null.default.id]: _null.default,
      [_tinyint.default.id]: _tinyint.default,
      [_bit.default.id]: _bit.default,
      [_smallint.default.id]: _smallint.default,
      [_int.default.id]: _int.default,
      [_smalldatetime.default.id]: _smalldatetime.default,
      [_real.default.id]: _real.default,
      [_money.default.id]: _money.default,
      [_datetime.default.id]: _datetime.default,
      [_float.default.id]: _float.default,
      [_decimal.default.id]: _decimal.default,
      [_numeric.default.id]: _numeric.default,
      [_smallmoney.default.id]: _smallmoney.default,
      [_bigint.default.id]: _bigint.default,
      [_image.default.id]: _image.default,
      [_text.default.id]: _text.default,
      [_uniqueidentifier.default.id]: _uniqueidentifier.default,
      [_intn.default.id]: _intn.default,
      [_ntext.default.id]: _ntext.default,
      [_bitn.default.id]: _bitn.default,
      [_decimaln.default.id]: _decimaln.default,
      [_numericn.default.id]: _numericn.default,
      [_floatn.default.id]: _floatn.default,
      [_moneyn.default.id]: _moneyn.default,
      [_datetimen.default.id]: _datetimen.default,
      [_varbinary.default.id]: _varbinary.default,
      [_varchar.default.id]: _varchar.default,
      [_binary.default.id]: _binary.default,
      [_char.default.id]: _char.default,
      [_nvarchar.default.id]: _nvarchar.default,
      [_nchar.default.id]: _nchar.default,
      [_xml.default.id]: _xml.default,
      [_time.default.id]: _time.default,
      [_date.default.id]: _date.default,
      [_datetime2.default.id]: _datetime2.default,
      [_datetimeoffset.default.id]: _datetimeoffset.default,
      [_udt.default.id]: _udt.default,
      [_tvp.default.id]: _tvp.default,
      [_sqlVariant.default.id]: _sqlVariant.default
    };
    var TYPES = exports.TYPES = {
      TinyInt: _tinyint.default,
      Bit: _bit.default,
      SmallInt: _smallint.default,
      Int: _int.default,
      SmallDateTime: _smalldatetime.default,
      Real: _real.default,
      Money: _money.default,
      DateTime: _datetime.default,
      Float: _float.default,
      Decimal: _decimal.default,
      Numeric: _numeric.default,
      SmallMoney: _smallmoney.default,
      BigInt: _bigint.default,
      Image: _image.default,
      Text: _text.default,
      UniqueIdentifier: _uniqueidentifier.default,
      NText: _ntext.default,
      VarBinary: _varbinary.default,
      VarChar: _varchar.default,
      Binary: _binary.default,
      Char: _char.default,
      NVarChar: _nvarchar.default,
      NChar: _nchar.default,
      Xml: _xml.default,
      Time: _time.default,
      Date: _date.default,
      DateTime2: _datetime2.default,
      DateTimeOffset: _datetimeoffset.default,
      UDT: _udt.default,
      TVP: _tvp.default,
      Variant: _sqlVariant.default
    };
    var typeByName = exports.typeByName = TYPES;
  }
});

// node_modules/tedious/lib/token/helpers.js
var require_helpers = __commonJS({
  "node_modules/tedious/lib/token/helpers.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Result = exports.NotEnoughDataError = void 0;
    exports.readBVarByte = readBVarByte;
    exports.readBVarChar = readBVarChar;
    exports.readBigInt64LE = readBigInt64LE;
    exports.readBigUInt64LE = readBigUInt64LE;
    exports.readDoubleLE = readDoubleLE;
    exports.readFloatLE = readFloatLE;
    exports.readInt16LE = readInt16LE;
    exports.readInt32LE = readInt32LE;
    exports.readUInt16LE = readUInt16LE;
    exports.readUInt24LE = readUInt24LE;
    exports.readUInt32BE = readUInt32BE;
    exports.readUInt32LE = readUInt32LE;
    exports.readUInt40LE = readUInt40LE;
    exports.readUInt8 = readUInt8;
    exports.readUNumeric128LE = readUNumeric128LE;
    exports.readUNumeric64LE = readUNumeric64LE;
    exports.readUNumeric96LE = readUNumeric96LE;
    exports.readUsVarByte = readUsVarByte;
    exports.readUsVarChar = readUsVarChar;
    var Result = class {
      constructor(value, offset) {
        this.value = value;
        this.offset = offset;
      }
    };
    exports.Result = Result;
    var NotEnoughDataError = class extends Error {
      constructor(byteCount) {
        super();
        __publicField(this, "byteCount");
        this.byteCount = byteCount;
      }
    };
    exports.NotEnoughDataError = NotEnoughDataError;
    function readUInt8(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 1) {
        throw new NotEnoughDataError(offset + 1);
      }
      return new Result(buf.readUInt8(offset), offset + 1);
    }
    function readUInt16LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 2) {
        throw new NotEnoughDataError(offset + 2);
      }
      return new Result(buf.readUInt16LE(offset), offset + 2);
    }
    function readInt16LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 2) {
        throw new NotEnoughDataError(offset + 2);
      }
      return new Result(buf.readInt16LE(offset), offset + 2);
    }
    function readUInt24LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 3) {
        throw new NotEnoughDataError(offset + 3);
      }
      return new Result(buf.readUIntLE(offset, 3), offset + 3);
    }
    function readUInt32LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readUInt32LE(offset), offset + 4);
    }
    function readUInt32BE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readUInt32BE(offset), offset + 4);
    }
    function readUInt40LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 5) {
        throw new NotEnoughDataError(offset + 5);
      }
      return new Result(buf.readUIntLE(offset, 5), offset + 5);
    }
    function readInt32LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readInt32LE(offset), offset + 4);
    }
    function readBigUInt64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readBigUInt64LE(offset), offset + 8);
    }
    function readBigInt64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readBigInt64LE(offset), offset + 8);
    }
    function readFloatLE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 4) {
        throw new NotEnoughDataError(offset + 4);
      }
      return new Result(buf.readFloatLE(offset), offset + 4);
    }
    function readDoubleLE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      return new Result(buf.readDoubleLE(offset), offset + 8);
    }
    function readBVarChar(buf, offset) {
      offset = +offset;
      let charCount;
      ({
        offset,
        value: charCount
      } = readUInt8(buf, offset));
      const byteLength = charCount * 2;
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.toString("ucs2", offset, offset + byteLength), offset + byteLength);
    }
    function readBVarByte(buf, offset) {
      offset = +offset;
      let byteLength;
      ({
        offset,
        value: byteLength
      } = readUInt8(buf, offset));
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
    }
    function readUsVarChar(buf, offset) {
      offset = +offset;
      let charCount;
      ({
        offset,
        value: charCount
      } = readUInt16LE(buf, offset));
      const byteLength = charCount * 2;
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.toString("ucs2", offset, offset + byteLength), offset + byteLength);
    }
    function readUsVarByte(buf, offset) {
      offset = +offset;
      let byteLength;
      ({
        offset,
        value: byteLength
      } = readUInt16LE(buf, offset));
      if (buf.length < offset + byteLength) {
        throw new NotEnoughDataError(offset + byteLength);
      }
      return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
    }
    function readUNumeric64LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 8) {
        throw new NotEnoughDataError(offset + 8);
      }
      const low = buf.readUInt32LE(offset);
      const high = buf.readUInt32LE(offset + 4);
      return new Result(4294967296 * high + low, offset + 8);
    }
    function readUNumeric96LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 12) {
        throw new NotEnoughDataError(offset + 12);
      }
      const dword1 = buf.readUInt32LE(offset);
      const dword2 = buf.readUInt32LE(offset + 4);
      const dword3 = buf.readUInt32LE(offset + 8);
      return new Result(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3, offset + 12);
    }
    function readUNumeric128LE(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 16) {
        throw new NotEnoughDataError(offset + 16);
      }
      const dword1 = buf.readUInt32LE(offset);
      const dword2 = buf.readUInt32LE(offset + 4);
      const dword3 = buf.readUInt32LE(offset + 8);
      const dword4 = buf.readUInt32LE(offset + 12);
      return new Result(dword1 + 4294967296 * dword2 + 4294967296 * 4294967296 * dword3 + 4294967296 * 4294967296 * 4294967296 * dword4, offset + 16);
    }
  }
});

// node_modules/tedious/lib/metadata-parser.js
var require_metadata_parser = __commonJS({
  "node_modules/tedious/lib/metadata-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.readCollation = readCollation;
    exports.readMetadata = readMetadata;
    var _collation = require_collation();
    var _dataType = require_data_type();
    var _sprintfJs = require_sprintf();
    var _helpers = require_helpers();
    function readCollation(buf, offset) {
      offset = +offset;
      if (buf.length < offset + 5) {
        throw new _helpers.NotEnoughDataError(offset + 5);
      }
      const collation = _collation.Collation.fromBuffer(buf.slice(offset, offset + 5));
      return new _helpers.Result(collation, offset + 5);
    }
    function readSchema(buf, offset) {
      offset = +offset;
      let schemaPresent;
      ({
        offset,
        value: schemaPresent
      } = (0, _helpers.readUInt8)(buf, offset));
      if (schemaPresent !== 1) {
        return new _helpers.Result(void 0, offset);
      }
      let dbname;
      ({
        offset,
        value: dbname
      } = (0, _helpers.readBVarChar)(buf, offset));
      let owningSchema;
      ({
        offset,
        value: owningSchema
      } = (0, _helpers.readBVarChar)(buf, offset));
      let xmlSchemaCollection;
      ({
        offset,
        value: xmlSchemaCollection
      } = (0, _helpers.readUsVarChar)(buf, offset));
      return new _helpers.Result({
        dbname,
        owningSchema,
        xmlSchemaCollection
      }, offset);
    }
    function readUDTInfo(buf, offset) {
      let maxByteSize;
      ({
        offset,
        value: maxByteSize
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let dbname;
      ({
        offset,
        value: dbname
      } = (0, _helpers.readBVarChar)(buf, offset));
      let owningSchema;
      ({
        offset,
        value: owningSchema
      } = (0, _helpers.readBVarChar)(buf, offset));
      let typeName;
      ({
        offset,
        value: typeName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let assemblyName;
      ({
        offset,
        value: assemblyName
      } = (0, _helpers.readUsVarChar)(buf, offset));
      return new _helpers.Result({
        maxByteSize,
        dbname,
        owningSchema,
        typeName,
        assemblyName
      }, offset);
    }
    function readMetadata(buf, offset, options) {
      let userType;
      ({
        offset,
        value: userType
      } = (options.tdsVersion < "7_2" ? _helpers.readUInt16LE : _helpers.readUInt32LE)(buf, offset));
      let flags;
      ({
        offset,
        value: flags
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let typeNumber;
      ({
        offset,
        value: typeNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const type = _dataType.TYPE[typeNumber];
      if (!type) {
        throw new Error((0, _sprintfJs.sprintf)("Unrecognised data type 0x%02X", typeNumber));
      }
      switch (type.name) {
        case "Null":
        case "TinyInt":
        case "SmallInt":
        case "Int":
        case "BigInt":
        case "Real":
        case "Float":
        case "SmallMoney":
        case "Money":
        case "Bit":
        case "SmallDateTime":
        case "DateTime":
        case "Date":
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        case "IntN":
        case "FloatN":
        case "MoneyN":
        case "BitN":
        case "UniqueIdentifier":
        case "DateTimeN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Variant": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "VarChar":
        case "Char":
        case "NVarChar":
        case "NChar": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          let collation;
          ({
            offset,
            value: collation
          } = readCollation(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Text":
        case "NText": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          let collation;
          ({
            offset,
            value: collation
          } = readCollation(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "VarBinary":
        case "Binary": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Image": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "Xml": {
          let schema;
          ({
            offset,
            value: schema
          } = readSchema(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema,
            udtInfo: void 0
          }, offset);
        }
        case "Time":
        case "DateTime2":
        case "DateTimeOffset": {
          let scale;
          ({
            offset,
            value: scale
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale,
            dataLength: void 0,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "NumericN":
        case "DecimalN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          let precision;
          ({
            offset,
            value: precision
          } = (0, _helpers.readUInt8)(buf, offset));
          let scale;
          ({
            offset,
            value: scale
          } = (0, _helpers.readUInt8)(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision,
            scale,
            dataLength,
            schema: void 0,
            udtInfo: void 0
          }, offset);
        }
        case "UDT": {
          let udtInfo;
          ({
            offset,
            value: udtInfo
          } = readUDTInfo(buf, offset));
          return new _helpers.Result({
            userType,
            flags,
            type,
            collation: void 0,
            precision: void 0,
            scale: void 0,
            dataLength: void 0,
            schema: void 0,
            udtInfo
          }, offset);
        }
        default:
          throw new Error((0, _sprintfJs.sprintf)("Unrecognised type %s", type.name));
      }
    }
    function metadataParse(parser, options, callback) {
      (async () => {
        while (true) {
          let result;
          try {
            result = readMetadata(parser.buffer, parser.position, options);
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = result.offset;
          return callback(result.value);
        }
      })();
    }
    var _default = exports.default = metadataParse;
    module.exports = metadataParse;
    module.exports.readCollation = readCollation;
    module.exports.readMetadata = readMetadata;
  }
});

// node_modules/tedious/lib/token/colmetadata-token-parser.js
var require_colmetadata_token_parser = __commonJS({
  "node_modules/tedious/lib/token/colmetadata-token-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _metadataParser = require_metadata_parser();
    var _token = require_token();
    var _helpers = require_helpers();
    function readTableName(buf, offset, metadata, options) {
      if (!metadata.type.hasTableName) {
        return new _helpers.Result(void 0, offset);
      }
      if (options.tdsVersion < "7_2") {
        return (0, _helpers.readUsVarChar)(buf, offset);
      }
      let numberOfTableNameParts;
      ({
        offset,
        value: numberOfTableNameParts
      } = (0, _helpers.readUInt8)(buf, offset));
      const tableName = [];
      for (let i = 0; i < numberOfTableNameParts; i++) {
        let tableNamePart;
        ({
          offset,
          value: tableNamePart
        } = (0, _helpers.readUsVarChar)(buf, offset));
        tableName.push(tableNamePart);
      }
      return new _helpers.Result(tableName, offset);
    }
    function readColumnName(buf, offset, index, metadata, options) {
      let colName;
      ({
        offset,
        value: colName
      } = (0, _helpers.readBVarChar)(buf, offset));
      if (options.columnNameReplacer) {
        return new _helpers.Result(options.columnNameReplacer(colName, index, metadata), offset);
      } else if (options.camelCaseColumns) {
        return new _helpers.Result(colName.replace(/^[A-Z]/, function(s) {
          return s.toLowerCase();
        }), offset);
      } else {
        return new _helpers.Result(colName, offset);
      }
    }
    function readColumn(buf, offset, options, index) {
      let metadata;
      ({
        offset,
        value: metadata
      } = (0, _metadataParser.readMetadata)(buf, offset, options));
      let tableName;
      ({
        offset,
        value: tableName
      } = readTableName(buf, offset, metadata, options));
      let colName;
      ({
        offset,
        value: colName
      } = readColumnName(buf, offset, index, metadata, options));
      return new _helpers.Result({
        userType: metadata.userType,
        flags: metadata.flags,
        type: metadata.type,
        collation: metadata.collation,
        precision: metadata.precision,
        scale: metadata.scale,
        udtInfo: metadata.udtInfo,
        dataLength: metadata.dataLength,
        schema: metadata.schema,
        colName,
        tableName
      }, offset);
    }
    async function colMetadataParser(parser) {
      let columnCount;
      while (true) {
        let offset;
        try {
          ({
            offset,
            value: columnCount
          } = (0, _helpers.readUInt16LE)(parser.buffer, parser.position));
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            await parser.waitForChunk();
            continue;
          }
          throw err;
        }
        parser.position = offset;
        break;
      }
      const columns = [];
      for (let i = 0; i < columnCount; i++) {
        while (true) {
          let column;
          let offset;
          try {
            ({
              offset,
              value: column
            } = readColumn(parser.buffer, parser.position, parser.options, i));
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = offset;
          columns.push(column);
          break;
        }
      }
      return new _token.ColMetadataToken(columns);
    }
    var _default = exports.default = colMetadataParser;
    module.exports = colMetadataParser;
  }
});

// node_modules/tedious/lib/token/done-token-parser.js
var require_done_token_parser = __commonJS({
  "node_modules/tedious/lib/token/done-token-parser.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.doneInProcParser = doneInProcParser;
    exports.doneParser = doneParser;
    exports.doneProcParser = doneProcParser;
    var _token = require_token();
    var _helpers = require_helpers();
    var STATUS = {
      MORE: 1,
      ERROR: 2,
      // This bit is not yet in use by SQL Server, so is not exposed in the returned token
      INXACT: 4,
      COUNT: 16,
      ATTN: 32,
      SRVERROR: 256
    };
    function readToken(buf, offset, options) {
      let status;
      ({
        offset,
        value: status
      } = (0, _helpers.readUInt16LE)(buf, offset));
      const more = !!(status & STATUS.MORE);
      const sqlError = !!(status & STATUS.ERROR);
      const rowCountValid = !!(status & STATUS.COUNT);
      const attention = !!(status & STATUS.ATTN);
      const serverError = !!(status & STATUS.SRVERROR);
      let curCmd;
      ({
        offset,
        value: curCmd
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let rowCount;
      ({
        offset,
        value: rowCount
      } = (options.tdsVersion < "7_2" ? _helpers.readUInt32LE : _helpers.readBigUInt64LE)(buf, offset));
      return new _helpers.Result({
        more,
        sqlError,
        attention,
        serverError,
        rowCount: rowCountValid ? Number(rowCount) : void 0,
        curCmd
      }, offset);
    }
    function doneParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneToken(value), offset);
    }
    function doneInProcParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneInProcToken(value), offset);
    }
    function doneProcParser(buf, offset, options) {
      let value;
      ({
        offset,
        value
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.DoneProcToken(value), offset);
    }
  }
});

// node_modules/tedious/lib/token/env-change-token-parser.js
var require_env_change_token_parser = __commonJS({
  "node_modules/tedious/lib/token/env-change-token-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _collation = require_collation();
    var _token = require_token();
    var _helpers = require_helpers();
    var types = {
      1: {
        name: "DATABASE",
        event: "databaseChange"
      },
      2: {
        name: "LANGUAGE",
        event: "languageChange"
      },
      3: {
        name: "CHARSET",
        event: "charsetChange"
      },
      4: {
        name: "PACKET_SIZE",
        event: "packetSizeChange"
      },
      7: {
        name: "SQL_COLLATION",
        event: "sqlCollationChange"
      },
      8: {
        name: "BEGIN_TXN",
        event: "beginTransaction"
      },
      9: {
        name: "COMMIT_TXN",
        event: "commitTransaction"
      },
      10: {
        name: "ROLLBACK_TXN",
        event: "rollbackTransaction"
      },
      13: {
        name: "DATABASE_MIRRORING_PARTNER",
        event: "partnerNode"
      },
      17: {
        name: "TXN_ENDED"
      },
      18: {
        name: "RESET_CONNECTION",
        event: "resetConnection"
      },
      20: {
        name: "ROUTING_CHANGE",
        event: "routingChange"
      }
    };
    function _readNewAndOldValue(buf, offset, length, type) {
      switch (type.name) {
        case "DATABASE":
        case "LANGUAGE":
        case "CHARSET":
        case "PACKET_SIZE":
        case "DATABASE_MIRRORING_PARTNER": {
          let newValue;
          ({
            offset,
            value: newValue
          } = (0, _helpers.readBVarChar)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readBVarChar)(buf, offset));
          switch (type.name) {
            case "PACKET_SIZE":
              return new _helpers.Result(new _token.PacketSizeEnvChangeToken(parseInt(newValue), parseInt(oldValue)), offset);
            case "DATABASE":
              return new _helpers.Result(new _token.DatabaseEnvChangeToken(newValue, oldValue), offset);
            case "LANGUAGE":
              return new _helpers.Result(new _token.LanguageEnvChangeToken(newValue, oldValue), offset);
            case "CHARSET":
              return new _helpers.Result(new _token.CharsetEnvChangeToken(newValue, oldValue), offset);
            case "DATABASE_MIRRORING_PARTNER":
              return new _helpers.Result(new _token.DatabaseMirroringPartnerEnvChangeToken(newValue, oldValue), offset);
          }
          throw new Error("unreachable");
        }
        case "SQL_COLLATION":
        case "BEGIN_TXN":
        case "COMMIT_TXN":
        case "ROLLBACK_TXN":
        case "RESET_CONNECTION": {
          let newValue;
          ({
            offset,
            value: newValue
          } = (0, _helpers.readBVarByte)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readBVarByte)(buf, offset));
          switch (type.name) {
            case "SQL_COLLATION": {
              const newCollation = newValue.length ? _collation.Collation.fromBuffer(newValue) : void 0;
              const oldCollation = oldValue.length ? _collation.Collation.fromBuffer(oldValue) : void 0;
              return new _helpers.Result(new _token.CollationChangeToken(newCollation, oldCollation), offset);
            }
            case "BEGIN_TXN":
              return new _helpers.Result(new _token.BeginTransactionEnvChangeToken(newValue, oldValue), offset);
            case "COMMIT_TXN":
              return new _helpers.Result(new _token.CommitTransactionEnvChangeToken(newValue, oldValue), offset);
            case "ROLLBACK_TXN":
              return new _helpers.Result(new _token.RollbackTransactionEnvChangeToken(newValue, oldValue), offset);
            case "RESET_CONNECTION":
              return new _helpers.Result(new _token.ResetConnectionEnvChangeToken(newValue, oldValue), offset);
          }
          throw new Error("unreachable");
        }
        case "ROUTING_CHANGE": {
          let routePacket;
          ({
            offset,
            value: routePacket
          } = (0, _helpers.readUsVarByte)(buf, offset));
          let oldValue;
          ({
            offset,
            value: oldValue
          } = (0, _helpers.readUsVarByte)(buf, offset));
          const protocol = routePacket.readUInt8(0);
          if (protocol !== 0) {
            throw new Error("Unknown protocol byte in routing change event");
          }
          const port = routePacket.readUInt16LE(1);
          const serverLen = routePacket.readUInt16LE(3);
          const server = routePacket.toString("ucs2", 5, 5 + serverLen * 2);
          const newValue = {
            protocol,
            port,
            server
          };
          return new _helpers.Result(new _token.RoutingEnvChangeToken(newValue, oldValue), offset);
        }
        default: {
          console.error("Tedious > Unsupported ENVCHANGE type " + type.name);
          return new _helpers.Result(void 0, offset + length - 1);
        }
      }
    }
    function envChangeParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      let typeNumber;
      ({
        offset,
        value: typeNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const type = types[typeNumber];
      if (!type) {
        console.error("Tedious > Unsupported ENVCHANGE type " + typeNumber);
        return new _helpers.Result(void 0, offset + tokenLength - 1);
      }
      return _readNewAndOldValue(buf, offset, tokenLength, type);
    }
    var _default = exports.default = envChangeParser;
    module.exports = envChangeParser;
  }
});

// node_modules/tedious/lib/token/infoerror-token-parser.js
var require_infoerror_token_parser = __commonJS({
  "node_modules/tedious/lib/token/infoerror-token-parser.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.errorParser = errorParser;
    exports.infoParser = infoParser;
    var _helpers = require_helpers();
    var _token = require_token();
    function readToken(buf, offset, options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < tokenLength + offset) {
        throw new _helpers.NotEnoughDataError(tokenLength + offset);
      }
      let number;
      ({
        offset,
        value: number
      } = (0, _helpers.readUInt32LE)(buf, offset));
      let state3;
      ({
        offset,
        value: state3
      } = (0, _helpers.readUInt8)(buf, offset));
      let clazz;
      ({
        offset,
        value: clazz
      } = (0, _helpers.readUInt8)(buf, offset));
      let message;
      ({
        offset,
        value: message
      } = (0, _helpers.readUsVarChar)(buf, offset));
      let serverName;
      ({
        offset,
        value: serverName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let procName;
      ({
        offset,
        value: procName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let lineNumber;
      ({
        offset,
        value: lineNumber
      } = options.tdsVersion < "7_2" ? (0, _helpers.readUInt16LE)(buf, offset) : (0, _helpers.readUInt32LE)(buf, offset));
      return new _helpers.Result({
        "number": number,
        "state": state3,
        "class": clazz,
        "message": message,
        "serverName": serverName,
        "procName": procName,
        "lineNumber": lineNumber
      }, offset);
    }
    function infoParser(buf, offset, options) {
      let data;
      ({
        offset,
        value: data
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.InfoMessageToken(data), offset);
    }
    function errorParser(buf, offset, options) {
      let data;
      ({
        offset,
        value: data
      } = readToken(buf, offset, options));
      return new _helpers.Result(new _token.ErrorMessageToken(data), offset);
    }
  }
});

// node_modules/tedious/lib/token/fedauth-info-parser.js
var require_fedauth_info_parser = __commonJS({
  "node_modules/tedious/lib/token/fedauth-info-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helpers = require_helpers();
    var _token = require_token();
    var FEDAUTHINFOID = {
      STSURL: 1,
      SPN: 2
    };
    function readFedAuthInfo(data) {
      let offset = 0;
      let spn, stsurl;
      const countOfInfoIDs = data.readUInt32LE(offset);
      offset += 4;
      for (let i = 0; i < countOfInfoIDs; i++) {
        const fedauthInfoID = data.readUInt8(offset);
        offset += 1;
        const fedAuthInfoDataLen = data.readUInt32LE(offset);
        offset += 4;
        const fedAuthInfoDataOffset = data.readUInt32LE(offset);
        offset += 4;
        switch (fedauthInfoID) {
          case FEDAUTHINFOID.SPN:
            spn = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
            break;
          case FEDAUTHINFOID.STSURL:
            stsurl = data.toString("ucs2", fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
            break;
          default:
            break;
        }
      }
      return {
        spn,
        stsurl
      };
    }
    function fedAuthInfoParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt32LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const data = buf.slice(offset, offset + tokenLength);
      offset += tokenLength;
      const {
        spn,
        stsurl
      } = readFedAuthInfo(data);
      return new _helpers.Result(new _token.FedAuthInfoToken(spn, stsurl), offset);
    }
    var _default = exports.default = fedAuthInfoParser;
    module.exports = fedAuthInfoParser;
  }
});

// node_modules/tedious/lib/token/feature-ext-ack-parser.js
var require_feature_ext_ack_parser = __commonJS({
  "node_modules/tedious/lib/token/feature-ext-ack-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helpers = require_helpers();
    var _token = require_token();
    var FEATURE_ID = {
      SESSIONRECOVERY: 1,
      FEDAUTH: 2,
      COLUMNENCRYPTION: 4,
      GLOBALTRANSACTIONS: 5,
      AZURESQLSUPPORT: 8,
      UTF8_SUPPORT: 10,
      TERMINATOR: 255
    };
    function featureExtAckParser(buf, offset, _options) {
      let fedAuth;
      let utf8Support;
      while (true) {
        let featureId;
        ({
          value: featureId,
          offset
        } = (0, _helpers.readUInt8)(buf, offset));
        if (featureId === FEATURE_ID.TERMINATOR) {
          return new _helpers.Result(new _token.FeatureExtAckToken(fedAuth, utf8Support), offset);
        }
        let featureAckDataLen;
        ({
          value: featureAckDataLen,
          offset
        } = (0, _helpers.readUInt32LE)(buf, offset));
        if (buf.length < offset + featureAckDataLen) {
          throw new _helpers.NotEnoughDataError(offset + featureAckDataLen);
        }
        const featureData = buf.slice(offset, offset + featureAckDataLen);
        offset += featureAckDataLen;
        switch (featureId) {
          case FEATURE_ID.FEDAUTH:
            fedAuth = featureData;
            break;
          case FEATURE_ID.UTF8_SUPPORT:
            utf8Support = !!featureData[0];
            break;
        }
      }
    }
    var _default = exports.default = featureExtAckParser;
    module.exports = featureExtAckParser;
  }
});

// node_modules/tedious/lib/token/loginack-token-parser.js
var require_loginack_token_parser = __commonJS({
  "node_modules/tedious/lib/token/loginack-token-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _tdsVersions = require_tds_versions();
    var _helpers = require_helpers();
    var interfaceTypes = {
      0: "SQL_DFLT",
      1: "SQL_TSQL"
    };
    function loginAckParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < tokenLength + offset) {
        throw new _helpers.NotEnoughDataError(tokenLength + offset);
      }
      let interfaceNumber;
      ({
        offset,
        value: interfaceNumber
      } = (0, _helpers.readUInt8)(buf, offset));
      const interfaceType = interfaceTypes[interfaceNumber];
      let tdsVersionNumber;
      ({
        offset,
        value: tdsVersionNumber
      } = (0, _helpers.readUInt32BE)(buf, offset));
      const tdsVersion = _tdsVersions.versionsByValue[tdsVersionNumber];
      let progName;
      ({
        offset,
        value: progName
      } = (0, _helpers.readBVarChar)(buf, offset));
      let major;
      ({
        offset,
        value: major
      } = (0, _helpers.readUInt8)(buf, offset));
      let minor;
      ({
        offset,
        value: minor
      } = (0, _helpers.readUInt8)(buf, offset));
      let buildNumHi;
      ({
        offset,
        value: buildNumHi
      } = (0, _helpers.readUInt8)(buf, offset));
      let buildNumLow;
      ({
        offset,
        value: buildNumLow
      } = (0, _helpers.readUInt8)(buf, offset));
      return new _helpers.Result(new _token.LoginAckToken({
        interface: interfaceType,
        tdsVersion,
        progName,
        progVersion: {
          major,
          minor,
          buildNumHi,
          buildNumLow
        }
      }), offset);
    }
    var _default = exports.default = loginAckParser;
    module.exports = loginAckParser;
  }
});

// node_modules/tedious/lib/token/order-token-parser.js
var require_order_token_parser = __commonJS({
  "node_modules/tedious/lib/token/order-token-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _helpers = require_helpers();
    function orderParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const orderColumns = [];
      for (let i = 0; i < tokenLength; i += 2) {
        let column;
        ({
          offset,
          value: column
        } = (0, _helpers.readUInt16LE)(buf, offset));
        orderColumns.push(column);
      }
      return new _helpers.Result(new _token.OrderToken(orderColumns), offset);
    }
    var _default = exports.default = orderParser;
    module.exports = orderParser;
  }
});

// node_modules/tedious/lib/token/returnstatus-token-parser.js
var require_returnstatus_token_parser = __commonJS({
  "node_modules/tedious/lib/token/returnstatus-token-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helpers = require_helpers();
    var _token = require_token();
    function returnStatusParser(buf, offset, _options) {
      let value;
      ({
        value,
        offset
      } = (0, _helpers.readInt32LE)(buf, offset));
      return new _helpers.Result(new _token.ReturnStatusToken(value), offset);
    }
    var _default = exports.default = returnStatusParser;
    module.exports = returnStatusParser;
  }
});

// node_modules/tedious/lib/value-parser.js
var require_value_parser = __commonJS({
  "node_modules/tedious/lib/value-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isPLPStream = isPLPStream;
    exports.readPLPStream = readPLPStream;
    exports.readValue = readValue;
    var _metadataParser = require_metadata_parser();
    var _dataType = require_data_type();
    var _iconvLite = _interopRequireDefault(require_lib());
    var _sprintfJs = require_sprintf();
    var _guidParser = require_guid_parser();
    var _helpers = require_helpers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var NULL = (1 << 16) - 1;
    var MAX = (1 << 16) - 1;
    var THREE_AND_A_THIRD = 3 + 1 / 3;
    var MONEY_DIVISOR = 1e4;
    var PLP_NULL = 0xFFFFFFFFFFFFFFFFn;
    var UNKNOWN_PLP_LEN = 0xFFFFFFFFFFFFFFFEn;
    var DEFAULT_ENCODING = "utf8";
    function readTinyInt(buf, offset) {
      return (0, _helpers.readUInt8)(buf, offset);
    }
    function readSmallInt(buf, offset) {
      return (0, _helpers.readInt16LE)(buf, offset);
    }
    function readInt(buf, offset) {
      return (0, _helpers.readInt32LE)(buf, offset);
    }
    function readBigInt(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readBigInt64LE)(buf, offset));
      return new _helpers.Result(value.toString(), offset);
    }
    function readReal(buf, offset) {
      return (0, _helpers.readFloatLE)(buf, offset);
    }
    function readFloat(buf, offset) {
      return (0, _helpers.readDoubleLE)(buf, offset);
    }
    function readSmallMoney(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readInt32LE)(buf, offset));
      return new _helpers.Result(value / MONEY_DIVISOR, offset);
    }
    function readMoney(buf, offset) {
      let high;
      ({
        offset,
        value: high
      } = (0, _helpers.readInt32LE)(buf, offset));
      let low;
      ({
        offset,
        value: low
      } = (0, _helpers.readUInt32LE)(buf, offset));
      return new _helpers.Result((low + 4294967296 * high) / MONEY_DIVISOR, offset);
    }
    function readBit(buf, offset) {
      let value;
      ({
        offset,
        value
      } = (0, _helpers.readUInt8)(buf, offset));
      return new _helpers.Result(!!value, offset);
    }
    function readValue(buf, offset, metadata, options) {
      const type = metadata.type;
      switch (type.name) {
        case "Null":
          return new _helpers.Result(null, offset);
        case "TinyInt": {
          return readTinyInt(buf, offset);
        }
        case "SmallInt": {
          return readSmallInt(buf, offset);
        }
        case "Int": {
          return readInt(buf, offset);
        }
        case "BigInt": {
          return readBigInt(buf, offset);
        }
        case "IntN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 1:
              return readTinyInt(buf, offset);
            case 2:
              return readSmallInt(buf, offset);
            case 4:
              return readInt(buf, offset);
            case 8:
              return readBigInt(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for IntN");
          }
        }
        case "Real": {
          return readReal(buf, offset);
        }
        case "Float": {
          return readFloat(buf, offset);
        }
        case "FloatN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readReal(buf, offset);
            case 8:
              return readFloat(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for FloatN");
          }
        }
        case "SmallMoney": {
          return readSmallMoney(buf, offset);
        }
        case "Money":
          return readMoney(buf, offset);
        case "MoneyN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readSmallMoney(buf, offset);
            case 8:
              return readMoney(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for MoneyN");
          }
        }
        case "Bit": {
          return readBit(buf, offset);
        }
        case "BitN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 1:
              return readBit(buf, offset);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for BitN");
          }
        }
        case "VarChar":
        case "Char": {
          const codepage = metadata.collation.codepage;
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readChars(buf, offset, dataLength, codepage);
        }
        case "NVarChar":
        case "NChar": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readNChars(buf, offset, dataLength);
        }
        case "VarBinary":
        case "Binary": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt16LE)(buf, offset));
          if (dataLength === NULL) {
            return new _helpers.Result(null, offset);
          }
          return readBinary(buf, offset, dataLength);
        }
        case "Text": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readChars(buf, offset, dataLength, metadata.collation.codepage);
        }
        case "NText": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readNChars(buf, offset, dataLength);
        }
        case "Image": {
          let textPointerLength;
          ({
            offset,
            value: textPointerLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (textPointerLength === 0) {
            return new _helpers.Result(null, offset);
          }
          ({
            offset
          } = readBinary(buf, offset, textPointerLength));
          ({
            offset
          } = readBinary(buf, offset, 8));
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          return readBinary(buf, offset, dataLength);
        }
        case "SmallDateTime": {
          return readSmallDateTime(buf, offset, options.useUTC);
        }
        case "DateTime": {
          return readDateTime(buf, offset, options.useUTC);
        }
        case "DateTimeN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 4:
              return readSmallDateTime(buf, offset, options.useUTC);
            case 8:
              return readDateTime(buf, offset, options.useUTC);
            default:
              throw new Error("Unsupported dataLength " + dataLength + " for DateTimeN");
          }
        }
        case "Time": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readTime(buf, offset, dataLength, metadata.scale, options.useUTC);
        }
        case "Date": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDate(buf, offset, options.useUTC);
        }
        case "DateTime2": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDateTime2(buf, offset, dataLength, metadata.scale, options.useUTC);
        }
        case "DateTimeOffset": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readDateTimeOffset(buf, offset, dataLength, metadata.scale);
        }
        case "NumericN":
        case "DecimalN": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readNumeric(buf, offset, dataLength, metadata.precision, metadata.scale);
        }
        case "UniqueIdentifier": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt8)(buf, offset));
          switch (dataLength) {
            case 0:
              return new _helpers.Result(null, offset);
            case 16:
              return readUniqueIdentifier(buf, offset, options);
            default:
              throw new Error((0, _sprintfJs.sprintf)("Unsupported guid size %d", dataLength - 1));
          }
        }
        case "Variant": {
          let dataLength;
          ({
            offset,
            value: dataLength
          } = (0, _helpers.readUInt32LE)(buf, offset));
          if (dataLength === 0) {
            return new _helpers.Result(null, offset);
          }
          return readVariant(buf, offset, options, dataLength);
        }
        default: {
          throw new Error("Invalid type!");
        }
      }
    }
    function isPLPStream(metadata) {
      switch (metadata.type.name) {
        case "VarChar":
        case "NVarChar":
        case "VarBinary": {
          return metadata.dataLength === MAX;
        }
        case "Xml": {
          return true;
        }
        case "UDT": {
          return true;
        }
      }
    }
    function readUniqueIdentifier(buf, offset, options) {
      let data;
      ({
        value: data,
        offset
      } = readBinary(buf, offset, 16));
      return new _helpers.Result(options.lowerCaseGuids ? (0, _guidParser.bufferToLowerCaseGuid)(data) : (0, _guidParser.bufferToUpperCaseGuid)(data), offset);
    }
    function readNumeric(buf, offset, dataLength, _precision, scale) {
      let sign;
      ({
        offset,
        value: sign
      } = (0, _helpers.readUInt8)(buf, offset));
      sign = sign === 1 ? 1 : -1;
      let value;
      if (dataLength === 5) {
        ({
          offset,
          value
        } = (0, _helpers.readUInt32LE)(buf, offset));
      } else if (dataLength === 9) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric64LE)(buf, offset));
      } else if (dataLength === 13) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric96LE)(buf, offset));
      } else if (dataLength === 17) {
        ({
          offset,
          value
        } = (0, _helpers.readUNumeric128LE)(buf, offset));
      } else {
        throw new Error((0, _sprintfJs.sprintf)("Unsupported numeric dataLength %d", dataLength));
      }
      return new _helpers.Result(value * sign / Math.pow(10, scale), offset);
    }
    function readVariant(buf, offset, options, dataLength) {
      let baseType;
      ({
        value: baseType,
        offset
      } = (0, _helpers.readUInt8)(buf, offset));
      const type = _dataType.TYPE[baseType];
      let propBytes;
      ({
        value: propBytes,
        offset
      } = (0, _helpers.readUInt8)(buf, offset));
      dataLength = dataLength - propBytes - 2;
      switch (type.name) {
        case "UniqueIdentifier":
          return readUniqueIdentifier(buf, offset, options);
        case "Bit":
          return readBit(buf, offset);
        case "TinyInt":
          return readTinyInt(buf, offset);
        case "SmallInt":
          return readSmallInt(buf, offset);
        case "Int":
          return readInt(buf, offset);
        case "BigInt":
          return readBigInt(buf, offset);
        case "SmallDateTime":
          return readSmallDateTime(buf, offset, options.useUTC);
        case "DateTime":
          return readDateTime(buf, offset, options.useUTC);
        case "Real":
          return readReal(buf, offset);
        case "Float":
          return readFloat(buf, offset);
        case "SmallMoney":
          return readSmallMoney(buf, offset);
        case "Money":
          return readMoney(buf, offset);
        case "Date":
          return readDate(buf, offset, options.useUTC);
        case "Time": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readTime(buf, offset, dataLength, scale, options.useUTC);
        }
        case "DateTime2": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readDateTime2(buf, offset, dataLength, scale, options.useUTC);
        }
        case "DateTimeOffset": {
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readDateTimeOffset(buf, offset, dataLength, scale);
        }
        case "VarBinary":
        case "Binary": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          return readBinary(buf, offset, dataLength);
        }
        case "NumericN":
        case "DecimalN": {
          let precision;
          ({
            value: precision,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          let scale;
          ({
            value: scale,
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          return readNumeric(buf, offset, dataLength, precision, scale);
        }
        case "VarChar":
        case "Char": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          let collation;
          ({
            value: collation,
            offset
          } = (0, _metadataParser.readCollation)(buf, offset));
          return readChars(buf, offset, dataLength, collation.codepage);
        }
        case "NVarChar":
        case "NChar": {
          ({
            offset
          } = (0, _helpers.readUInt16LE)(buf, offset));
          ({
            offset
          } = (0, _metadataParser.readCollation)(buf, offset));
          return readNChars(buf, offset, dataLength);
        }
        default:
          throw new Error("Invalid type!");
      }
    }
    function readBinary(buf, offset, dataLength) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(buf.slice(offset, offset + dataLength), offset + dataLength);
    }
    function readChars(buf, offset, dataLength, codepage) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(_iconvLite.default.decode(buf.slice(offset, offset + dataLength), codepage ?? DEFAULT_ENCODING), offset + dataLength);
    }
    function readNChars(buf, offset, dataLength) {
      if (buf.length < offset + dataLength) {
        throw new _helpers.NotEnoughDataError(offset + dataLength);
      }
      return new _helpers.Result(buf.toString("ucs2", offset, offset + dataLength), offset + dataLength);
    }
    async function readPLPStream(parser) {
      while (parser.buffer.length < parser.position + 8) {
        await parser.waitForChunk();
      }
      const expectedLength = parser.buffer.readBigUInt64LE(parser.position);
      parser.position += 8;
      if (expectedLength === PLP_NULL) {
        return null;
      }
      const chunks = [];
      let currentLength = 0;
      while (true) {
        while (parser.buffer.length < parser.position + 4) {
          await parser.waitForChunk();
        }
        const chunkLength = parser.buffer.readUInt32LE(parser.position);
        parser.position += 4;
        if (!chunkLength) {
          break;
        }
        while (parser.buffer.length < parser.position + chunkLength) {
          await parser.waitForChunk();
        }
        chunks.push(parser.buffer.slice(parser.position, parser.position + chunkLength));
        parser.position += chunkLength;
        currentLength += chunkLength;
      }
      if (expectedLength !== UNKNOWN_PLP_LEN) {
        if (currentLength !== Number(expectedLength)) {
          throw new Error("Partially Length-prefixed Bytes unmatched lengths : expected " + expectedLength + ", but got " + currentLength + " bytes");
        }
      }
      return chunks;
    }
    function readSmallDateTime(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let minutes;
      ({
        offset,
        value: minutes
      } = (0, _helpers.readUInt16LE)(buf, offset));
      let value;
      if (useUTC) {
        value = new Date(Date.UTC(1900, 0, 1 + days, 0, minutes));
      } else {
        value = new Date(1900, 0, 1 + days, 0, minutes);
      }
      return new _helpers.Result(value, offset);
    }
    function readDateTime(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readInt32LE)(buf, offset));
      let threeHundredthsOfSecond;
      ({
        offset,
        value: threeHundredthsOfSecond
      } = (0, _helpers.readInt32LE)(buf, offset));
      const milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);
      let value;
      if (useUTC) {
        value = new Date(Date.UTC(1900, 0, 1 + days, 0, 0, 0, milliseconds));
      } else {
        value = new Date(1900, 0, 1 + days, 0, 0, 0, milliseconds);
      }
      return new _helpers.Result(value, offset);
    }
    function readTime(buf, offset, dataLength, scale, useUTC) {
      let value;
      switch (dataLength) {
        case 3: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt24LE)(buf, offset));
          break;
        }
        case 4: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt32LE)(buf, offset));
          break;
        }
        case 5: {
          ({
            value,
            offset
          } = (0, _helpers.readUInt40LE)(buf, offset));
          break;
        }
        default: {
          throw new Error("unreachable");
        }
      }
      if (scale < 7) {
        for (let i = scale; i < 7; i++) {
          value *= 10;
        }
      }
      let date;
      if (useUTC) {
        date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 1e4));
      } else {
        date = new Date(1970, 0, 1, 0, 0, 0, value / 1e4);
      }
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: value % 1e4 / Math.pow(10, 7)
      });
      return new _helpers.Result(date, offset);
    }
    function readDate(buf, offset, useUTC) {
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      if (useUTC) {
        return new _helpers.Result(new Date(Date.UTC(2e3, 0, days - 730118)), offset);
      } else {
        return new _helpers.Result(new Date(2e3, 0, days - 730118), offset);
      }
    }
    function readDateTime2(buf, offset, dataLength, scale, useUTC) {
      let time;
      ({
        offset,
        value: time
      } = readTime(buf, offset, dataLength - 3, scale, useUTC));
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      let date;
      if (useUTC) {
        date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
      } else {
        date = new Date(2e3, 0, days - 730118, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
      }
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: time.nanosecondsDelta
      });
      return new _helpers.Result(date, offset);
    }
    function readDateTimeOffset(buf, offset, dataLength, scale) {
      let time;
      ({
        offset,
        value: time
      } = readTime(buf, offset, dataLength - 5, scale, true));
      let days;
      ({
        offset,
        value: days
      } = (0, _helpers.readUInt24LE)(buf, offset));
      ({
        offset
      } = (0, _helpers.readUInt16LE)(buf, offset));
      const date = new Date(Date.UTC(2e3, 0, days - 730118, 0, 0, 0, +time));
      Object.defineProperty(date, "nanosecondsDelta", {
        enumerable: false,
        value: time.nanosecondsDelta
      });
      return new _helpers.Result(date, offset);
    }
    module.exports.readValue = readValue;
    module.exports.isPLPStream = isPLPStream;
    module.exports.readPLPStream = readPLPStream;
  }
});

// node_modules/tedious/lib/token/returnvalue-token-parser.js
var require_returnvalue_token_parser = __commonJS({
  "node_modules/tedious/lib/token/returnvalue-token-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _metadataParser = require_metadata_parser();
    var _valueParser = require_value_parser();
    var _helpers = require_helpers();
    var iconv = _interopRequireWildcard(require_lib());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    async function returnParser(parser) {
      var _a3;
      let paramName;
      let paramOrdinal;
      let metadata;
      while (true) {
        const buf = parser.buffer;
        let offset = parser.position;
        try {
          ({
            offset,
            value: paramOrdinal
          } = (0, _helpers.readUInt16LE)(buf, offset));
          ({
            offset,
            value: paramName
          } = (0, _helpers.readBVarChar)(buf, offset));
          ({
            offset
          } = (0, _helpers.readUInt8)(buf, offset));
          ({
            offset,
            value: metadata
          } = (0, _metadataParser.readMetadata)(buf, offset, parser.options));
          if (paramName.charAt(0) === "@") {
            paramName = paramName.slice(1);
          }
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            await parser.waitForChunk();
            continue;
          }
          throw err;
        }
        parser.position = offset;
        break;
      }
      let value;
      while (true) {
        const buf = parser.buffer;
        let offset = parser.position;
        if ((0, _valueParser.isPLPStream)(metadata)) {
          const chunks = await (0, _valueParser.readPLPStream)(parser);
          if (chunks === null) {
            value = chunks;
          } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
            value = Buffer.concat(chunks).toString("ucs2");
          } else if (metadata.type.name === "VarChar") {
            value = iconv.decode(Buffer.concat(chunks), ((_a3 = metadata.collation) == null ? void 0 : _a3.codepage) ?? "utf8");
          } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
            value = Buffer.concat(chunks);
          }
        } else {
          try {
            ({
              value,
              offset
            } = (0, _valueParser.readValue)(buf, offset, metadata, parser.options));
          } catch (err) {
            if (err instanceof _helpers.NotEnoughDataError) {
              await parser.waitForChunk();
              continue;
            }
            throw err;
          }
          parser.position = offset;
        }
        break;
      }
      return new _token.ReturnValueToken({
        paramOrdinal,
        paramName,
        metadata,
        value
      });
    }
    var _default = exports.default = returnParser;
    module.exports = returnParser;
  }
});

// node_modules/tedious/lib/token/row-token-parser.js
var require_row_token_parser = __commonJS({
  "node_modules/tedious/lib/token/row-token-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var iconv = _interopRequireWildcard(require_lib());
    var _valueParser = require_value_parser();
    var _helpers = require_helpers();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    async function rowParser(parser) {
      var _a3;
      const columns = [];
      for (const metadata of parser.colMetadata) {
        while (true) {
          if ((0, _valueParser.isPLPStream)(metadata)) {
            const chunks = await (0, _valueParser.readPLPStream)(parser);
            if (chunks === null) {
              columns.push({
                value: chunks,
                metadata
              });
            } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
              columns.push({
                value: Buffer.concat(chunks).toString("ucs2"),
                metadata
              });
            } else if (metadata.type.name === "VarChar") {
              columns.push({
                value: iconv.decode(Buffer.concat(chunks), ((_a3 = metadata.collation) == null ? void 0 : _a3.codepage) ?? "utf8"),
                metadata
              });
            } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
              columns.push({
                value: Buffer.concat(chunks),
                metadata
              });
            }
          } else {
            let result;
            try {
              result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
            } catch (err) {
              if (err instanceof _helpers.NotEnoughDataError) {
                await parser.waitForChunk();
                continue;
              }
              throw err;
            }
            parser.position = result.offset;
            columns.push({
              value: result.value,
              metadata
            });
          }
          break;
        }
      }
      if (parser.options.useColumnNames) {
        const columnsMap = /* @__PURE__ */ Object.create(null);
        columns.forEach((column) => {
          const colName = column.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column;
          }
        });
        return new _token.RowToken(columnsMap);
      } else {
        return new _token.RowToken(columns);
      }
    }
    var _default = exports.default = rowParser;
    module.exports = rowParser;
  }
});

// node_modules/tedious/lib/token/nbcrow-token-parser.js
var require_nbcrow_token_parser = __commonJS({
  "node_modules/tedious/lib/token/nbcrow-token-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var iconv = _interopRequireWildcard(require_lib());
    var _valueParser = require_value_parser();
    var _helpers = require_helpers();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    async function nbcRowParser(parser) {
      var _a3;
      const colMetadata = parser.colMetadata;
      const columns = [];
      const bitmap = [];
      const bitmapByteLength = Math.ceil(colMetadata.length / 8);
      while (parser.buffer.length - parser.position < bitmapByteLength) {
        await parser.waitForChunk();
      }
      const bytes = parser.buffer.slice(parser.position, parser.position + bitmapByteLength);
      parser.position += bitmapByteLength;
      for (let i = 0, len = bytes.length; i < len; i++) {
        const byte = bytes[i];
        bitmap.push(byte & 1 ? true : false);
        bitmap.push(byte & 2 ? true : false);
        bitmap.push(byte & 4 ? true : false);
        bitmap.push(byte & 8 ? true : false);
        bitmap.push(byte & 16 ? true : false);
        bitmap.push(byte & 32 ? true : false);
        bitmap.push(byte & 64 ? true : false);
        bitmap.push(byte & 128 ? true : false);
      }
      for (let i = 0; i < colMetadata.length; i++) {
        const metadata = colMetadata[i];
        if (bitmap[i]) {
          columns.push({
            value: null,
            metadata
          });
          continue;
        }
        while (true) {
          if ((0, _valueParser.isPLPStream)(metadata)) {
            const chunks = await (0, _valueParser.readPLPStream)(parser);
            if (chunks === null) {
              columns.push({
                value: chunks,
                metadata
              });
            } else if (metadata.type.name === "NVarChar" || metadata.type.name === "Xml") {
              columns.push({
                value: Buffer.concat(chunks).toString("ucs2"),
                metadata
              });
            } else if (metadata.type.name === "VarChar") {
              columns.push({
                value: iconv.decode(Buffer.concat(chunks), ((_a3 = metadata.collation) == null ? void 0 : _a3.codepage) ?? "utf8"),
                metadata
              });
            } else if (metadata.type.name === "VarBinary" || metadata.type.name === "UDT") {
              columns.push({
                value: Buffer.concat(chunks),
                metadata
              });
            }
          } else {
            let result;
            try {
              result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
            } catch (err) {
              if (err instanceof _helpers.NotEnoughDataError) {
                await parser.waitForChunk();
                continue;
              }
              throw err;
            }
            parser.position = result.offset;
            columns.push({
              value: result.value,
              metadata
            });
          }
          break;
        }
      }
      if (parser.options.useColumnNames) {
        const columnsMap = /* @__PURE__ */ Object.create(null);
        columns.forEach((column) => {
          const colName = column.metadata.colName;
          if (columnsMap[colName] == null) {
            columnsMap[colName] = column;
          }
        });
        return new _token.NBCRowToken(columnsMap);
      } else {
        return new _token.NBCRowToken(columns);
      }
    }
    var _default = exports.default = nbcRowParser;
    module.exports = nbcRowParser;
  }
});

// node_modules/tedious/lib/token/sspi-token-parser.js
var require_sspi_token_parser = __commonJS({
  "node_modules/tedious/lib/token/sspi-token-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _helpers = require_helpers();
    var _token = require_token();
    function parseChallenge(buffer) {
      const challenge = {};
      challenge.magic = buffer.slice(0, 8).toString("utf8");
      challenge.type = buffer.readInt32LE(8);
      challenge.domainLen = buffer.readInt16LE(12);
      challenge.domainMax = buffer.readInt16LE(14);
      challenge.domainOffset = buffer.readInt32LE(16);
      challenge.flags = buffer.readInt32LE(20);
      challenge.nonce = buffer.slice(24, 32);
      challenge.zeroes = buffer.slice(32, 40);
      challenge.targetLen = buffer.readInt16LE(40);
      challenge.targetMax = buffer.readInt16LE(42);
      challenge.targetOffset = buffer.readInt32LE(44);
      challenge.oddData = buffer.slice(48, 56);
      challenge.domain = buffer.slice(56, 56 + challenge.domainLen).toString("ucs2");
      challenge.target = buffer.slice(56 + challenge.domainLen, 56 + challenge.domainLen + challenge.targetLen);
      return challenge;
    }
    function sspiParser(buf, offset, _options) {
      let tokenLength;
      ({
        offset,
        value: tokenLength
      } = (0, _helpers.readUInt16LE)(buf, offset));
      if (buf.length < offset + tokenLength) {
        throw new _helpers.NotEnoughDataError(offset + tokenLength);
      }
      const data = buf.slice(offset, offset + tokenLength);
      offset += tokenLength;
      return new _helpers.Result(new _token.SSPIToken(parseChallenge(data), data), offset);
    }
    var _default = exports.default = sspiParser;
    module.exports = sspiParser;
  }
});

// node_modules/tedious/lib/token/stream-parser.js
var require_stream_parser = __commonJS({
  "node_modules/tedious/lib/token/stream-parser.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _token = require_token();
    var _colmetadataTokenParser = _interopRequireDefault(require_colmetadata_token_parser());
    var _doneTokenParser = require_done_token_parser();
    var _envChangeTokenParser = _interopRequireDefault(require_env_change_token_parser());
    var _infoerrorTokenParser = require_infoerror_token_parser();
    var _fedauthInfoParser = _interopRequireDefault(require_fedauth_info_parser());
    var _featureExtAckParser = _interopRequireDefault(require_feature_ext_ack_parser());
    var _loginackTokenParser = _interopRequireDefault(require_loginack_token_parser());
    var _orderTokenParser = _interopRequireDefault(require_order_token_parser());
    var _returnstatusTokenParser = _interopRequireDefault(require_returnstatus_token_parser());
    var _returnvalueTokenParser = _interopRequireDefault(require_returnvalue_token_parser());
    var _rowTokenParser = _interopRequireDefault(require_row_token_parser());
    var _nbcrowTokenParser = _interopRequireDefault(require_nbcrow_token_parser());
    var _sspiTokenParser = _interopRequireDefault(require_sspi_token_parser());
    var _helpers = require_helpers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = class _Parser {
      constructor(iterable, debug, options) {
        __publicField(this, "debug");
        __publicField(this, "colMetadata");
        __publicField(this, "options");
        __publicField(this, "iterator");
        __publicField(this, "buffer");
        __publicField(this, "position");
        this.debug = debug;
        this.colMetadata = [];
        this.options = options;
        this.iterator = (iterable[Symbol.asyncIterator] || iterable[Symbol.iterator]).call(iterable);
        this.buffer = Buffer.alloc(0);
        this.position = 0;
      }
      static async *parseTokens(iterable, debug, options, colMetadata = []) {
        const parser = new _Parser(iterable, debug, options);
        parser.colMetadata = colMetadata;
        while (true) {
          try {
            await parser.waitForChunk();
          } catch (err) {
            if (parser.position === parser.buffer.length) {
              return;
            }
            throw err;
          }
          while (parser.buffer.length >= parser.position + 1) {
            const type = parser.buffer.readUInt8(parser.position);
            parser.position += 1;
            const token = parser.readToken(type);
            if (token !== void 0) {
              yield token;
            }
          }
        }
      }
      readToken(type) {
        switch (type) {
          case _token.TYPE.DONE: {
            return this.readDoneToken();
          }
          case _token.TYPE.DONEPROC: {
            return this.readDoneProcToken();
          }
          case _token.TYPE.DONEINPROC: {
            return this.readDoneInProcToken();
          }
          case _token.TYPE.ERROR: {
            return this.readErrorToken();
          }
          case _token.TYPE.INFO: {
            return this.readInfoToken();
          }
          case _token.TYPE.ENVCHANGE: {
            return this.readEnvChangeToken();
          }
          case _token.TYPE.LOGINACK: {
            return this.readLoginAckToken();
          }
          case _token.TYPE.RETURNSTATUS: {
            return this.readReturnStatusToken();
          }
          case _token.TYPE.ORDER: {
            return this.readOrderToken();
          }
          case _token.TYPE.FEDAUTHINFO: {
            return this.readFedAuthInfoToken();
          }
          case _token.TYPE.SSPI: {
            return this.readSSPIToken();
          }
          case _token.TYPE.COLMETADATA: {
            return this.readColMetadataToken();
          }
          case _token.TYPE.RETURNVALUE: {
            return this.readReturnValueToken();
          }
          case _token.TYPE.ROW: {
            return this.readRowToken();
          }
          case _token.TYPE.NBCROW: {
            return this.readNbcRowToken();
          }
          case _token.TYPE.FEATUREEXTACK: {
            return this.readFeatureExtAckToken();
          }
          default: {
            throw new Error("Unknown type: " + type);
          }
        }
      }
      readFeatureExtAckToken() {
        let result;
        try {
          result = (0, _featureExtAckParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readFeatureExtAckToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      async readNbcRowToken() {
        return await (0, _nbcrowTokenParser.default)(this);
      }
      async readReturnValueToken() {
        return await (0, _returnvalueTokenParser.default)(this);
      }
      async readColMetadataToken() {
        const token = await (0, _colmetadataTokenParser.default)(this);
        this.colMetadata = token.columns;
        return token;
      }
      readSSPIToken() {
        let result;
        try {
          result = (0, _sspiTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readSSPIToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readFedAuthInfoToken() {
        let result;
        try {
          result = (0, _fedauthInfoParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readFedAuthInfoToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readOrderToken() {
        let result;
        try {
          result = (0, _orderTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readOrderToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readReturnStatusToken() {
        let result;
        try {
          result = (0, _returnstatusTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readReturnStatusToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readLoginAckToken() {
        let result;
        try {
          result = (0, _loginackTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readLoginAckToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readEnvChangeToken() {
        let result;
        try {
          result = (0, _envChangeTokenParser.default)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readEnvChangeToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readRowToken() {
        return (0, _rowTokenParser.default)(this);
      }
      readInfoToken() {
        let result;
        try {
          result = (0, _infoerrorTokenParser.infoParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readInfoToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readErrorToken() {
        let result;
        try {
          result = (0, _infoerrorTokenParser.errorParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readErrorToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneInProcToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneInProcParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneInProcToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneProcToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneProcParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneProcToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      readDoneToken() {
        let result;
        try {
          result = (0, _doneTokenParser.doneParser)(this.buffer, this.position, this.options);
        } catch (err) {
          if (err instanceof _helpers.NotEnoughDataError) {
            return this.waitForChunk().then(() => {
              return this.readDoneToken();
            });
          }
          throw err;
        }
        this.position = result.offset;
        return result.value;
      }
      async waitForChunk() {
        const result = await this.iterator.next();
        if (result.done) {
          throw new Error("unexpected end of data");
        }
        if (this.position === this.buffer.length) {
          this.buffer = result.value;
        } else {
          this.buffer = Buffer.concat([this.buffer.slice(this.position), result.value]);
        }
        this.position = 0;
      }
    };
    var _default = exports.default = Parser;
    module.exports = Parser;
  }
});

// node_modules/tedious/lib/token/token-stream-parser.js
var require_token_stream_parser = __commonJS({
  "node_modules/tedious/lib/token/token-stream-parser.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Parser = void 0;
    var _events = require_events();
    var _streamParser = _interopRequireDefault(require_stream_parser());
    var _stream = require_stream();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Parser = class extends _events.EventEmitter {
      constructor(message, debug, handler, options) {
        super();
        this.debug = debug;
        this.options = options;
        this.parser = _stream.Readable.from(_streamParser.default.parseTokens(message, this.debug, this.options));
        this.parser.on("data", (token) => {
          handler[token.handlerName](token);
        });
        this.parser.on("drain", () => {
          this.emit("drain");
        });
        this.parser.on("end", () => {
          this.emit("end");
        });
      }
      pause() {
        return this.parser.pause();
      }
      resume() {
        return this.parser.resume();
      }
    };
    exports.Parser = Parser;
  }
});

// node_modules/tedious/lib/transaction.js
var require_transaction = __commonJS({
  "node_modules/tedious/lib/transaction.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Transaction = exports.OPERATION_TYPE = exports.ISOLATION_LEVEL = void 0;
    exports.assertValidIsolationLevel = assertValidIsolationLevel;
    exports.isolationLevelByValue = void 0;
    var _writableTrackingBuffer = _interopRequireDefault(require_writable_tracking_buffer());
    var _allHeaders = require_all_headers();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var OPERATION_TYPE = exports.OPERATION_TYPE = {
      TM_GET_DTC_ADDRESS: 0,
      TM_PROPAGATE_XACT: 1,
      TM_BEGIN_XACT: 5,
      TM_PROMOTE_XACT: 6,
      TM_COMMIT_XACT: 7,
      TM_ROLLBACK_XACT: 8,
      TM_SAVE_XACT: 9
    };
    var ISOLATION_LEVEL = exports.ISOLATION_LEVEL = {
      NO_CHANGE: 0,
      READ_UNCOMMITTED: 1,
      READ_COMMITTED: 2,
      REPEATABLE_READ: 3,
      SERIALIZABLE: 4,
      SNAPSHOT: 5
    };
    var isolationLevelByValue = exports.isolationLevelByValue = {};
    for (const name2 in ISOLATION_LEVEL) {
      const value = ISOLATION_LEVEL[name2];
      isolationLevelByValue[value] = name2;
    }
    function assertValidIsolationLevel(isolationLevel, name2) {
      if (typeof isolationLevel !== "number") {
        throw new TypeError(`The "${name2}" ${name2.includes(".") ? "property" : "argument"} must be of type number. Received type ${typeof isolationLevel} (${isolationLevel})`);
      }
      if (!Number.isInteger(isolationLevel)) {
        throw new RangeError(`The value of "${name2}" is out of range. It must be an integer. Received: ${isolationLevel}`);
      }
      if (!(isolationLevel >= 0 && isolationLevel <= 5)) {
        throw new RangeError(`The value of "${name2}" is out of range. It must be >= 0 && <= 5. Received: ${isolationLevel}`);
      }
    }
    var Transaction = class {
      constructor(name2, isolationLevel = ISOLATION_LEVEL.NO_CHANGE) {
        this.name = name2;
        this.isolationLevel = isolationLevel;
        this.outstandingRequestCount = 1;
      }
      beginPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ucs2");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_BEGIN_XACT);
        buffer.writeUInt8(this.isolationLevel);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Begin Transaction: name=" + this.name + ", isolationLevel=" + isolationLevelByValue[this.isolationLevel];
          }
        };
      }
      commitPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_COMMIT_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Commit Transaction: name=" + this.name;
          }
        };
      }
      rollbackPayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_ROLLBACK_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        buffer.writeUInt8(0);
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Rollback Transaction: name=" + this.name;
          }
        };
      }
      savePayload(txnDescriptor) {
        const buffer = new _writableTrackingBuffer.default(100, "ascii");
        (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
        buffer.writeUShort(OPERATION_TYPE.TM_SAVE_XACT);
        buffer.writeUInt8(this.name.length * 2);
        buffer.writeString(this.name, "ucs2");
        return {
          *[Symbol.iterator]() {
            yield buffer.data;
          },
          toString: () => {
            return "Save Transaction: name=" + this.name;
          }
        };
      }
      isolationLevelToTSQL() {
        switch (this.isolationLevel) {
          case ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "READ UNCOMMITTED";
          case ISOLATION_LEVEL.READ_COMMITTED:
            return "READ COMMITTED";
          case ISOLATION_LEVEL.REPEATABLE_READ:
            return "REPEATABLE READ";
          case ISOLATION_LEVEL.SERIALIZABLE:
            return "SERIALIZABLE";
          case ISOLATION_LEVEL.SNAPSHOT:
            return "SNAPSHOT";
        }
        return "";
      }
    };
    exports.Transaction = Transaction;
  }
});

// node_modules/tedious/lib/connector.js
var require_connector = __commonJS({
  "node_modules/tedious/lib/connector.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.connectInParallel = connectInParallel;
    exports.connectInSequence = connectInSequence;
    exports.lookupAllAddresses = lookupAllAddresses;
    var _net = _interopRequireDefault(require_net());
    var _nodeUrl = _interopRequireDefault(require_node_url());
    var _abortError = _interopRequireDefault(require_abort_error());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    async function connectInParallel(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      return await new Promise((resolve, reject) => {
        const sockets = new Array(addresses.length);
        const errors = [];
        function onError(err) {
          errors.push(err);
          this.removeListener("error", onError);
          this.removeListener("connect", onConnect);
          this.destroy();
          if (errors.length === addresses.length) {
            signal.removeEventListener("abort", onAbort);
            reject(new AggregateError(errors, "Could not connect (parallel)"));
          }
        }
        function onConnect() {
          signal.removeEventListener("abort", onAbort);
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            if (this === socket) {
              continue;
            }
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          resolve(this);
        }
        const onAbort = () => {
          for (let j = 0; j < sockets.length; j++) {
            const socket = sockets[j];
            socket.removeListener("error", onError);
            socket.removeListener("connect", onConnect);
            socket.destroy();
          }
          reject(new _abortError.default());
        };
        for (let i = 0, len = addresses.length; i < len; i++) {
          const socket = sockets[i] = _net.default.connect({
            ...options,
            host: addresses[i].address,
            family: addresses[i].family
          });
          socket.on("error", onError);
          socket.on("connect", onConnect);
        }
        signal.addEventListener("abort", onAbort, {
          once: true
        });
      });
    }
    async function connectInSequence(options, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      const errors = [];
      const addresses = await lookupAllAddresses(options.host, lookup, signal);
      for (const address of addresses) {
        try {
          return await new Promise((resolve, reject) => {
            const socket = _net.default.connect({
              ...options,
              host: address.address,
              family: address.family
            });
            const onAbort = () => {
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(new _abortError.default());
            };
            const onError = (err) => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              socket.destroy();
              reject(err);
            };
            const onConnect = () => {
              signal.removeEventListener("abort", onAbort);
              socket.removeListener("error", onError);
              socket.removeListener("connect", onConnect);
              resolve(socket);
            };
            signal.addEventListener("abort", onAbort, {
              once: true
            });
            socket.on("error", onError);
            socket.on("connect", onConnect);
          });
        } catch (err) {
          if (err instanceof Error && err.name === "AbortError") {
            throw err;
          }
          errors.push(err);
          continue;
        }
      }
      throw new AggregateError(errors, "Could not connect (sequence)");
    }
    async function lookupAllAddresses(host, lookup, signal) {
      if (signal.aborted) {
        throw new _abortError.default();
      }
      if (_net.default.isIPv6(host)) {
        return [{
          address: host,
          family: 6
        }];
      } else if (_net.default.isIPv4(host)) {
        return [{
          address: host,
          family: 4
        }];
      } else {
        return await new Promise((resolve, reject) => {
          const onAbort = () => {
            reject(new _abortError.default());
          };
          signal.addEventListener("abort", onAbort);
          lookup(_nodeUrl.default.domainToASCII(host), {
            all: true
          }, (err, addresses) => {
            signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve(addresses);
          });
        });
      }
    }
  }
});

// node_modules/tedious/lib/library.js
var require_library = __commonJS({
  "node_modules/tedious/lib/library.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.name = void 0;
    var name2 = exports.name = "Tedious";
  }
});

// node_modules/tedious/lib/ntlm.js
var require_ntlm = __commonJS({
  "node_modules/tedious/lib/ntlm.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createNTLMRequest = createNTLMRequest;
    var NTLMFlags = {
      NTLM_NegotiateUnicode: 1,
      NTLM_NegotiateOEM: 2,
      NTLM_RequestTarget: 4,
      NTLM_Unknown9: 8,
      NTLM_NegotiateSign: 16,
      NTLM_NegotiateSeal: 32,
      NTLM_NegotiateDatagram: 64,
      NTLM_NegotiateLanManagerKey: 128,
      NTLM_Unknown8: 256,
      NTLM_NegotiateNTLM: 512,
      NTLM_NegotiateNTOnly: 1024,
      NTLM_Anonymous: 2048,
      NTLM_NegotiateOemDomainSupplied: 4096,
      NTLM_NegotiateOemWorkstationSupplied: 8192,
      NTLM_Unknown6: 16384,
      NTLM_NegotiateAlwaysSign: 32768,
      NTLM_TargetTypeDomain: 65536,
      NTLM_TargetTypeServer: 131072,
      NTLM_TargetTypeShare: 262144,
      NTLM_NegotiateExtendedSecurity: 524288,
      NTLM_NegotiateIdentify: 1048576,
      NTLM_Unknown5: 2097152,
      NTLM_RequestNonNTSessionKey: 4194304,
      NTLM_NegotiateTargetInfo: 8388608,
      NTLM_Unknown4: 16777216,
      NTLM_NegotiateVersion: 33554432,
      NTLM_Unknown3: 67108864,
      NTLM_Unknown2: 134217728,
      NTLM_Unknown1: 268435456,
      NTLM_Negotiate128: 536870912,
      NTLM_NegotiateKeyExchange: 1073741824,
      NTLM_Negotiate56: 2147483648
    };
    function createNTLMRequest(options) {
      const domain = escape(options.domain.toUpperCase());
      const workstation = options.workstation ? escape(options.workstation.toUpperCase()) : "";
      let type1flags = NTLMFlags.NTLM_NegotiateUnicode + NTLMFlags.NTLM_NegotiateOEM + NTLMFlags.NTLM_RequestTarget + NTLMFlags.NTLM_NegotiateNTLM + NTLMFlags.NTLM_NegotiateOemDomainSupplied + NTLMFlags.NTLM_NegotiateOemWorkstationSupplied + NTLMFlags.NTLM_NegotiateAlwaysSign + NTLMFlags.NTLM_NegotiateVersion + NTLMFlags.NTLM_NegotiateExtendedSecurity + NTLMFlags.NTLM_Negotiate128 + NTLMFlags.NTLM_Negotiate56;
      if (workstation === "") {
        type1flags -= NTLMFlags.NTLM_NegotiateOemWorkstationSupplied;
      }
      const fixedData = Buffer.alloc(40);
      const buffers = [fixedData];
      let offset = 0;
      offset += fixedData.write("NTLMSSP", offset, 7, "ascii");
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt32LE(1, offset);
      offset = fixedData.writeUInt32LE(type1flags, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt16LE(domain.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length + workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt16LE(workstation.length, offset);
      offset = fixedData.writeUInt32LE(fixedData.length, offset);
      offset = fixedData.writeUInt8(5, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt16LE(2195, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      offset = fixedData.writeUInt8(0, offset);
      fixedData.writeUInt8(15, offset);
      buffers.push(Buffer.from(workstation, "ascii"));
      buffers.push(Buffer.from(domain, "ascii"));
      return Buffer.concat(buffers);
    }
  }
});

// node_modules/tedious/lib/bulk-load-payload.js
var require_bulk_load_payload = __commonJS({
  "node_modules/tedious/lib/bulk-load-payload.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BulkLoadPayload = void 0;
    var BulkLoadPayload = class {
      constructor(bulkLoad) {
        this.bulkLoad = bulkLoad;
        this.iterator = this.bulkLoad.rowToPacketTransform[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterator;
      }
      toString(indent = "") {
        return indent + "BulkLoad";
      }
    };
    exports.BulkLoadPayload = BulkLoadPayload;
  }
});

// node_modules/tedious/lib/special-stored-procedure.js
var require_special_stored_procedure = __commonJS({
  "node_modules/tedious/lib/special-stored-procedure.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var procedures = {
      Sp_Cursor: 1,
      Sp_CursorOpen: 2,
      Sp_CursorPrepare: 3,
      Sp_CursorExecute: 4,
      Sp_CursorPrepExec: 5,
      Sp_CursorUnprepare: 6,
      Sp_CursorFetch: 7,
      Sp_CursorOption: 8,
      Sp_CursorClose: 9,
      Sp_ExecuteSql: 10,
      Sp_Prepare: 11,
      Sp_Execute: 12,
      Sp_PrepExec: 13,
      Sp_PrepExecRpc: 14,
      Sp_Unprepare: 15
    };
    var _default = exports.default = procedures;
    module.exports = procedures;
  }
});

// node_modules/tedious/package.json
var require_package = __commonJS({
  "node_modules/tedious/package.json"(exports, module) {
    module.exports = {
      author: "Mike D Pilsbury <mike.pilsbury@gmail.com>",
      contributors: [
        "Alex Robson",
        "Arthur Schreiber",
        "Bret Copeland <bret@atlantisflight.org> (https://github.com/bretcope)",
        "Bryan Ross <bryan@rossipedia.com> (https://github.com/rossipedia)",
        "Ciaran Jessup <ciaranj@gmail.com>",
        "Cort Fritz <cfritz@caa.com>",
        "lastonesky",
        "Patrik Simek <patrik@patriksimek.cz>",
        "Phil Dodderidge <pdodde@poyntz.com>",
        "Zach Aller"
      ],
      name: "tedious",
      description: "A TDS driver, for connecting to MS SQLServer databases.",
      keywords: [
        "sql",
        "database",
        "mssql",
        "sqlserver",
        "sql-server",
        "tds",
        "msnodesql",
        "azure"
      ],
      homepage: "https://github.com/tediousjs/tedious",
      bugs: "https://github.com/tediousjs/tedious/issues",
      license: "MIT",
      version: "18.2.0",
      main: "./lib/tedious.js",
      types: "./lib/tedious.d.ts",
      repository: {
        type: "git",
        url: "https://github.com/tediousjs/tedious.git"
      },
      engines: {
        node: ">=18"
      },
      publishConfig: {
        tag: "next"
      },
      dependencies: {
        "@azure/identity": "^3.4.1",
        "@azure/keyvault-keys": "^4.4.0",
        "@js-joda/core": "^5.6.1",
        "@types/node": ">=18",
        bl: "^6.0.11",
        "iconv-lite": "^0.6.3",
        "js-md4": "^0.3.2",
        "native-duplexpair": "^1.0.0",
        "sprintf-js": "^1.1.3"
      },
      devDependencies: {
        "@babel/cli": "^7.23.9",
        "@babel/core": "^7.23.9",
        "@babel/node": "^7.23.9",
        "@babel/preset-env": "^7.23.9",
        "@babel/preset-typescript": "^7.23.3",
        "@babel/register": "^7.23.7",
        "@types/async": "^3.2.24",
        "@types/bl": "^5.1.0",
        "@types/chai": "^4.3.12",
        "@types/depd": "^1.1.36",
        "@types/lru-cache": "^5.1.1",
        "@types/mocha": "^10.0.6",
        "@types/sprintf-js": "^1.1.4",
        "@typescript-eslint/eslint-plugin": "^7.0.2",
        "@typescript-eslint/parser": "^7.0.2",
        async: "^3.2.5",
        "babel-plugin-istanbul": "^6.1.1",
        chai: "^4.4.1",
        codecov: "^3.8.3",
        eslint: "^8.57.0",
        mitm: "^1.7.2",
        mocha: "^10.3.0",
        nyc: "^15.1.0",
        rimraf: "^5.0.5",
        "semantic-release": "^19.0.3",
        sinon: "^15.2.0",
        typedoc: "^0.25.8",
        typescript: "^5.3.3"
      },
      scripts: {
        docs: "typedoc",
        lint: "eslint src test --ext .js,.ts && tsc",
        test: "mocha --forbid-only test/unit test/unit/token test/unit/tracking-buffer",
        "test-integration": "mocha --forbid-only test/integration/",
        "test-all": "mocha --forbid-only test/unit/ test/unit/token/ test/unit/tracking-buffer test/integration/",
        "build:types": "tsc --project tsconfig.build-types.json",
        build: "rimraf lib && babel src --out-dir lib --extensions .js,.ts && npm run build:types",
        prepublish: "npm run build",
        "semantic-release": "semantic-release"
      },
      babel: {
        sourceMaps: "both",
        ignore: [
          "./src/**/*.d.ts"
        ],
        presets: [
          [
            "@babel/preset-env",
            {
              targets: {
                node: 18
              }
            }
          ],
          [
            "@babel/preset-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ],
        plugins: [
          [
            "@babel/transform-typescript",
            {
              allowDeclareFields: true
            }
          ]
        ]
      },
      mocha: {
        require: "test/setup.js",
        timeout: 5e3,
        extension: [
          "js",
          "ts"
        ]
      },
      nyc: {
        sourceMap: false,
        instrument: false,
        extension: [
          ".ts"
        ]
      }
    };
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    init_process();
    init_buffer();
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tedious/lib/token/handler.js
var require_handler = __commonJS({
  "node_modules/tedious/lib/token/handler.js"(exports) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UnexpectedTokenError = exports.TokenHandler = exports.RequestTokenHandler = exports.Login7TokenHandler = exports.InitialSqlTokenHandler = exports.AttentionTokenHandler = void 0;
    var _request = _interopRequireDefault(require_request());
    var _errors = require_errors();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UnexpectedTokenError = class extends Error {
      constructor(handler, token) {
        super("Unexpected token `" + token.name + "` in `" + handler.constructor.name + "`");
      }
    };
    exports.UnexpectedTokenError = UnexpectedTokenError;
    var TokenHandler = class {
      onInfoMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onErrorMessage(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSSPI(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLanguageChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCharsetChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onSqlCollationChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRoutingChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onPacketSizeChange(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onResetConnection(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onBeginTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onCommitTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRollbackTransaction(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFedAuthInfo(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onFeatureExtAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onLoginAck(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onColMetadata(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onOrder(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onRow(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnStatus(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onReturnValue(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDoneInProc(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDone(token) {
        throw new UnexpectedTokenError(this, token);
      }
      onDatabaseMirroringPartner(token) {
        throw new UnexpectedTokenError(this, token);
      }
    };
    exports.TokenHandler = TokenHandler;
    var InitialSqlTokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        this.connection.emit("error", new Error("Received 'columnMetadata' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onOrder(token) {
        this.connection.emit("error", new Error("Received 'order' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onRow(token) {
        this.connection.emit("error", new Error("Received 'row' when no sqlRequest is in progress"));
        this.connection.close();
      }
      onReturnStatus(token) {
      }
      onReturnValue(token) {
      }
      onDoneProc(token) {
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports.InitialSqlTokenHandler = InitialSqlTokenHandler;
    var Login7TokenHandler = class extends TokenHandler {
      constructor(connection) {
        super();
        this.loginAckReceived = false;
        this.connection = connection;
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        const error = new _errors.ConnectionError(token.message, "ELOGIN");
        const isLoginErrorTransient = this.connection.transientErrorLookup.isTransientError(token.number);
        if (isLoginErrorTransient && this.connection.curTransientRetryCount !== this.connection.config.options.maxRetriesOnTransientErrors) {
          error.isTransient = true;
        }
        this.connection.loginError = error;
      }
      onSSPI(token) {
        if (token.ntlmpacket) {
          this.connection.ntlmpacket = token.ntlmpacket;
          this.connection.ntlmpacketBuffer = token.ntlmpacketBuffer;
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onFedAuthInfo(token) {
        this.fedAuthInfoToken = token;
      }
      onFeatureExtAck(token) {
        const {
          authentication
        } = this.connection.config;
        if (authentication.type === "azure-active-directory-password" || authentication.type === "azure-active-directory-access-token" || authentication.type === "azure-active-directory-msi-vm" || authentication.type === "azure-active-directory-msi-app-service" || authentication.type === "azure-active-directory-service-principal-secret" || authentication.type === "azure-active-directory-default") {
          if (token.fedAuth === void 0) {
            this.connection.loginError = new _errors.ConnectionError("Did not receive Active Directory authentication acknowledgement");
          } else if (token.fedAuth.length !== 0) {
            this.connection.loginError = new _errors.ConnectionError(`Active Directory authentication acknowledgment for ${authentication.type} authentication method includes extra data`);
          }
        } else if (token.fedAuth === void 0 && token.utf8Support === void 0) {
          this.connection.loginError = new _errors.ConnectionError("Received acknowledgement for unknown feature");
        } else if (token.fedAuth) {
          this.connection.loginError = new _errors.ConnectionError("Did not request Active Directory authentication, but received the acknowledgment");
        }
      }
      onLoginAck(token) {
        if (!token.tdsVersion) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unknown TDS version.", "ETDS");
          return;
        }
        if (!token.interface) {
          this.connection.loginError = new _errors.ConnectionError("Server responded with unsupported interface.", "EINTERFACENOTSUPP");
          return;
        }
        this.connection.config.options.tdsVersion = token.tdsVersion;
        this.loginAckReceived = true;
      }
      onRoutingChange(token) {
        const [server] = token.newValue.server.split("\\");
        this.routingData = {
          server,
          port: token.newValue.port
        };
      }
      onDoneInProc(token) {
      }
      onDone(token) {
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onDatabaseMirroringPartner(token) {
      }
    };
    exports.Login7TokenHandler = Login7TokenHandler;
    var RequestTokenHandler = class extends TokenHandler {
      constructor(connection, request) {
        super();
        this.connection = connection;
        this.request = request;
        this.errors = [];
      }
      onInfoMessage(token) {
        this.connection.emit("infoMessage", token);
      }
      onErrorMessage(token) {
        this.connection.emit("errorMessage", token);
        if (!this.request.canceled) {
          const error = new _errors.RequestError(token.message, "EREQUEST");
          error.number = token.number;
          error.state = token.state;
          error.class = token.class;
          error.serverName = token.serverName;
          error.procName = token.procName;
          error.lineNumber = token.lineNumber;
          this.errors.push(error);
          this.request.error = error;
          if (this.request instanceof _request.default && this.errors.length > 1) {
            this.request.error = new AggregateError(this.errors);
          }
        }
      }
      onDatabaseChange(token) {
        this.connection.emit("databaseChange", token.newValue);
      }
      onLanguageChange(token) {
        this.connection.emit("languageChange", token.newValue);
      }
      onCharsetChange(token) {
        this.connection.emit("charsetChange", token.newValue);
      }
      onSqlCollationChange(token) {
        this.connection.databaseCollation = token.newValue;
      }
      onPacketSizeChange(token) {
        this.connection.messageIo.packetSize(token.newValue);
      }
      onBeginTransaction(token) {
        this.connection.transactionDescriptors.push(token.newValue);
        this.connection.inTransaction = true;
      }
      onCommitTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
      }
      onRollbackTransaction(token) {
        this.connection.transactionDescriptors.length = 1;
        this.connection.inTransaction = false;
        this.connection.emit("rollbackTransaction");
      }
      onColMetadata(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.useColumnNames) {
            const columns = /* @__PURE__ */ Object.create(null);
            for (let j = 0, len = token.columns.length; j < len; j++) {
              const col = token.columns[j];
              if (columns[col.colName] == null) {
                columns[col.colName] = col;
              }
            }
            this.request.emit("columnMetadata", columns);
          } else {
            this.request.emit("columnMetadata", token.columns);
          }
        }
      }
      onOrder(token) {
        if (!this.request.canceled) {
          this.request.emit("order", token.orderColumns);
        }
      }
      onRow(token) {
        if (!this.request.canceled) {
          if (this.connection.config.options.rowCollectionOnRequestCompletion) {
            this.request.rows.push(token.columns);
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst.push(token.columns);
          }
          this.request.emit("row", token.columns);
        }
      }
      onReturnStatus(token) {
        if (!this.request.canceled) {
          this.connection.procReturnStatusValue = token.value;
        }
      }
      onReturnValue(token) {
        if (!this.request.canceled) {
          this.request.emit("returnValue", token.paramName, token.value, token.metadata);
        }
      }
      onDoneProc(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("doneProc", token.rowCount, token.more, this.connection.procReturnStatusValue, this.request.rst);
          this.connection.procReturnStatusValue = void 0;
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDoneInProc(token) {
        if (!this.request.canceled) {
          this.request.emit("doneInProc", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onDone(token) {
        if (!this.request.canceled) {
          if (token.sqlError && !this.request.error) {
            this.request.error = new _errors.RequestError("An unknown error has occurred.", "UNKNOWN");
          }
          this.request.emit("done", token.rowCount, token.more, this.request.rst);
          if (token.rowCount !== void 0) {
            this.request.rowCount += token.rowCount;
          }
          if (this.connection.config.options.rowCollectionOnDone) {
            this.request.rst = [];
          }
        }
      }
      onResetConnection(token) {
        this.connection.emit("resetConnection");
      }
    };
    exports.RequestTokenHandler = RequestTokenHandler;
    var AttentionTokenHandler = class extends TokenHandler {
      /**
       * Returns whether an attention acknowledgement was received.
       */
      constructor(connection, request) {
        super();
        this.connection = connection;
        this.request = request;
        this.attentionReceived = false;
      }
      onDone(token) {
        if (token.attention) {
          this.attentionReceived = true;
        }
      }
    };
    exports.AttentionTokenHandler = AttentionTokenHandler;
  }
});

// node_modules/tedious/lib/connection.js
var require_connection = __commonJS({
  "node_modules/tedious/lib/connection.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require_crypto());
    var _os = _interopRequireDefault(require_os());
    var tls = _interopRequireWildcard(require_tls());
    var net = _interopRequireWildcard(require_net());
    var _dns = _interopRequireDefault(require_dns());
    var _constants = _interopRequireDefault(require_constants());
    var _stream = require_stream();
    var _identity = (init_src2(), __toCommonJS(src_exports));
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _debug = _interopRequireDefault(require_debug());
    var _events = require_events();
    var _instanceLookup = require_instance_lookup();
    var _transientErrorLookup = require_transient_error_lookup();
    var _packet = require_packet();
    var _preloginPayload = _interopRequireDefault(require_prelogin_payload());
    var _login7Payload = _interopRequireDefault(require_login7_payload());
    var _ntlmPayload = _interopRequireDefault(require_ntlm_payload());
    var _request = _interopRequireDefault(require_request());
    var _rpcrequestPayload = _interopRequireDefault(require_rpcrequest_payload());
    var _sqlbatchPayload = _interopRequireDefault(require_sqlbatch_payload());
    var _messageIo = _interopRequireDefault(require_message_io());
    var _tokenStreamParser = require_token_stream_parser();
    var _transaction = require_transaction();
    var _errors = require_errors();
    var _connector = require_connector();
    var _library = require_library();
    var _tdsVersions = require_tds_versions();
    var _message = _interopRequireDefault(require_message());
    var _ntlm = require_ntlm();
    var _dataType = require_data_type();
    var _bulkLoadPayload = require_bulk_load_payload();
    var _specialStoredProcedure = _interopRequireDefault(require_special_stored_procedure());
    var _package = require_package();
    var _url = require_url();
    var _handler = require_handler();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != typeof e && "function" != typeof e)
        return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var KEEP_ALIVE_INITIAL_DELAY = 30 * 1e3;
    var DEFAULT_CONNECT_TIMEOUT = 15 * 1e3;
    var DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1e3;
    var DEFAULT_CANCEL_TIMEOUT = 5 * 1e3;
    var DEFAULT_CONNECT_RETRY_INTERVAL = 500;
    var DEFAULT_PACKET_SIZE = 4 * 1024;
    var DEFAULT_TEXTSIZE = 2147483647;
    var DEFAULT_DATEFIRST = 7;
    var DEFAULT_PORT = 1433;
    var DEFAULT_TDS_VERSION = "7_4";
    var DEFAULT_LANGUAGE = "us_english";
    var DEFAULT_DATEFORMAT = "mdy";
    var CLEANUP_TYPE = {
      NORMAL: 0,
      REDIRECT: 1,
      RETRY: 2
    };
    var Connection = class extends _events.EventEmitter {
      /**
       * @private
       */
      /**
       * Note: be aware of the different options field:
       * 1. config.authentication.options
       * 2. config.options
       *
       * ```js
       * const { Connection } = require('tedious');
       *
       * const config = {
       *  "authentication": {
       *    ...,
       *    "options": {...}
       *  },
       *  "options": {...}
       * };
       *
       * const connection = new Connection(config);
       * ```
       *
       * @param config
       */
      constructor(config) {
        super();
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        /**
         * @private
         */
        __publicField(this, "_cancelAfterRequestSent");
        if (typeof config !== "object" || config === null) {
          throw new TypeError('The "config" argument is required and must be of type Object.');
        }
        if (typeof config.server !== "string") {
          throw new TypeError('The "config.server" property is required and must be of type string.');
        }
        this.fedAuthRequired = false;
        let authentication;
        if (config.authentication !== void 0) {
          if (typeof config.authentication !== "object" || config.authentication === null) {
            throw new TypeError('The "config.authentication" property must be of type Object.');
          }
          const type = config.authentication.type;
          const options = config.authentication.options === void 0 ? {} : config.authentication.options;
          if (typeof type !== "string") {
            throw new TypeError('The "config.authentication.type" property must be of type string.');
          }
          if (type !== "default" && type !== "ntlm" && type !== "azure-active-directory-password" && type !== "azure-active-directory-access-token" && type !== "azure-active-directory-msi-vm" && type !== "azure-active-directory-msi-app-service" && type !== "azure-active-directory-service-principal-secret" && type !== "azure-active-directory-default") {
            throw new TypeError('The "type" property must one of "default", "ntlm", "azure-active-directory-password", "azure-active-directory-access-token", "azure-active-directory-default", "azure-active-directory-msi-vm" or "azure-active-directory-msi-app-service" or "azure-active-directory-service-principal-secret".');
          }
          if (typeof options !== "object" || options === null) {
            throw new TypeError('The "config.authentication.options" property must be of type object.');
          }
          if (type === "ntlm") {
            if (typeof options.domain !== "string") {
              throw new TypeError('The "config.authentication.options.domain" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication = {
              type: "ntlm",
              options: {
                userName: options.userName,
                password: options.password,
                domain: options.domain && options.domain.toUpperCase()
              }
            };
          } else if (type === "azure-active-directory-password") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            if (options.tenantId !== void 0 && typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-password",
              options: {
                userName: options.userName,
                password: options.password,
                tenantId: options.tenantId,
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-access-token") {
            if (typeof options.token !== "string") {
              throw new TypeError('The "config.authentication.options.token" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-access-token",
              options: {
                token: options.token
              }
            };
          } else if (type === "azure-active-directory-msi-vm") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-msi-vm",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-default") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-default",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-msi-app-service") {
            if (options.clientId !== void 0 && typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-msi-app-service",
              options: {
                clientId: options.clientId
              }
            };
          } else if (type === "azure-active-directory-service-principal-secret") {
            if (typeof options.clientId !== "string") {
              throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
            }
            if (typeof options.clientSecret !== "string") {
              throw new TypeError('The "config.authentication.options.clientSecret" property must be of type string.');
            }
            if (typeof options.tenantId !== "string") {
              throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
            }
            authentication = {
              type: "azure-active-directory-service-principal-secret",
              options: {
                clientId: options.clientId,
                clientSecret: options.clientSecret,
                tenantId: options.tenantId
              }
            };
          } else {
            if (options.userName !== void 0 && typeof options.userName !== "string") {
              throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
            }
            if (options.password !== void 0 && typeof options.password !== "string") {
              throw new TypeError('The "config.authentication.options.password" property must be of type string.');
            }
            authentication = {
              type: "default",
              options: {
                userName: options.userName,
                password: options.password
              }
            };
          }
        } else {
          authentication = {
            type: "default",
            options: {
              userName: void 0,
              password: void 0
            }
          };
        }
        this.config = {
          server: config.server,
          authentication,
          options: {
            abortTransactionOnError: false,
            appName: void 0,
            camelCaseColumns: false,
            cancelTimeout: DEFAULT_CANCEL_TIMEOUT,
            columnEncryptionKeyCacheTTL: 2 * 60 * 60 * 1e3,
            // Units: milliseconds
            columnEncryptionSetting: false,
            columnNameReplacer: void 0,
            connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,
            connectTimeout: DEFAULT_CONNECT_TIMEOUT,
            connector: void 0,
            connectionIsolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            cryptoCredentialsDetails: {},
            database: void 0,
            datefirst: DEFAULT_DATEFIRST,
            dateFormat: DEFAULT_DATEFORMAT,
            debug: {
              data: false,
              packet: false,
              payload: false,
              token: false
            },
            enableAnsiNull: true,
            enableAnsiNullDefault: true,
            enableAnsiPadding: true,
            enableAnsiWarnings: true,
            enableArithAbort: true,
            enableConcatNullYieldsNull: true,
            enableCursorCloseOnCommit: null,
            enableImplicitTransactions: false,
            enableNumericRoundabort: false,
            enableQuotedIdentifier: true,
            encrypt: true,
            fallbackToDefaultDb: false,
            encryptionKeyStoreProviders: void 0,
            instanceName: void 0,
            isolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
            language: DEFAULT_LANGUAGE,
            localAddress: void 0,
            maxRetriesOnTransientErrors: 3,
            multiSubnetFailover: false,
            packetSize: DEFAULT_PACKET_SIZE,
            port: DEFAULT_PORT,
            readOnlyIntent: false,
            requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,
            rowCollectionOnDone: false,
            rowCollectionOnRequestCompletion: false,
            serverName: void 0,
            serverSupportsColumnEncryption: false,
            tdsVersion: DEFAULT_TDS_VERSION,
            textsize: DEFAULT_TEXTSIZE,
            trustedServerNameAE: void 0,
            trustServerCertificate: false,
            useColumnNames: false,
            useUTC: true,
            workstationId: void 0,
            lowerCaseGuids: false
          }
        };
        if (config.options) {
          if (config.options.port && config.options.instanceName) {
            throw new Error("Port and instanceName are mutually exclusive, but " + config.options.port + " and " + config.options.instanceName + " provided");
          }
          if (config.options.abortTransactionOnError !== void 0) {
            if (typeof config.options.abortTransactionOnError !== "boolean" && config.options.abortTransactionOnError !== null) {
              throw new TypeError('The "config.options.abortTransactionOnError" property must be of type string or null.');
            }
            this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;
          }
          if (config.options.appName !== void 0) {
            if (typeof config.options.appName !== "string") {
              throw new TypeError('The "config.options.appName" property must be of type string.');
            }
            this.config.options.appName = config.options.appName;
          }
          if (config.options.camelCaseColumns !== void 0) {
            if (typeof config.options.camelCaseColumns !== "boolean") {
              throw new TypeError('The "config.options.camelCaseColumns" property must be of type boolean.');
            }
            this.config.options.camelCaseColumns = config.options.camelCaseColumns;
          }
          if (config.options.cancelTimeout !== void 0) {
            if (typeof config.options.cancelTimeout !== "number") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type number.');
            }
            this.config.options.cancelTimeout = config.options.cancelTimeout;
          }
          if (config.options.columnNameReplacer) {
            if (typeof config.options.columnNameReplacer !== "function") {
              throw new TypeError('The "config.options.cancelTimeout" property must be of type function.');
            }
            this.config.options.columnNameReplacer = config.options.columnNameReplacer;
          }
          if (config.options.connectionIsolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.connectionIsolationLevel, "config.options.connectionIsolationLevel");
            this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;
          }
          if (config.options.connectTimeout !== void 0) {
            if (typeof config.options.connectTimeout !== "number") {
              throw new TypeError('The "config.options.connectTimeout" property must be of type number.');
            }
            this.config.options.connectTimeout = config.options.connectTimeout;
          }
          if (config.options.connector !== void 0) {
            if (typeof config.options.connector !== "function") {
              throw new TypeError('The "config.options.connector" property must be a function.');
            }
            this.config.options.connector = config.options.connector;
          }
          if (config.options.cryptoCredentialsDetails !== void 0) {
            if (typeof config.options.cryptoCredentialsDetails !== "object" || config.options.cryptoCredentialsDetails === null) {
              throw new TypeError('The "config.options.cryptoCredentialsDetails" property must be of type Object.');
            }
            this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;
          }
          if (config.options.database !== void 0) {
            if (typeof config.options.database !== "string") {
              throw new TypeError('The "config.options.database" property must be of type string.');
            }
            this.config.options.database = config.options.database;
          }
          if (config.options.datefirst !== void 0) {
            if (typeof config.options.datefirst !== "number" && config.options.datefirst !== null) {
              throw new TypeError('The "config.options.datefirst" property must be of type number.');
            }
            if (config.options.datefirst !== null && (config.options.datefirst < 1 || config.options.datefirst > 7)) {
              throw new RangeError('The "config.options.datefirst" property must be >= 1 and <= 7');
            }
            this.config.options.datefirst = config.options.datefirst;
          }
          if (config.options.dateFormat !== void 0) {
            if (typeof config.options.dateFormat !== "string" && config.options.dateFormat !== null) {
              throw new TypeError('The "config.options.dateFormat" property must be of type string or null.');
            }
            this.config.options.dateFormat = config.options.dateFormat;
          }
          if (config.options.debug) {
            if (config.options.debug.data !== void 0) {
              if (typeof config.options.debug.data !== "boolean") {
                throw new TypeError('The "config.options.debug.data" property must be of type boolean.');
              }
              this.config.options.debug.data = config.options.debug.data;
            }
            if (config.options.debug.packet !== void 0) {
              if (typeof config.options.debug.packet !== "boolean") {
                throw new TypeError('The "config.options.debug.packet" property must be of type boolean.');
              }
              this.config.options.debug.packet = config.options.debug.packet;
            }
            if (config.options.debug.payload !== void 0) {
              if (typeof config.options.debug.payload !== "boolean") {
                throw new TypeError('The "config.options.debug.payload" property must be of type boolean.');
              }
              this.config.options.debug.payload = config.options.debug.payload;
            }
            if (config.options.debug.token !== void 0) {
              if (typeof config.options.debug.token !== "boolean") {
                throw new TypeError('The "config.options.debug.token" property must be of type boolean.');
              }
              this.config.options.debug.token = config.options.debug.token;
            }
          }
          if (config.options.enableAnsiNull !== void 0) {
            if (typeof config.options.enableAnsiNull !== "boolean" && config.options.enableAnsiNull !== null) {
              throw new TypeError('The "config.options.enableAnsiNull" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNull = config.options.enableAnsiNull;
          }
          if (config.options.enableAnsiNullDefault !== void 0) {
            if (typeof config.options.enableAnsiNullDefault !== "boolean" && config.options.enableAnsiNullDefault !== null) {
              throw new TypeError('The "config.options.enableAnsiNullDefault" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;
          }
          if (config.options.enableAnsiPadding !== void 0) {
            if (typeof config.options.enableAnsiPadding !== "boolean" && config.options.enableAnsiPadding !== null) {
              throw new TypeError('The "config.options.enableAnsiPadding" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;
          }
          if (config.options.enableAnsiWarnings !== void 0) {
            if (typeof config.options.enableAnsiWarnings !== "boolean" && config.options.enableAnsiWarnings !== null) {
              throw new TypeError('The "config.options.enableAnsiWarnings" property must be of type boolean or null.');
            }
            this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;
          }
          if (config.options.enableArithAbort !== void 0) {
            if (typeof config.options.enableArithAbort !== "boolean" && config.options.enableArithAbort !== null) {
              throw new TypeError('The "config.options.enableArithAbort" property must be of type boolean or null.');
            }
            this.config.options.enableArithAbort = config.options.enableArithAbort;
          }
          if (config.options.enableConcatNullYieldsNull !== void 0) {
            if (typeof config.options.enableConcatNullYieldsNull !== "boolean" && config.options.enableConcatNullYieldsNull !== null) {
              throw new TypeError('The "config.options.enableConcatNullYieldsNull" property must be of type boolean or null.');
            }
            this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;
          }
          if (config.options.enableCursorCloseOnCommit !== void 0) {
            if (typeof config.options.enableCursorCloseOnCommit !== "boolean" && config.options.enableCursorCloseOnCommit !== null) {
              throw new TypeError('The "config.options.enableCursorCloseOnCommit" property must be of type boolean or null.');
            }
            this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;
          }
          if (config.options.enableImplicitTransactions !== void 0) {
            if (typeof config.options.enableImplicitTransactions !== "boolean" && config.options.enableImplicitTransactions !== null) {
              throw new TypeError('The "config.options.enableImplicitTransactions" property must be of type boolean or null.');
            }
            this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;
          }
          if (config.options.enableNumericRoundabort !== void 0) {
            if (typeof config.options.enableNumericRoundabort !== "boolean" && config.options.enableNumericRoundabort !== null) {
              throw new TypeError('The "config.options.enableNumericRoundabort" property must be of type boolean or null.');
            }
            this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;
          }
          if (config.options.enableQuotedIdentifier !== void 0) {
            if (typeof config.options.enableQuotedIdentifier !== "boolean" && config.options.enableQuotedIdentifier !== null) {
              throw new TypeError('The "config.options.enableQuotedIdentifier" property must be of type boolean or null.');
            }
            this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;
          }
          if (config.options.encrypt !== void 0) {
            if (typeof config.options.encrypt !== "boolean") {
              if (config.options.encrypt !== "strict") {
                throw new TypeError('The "encrypt" property must be set to "strict", or of type boolean.');
              }
            }
            this.config.options.encrypt = config.options.encrypt;
          }
          if (config.options.fallbackToDefaultDb !== void 0) {
            if (typeof config.options.fallbackToDefaultDb !== "boolean") {
              throw new TypeError('The "config.options.fallbackToDefaultDb" property must be of type boolean.');
            }
            this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;
          }
          if (config.options.instanceName !== void 0) {
            if (typeof config.options.instanceName !== "string") {
              throw new TypeError('The "config.options.instanceName" property must be of type string.');
            }
            this.config.options.instanceName = config.options.instanceName;
            this.config.options.port = void 0;
          }
          if (config.options.isolationLevel !== void 0) {
            (0, _transaction.assertValidIsolationLevel)(config.options.isolationLevel, "config.options.isolationLevel");
            this.config.options.isolationLevel = config.options.isolationLevel;
          }
          if (config.options.language !== void 0) {
            if (typeof config.options.language !== "string" && config.options.language !== null) {
              throw new TypeError('The "config.options.language" property must be of type string or null.');
            }
            this.config.options.language = config.options.language;
          }
          if (config.options.localAddress !== void 0) {
            if (typeof config.options.localAddress !== "string") {
              throw new TypeError('The "config.options.localAddress" property must be of type string.');
            }
            this.config.options.localAddress = config.options.localAddress;
          }
          if (config.options.multiSubnetFailover !== void 0) {
            if (typeof config.options.multiSubnetFailover !== "boolean") {
              throw new TypeError('The "config.options.multiSubnetFailover" property must be of type boolean.');
            }
            this.config.options.multiSubnetFailover = config.options.multiSubnetFailover;
          }
          if (config.options.packetSize !== void 0) {
            if (typeof config.options.packetSize !== "number") {
              throw new TypeError('The "config.options.packetSize" property must be of type number.');
            }
            this.config.options.packetSize = config.options.packetSize;
          }
          if (config.options.port !== void 0) {
            if (typeof config.options.port !== "number") {
              throw new TypeError('The "config.options.port" property must be of type number.');
            }
            if (config.options.port <= 0 || config.options.port >= 65536) {
              throw new RangeError('The "config.options.port" property must be > 0 and < 65536');
            }
            this.config.options.port = config.options.port;
            this.config.options.instanceName = void 0;
          }
          if (config.options.readOnlyIntent !== void 0) {
            if (typeof config.options.readOnlyIntent !== "boolean") {
              throw new TypeError('The "config.options.readOnlyIntent" property must be of type boolean.');
            }
            this.config.options.readOnlyIntent = config.options.readOnlyIntent;
          }
          if (config.options.requestTimeout !== void 0) {
            if (typeof config.options.requestTimeout !== "number") {
              throw new TypeError('The "config.options.requestTimeout" property must be of type number.');
            }
            this.config.options.requestTimeout = config.options.requestTimeout;
          }
          if (config.options.maxRetriesOnTransientErrors !== void 0) {
            if (typeof config.options.maxRetriesOnTransientErrors !== "number") {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be of type number.');
            }
            if (config.options.maxRetriesOnTransientErrors < 0) {
              throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be equal or greater than 0.');
            }
            this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;
          }
          if (config.options.connectionRetryInterval !== void 0) {
            if (typeof config.options.connectionRetryInterval !== "number") {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be of type number.');
            }
            if (config.options.connectionRetryInterval <= 0) {
              throw new TypeError('The "config.options.connectionRetryInterval" property must be greater than 0.');
            }
            this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;
          }
          if (config.options.rowCollectionOnDone !== void 0) {
            if (typeof config.options.rowCollectionOnDone !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnDone" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;
          }
          if (config.options.rowCollectionOnRequestCompletion !== void 0) {
            if (typeof config.options.rowCollectionOnRequestCompletion !== "boolean") {
              throw new TypeError('The "config.options.rowCollectionOnRequestCompletion" property must be of type boolean.');
            }
            this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;
          }
          if (config.options.tdsVersion !== void 0) {
            if (typeof config.options.tdsVersion !== "string") {
              throw new TypeError('The "config.options.tdsVersion" property must be of type string.');
            }
            this.config.options.tdsVersion = config.options.tdsVersion;
          }
          if (config.options.textsize !== void 0) {
            if (typeof config.options.textsize !== "number" && config.options.textsize !== null) {
              throw new TypeError('The "config.options.textsize" property must be of type number or null.');
            }
            if (config.options.textsize > 2147483647) {
              throw new TypeError(`The "config.options.textsize" can't be greater than 2147483647.`);
            } else if (config.options.textsize < -1) {
              throw new TypeError(`The "config.options.textsize" can't be smaller than -1.`);
            }
            this.config.options.textsize = config.options.textsize | 0;
          }
          if (config.options.trustServerCertificate !== void 0) {
            if (typeof config.options.trustServerCertificate !== "boolean") {
              throw new TypeError('The "config.options.trustServerCertificate" property must be of type boolean.');
            }
            this.config.options.trustServerCertificate = config.options.trustServerCertificate;
          }
          if (config.options.serverName !== void 0) {
            if (typeof config.options.serverName !== "string") {
              throw new TypeError('The "config.options.serverName" property must be of type string.');
            }
            this.config.options.serverName = config.options.serverName;
          }
          if (config.options.useColumnNames !== void 0) {
            if (typeof config.options.useColumnNames !== "boolean") {
              throw new TypeError('The "config.options.useColumnNames" property must be of type boolean.');
            }
            this.config.options.useColumnNames = config.options.useColumnNames;
          }
          if (config.options.useUTC !== void 0) {
            if (typeof config.options.useUTC !== "boolean") {
              throw new TypeError('The "config.options.useUTC" property must be of type boolean.');
            }
            this.config.options.useUTC = config.options.useUTC;
          }
          if (config.options.workstationId !== void 0) {
            if (typeof config.options.workstationId !== "string") {
              throw new TypeError('The "config.options.workstationId" property must be of type string.');
            }
            this.config.options.workstationId = config.options.workstationId;
          }
          if (config.options.lowerCaseGuids !== void 0) {
            if (typeof config.options.lowerCaseGuids !== "boolean") {
              throw new TypeError('The "config.options.lowerCaseGuids" property must be of type boolean.');
            }
            this.config.options.lowerCaseGuids = config.options.lowerCaseGuids;
          }
        }
        this.secureContextOptions = this.config.options.cryptoCredentialsDetails;
        if (this.secureContextOptions.secureOptions === void 0) {
          this.secureContextOptions = Object.create(this.secureContextOptions, {
            secureOptions: {
              value: _constants.default.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
            }
          });
        }
        this.debug = this.createDebug();
        this.inTransaction = false;
        this.transactionDescriptors = [Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])];
        this.transactionDepth = 0;
        this.isSqlBatch = false;
        this.closed = false;
        this.messageBuffer = Buffer.alloc(0);
        this.curTransientRetryCount = 0;
        this.transientErrorLookup = new _transientErrorLookup.TransientErrorLookup();
        this.state = this.STATE.INITIALIZED;
        this._cancelAfterRequestSent = () => {
          this.messageIo.sendMessage(_packet.TYPE.ATTENTION);
          this.createCancelTimer();
        };
      }
      connect(connectListener) {
        if (this.state !== this.STATE.INITIALIZED) {
          throw new _errors.ConnectionError("`.connect` can not be called on a Connection in `" + this.state.name + "` state.");
        }
        if (connectListener) {
          const onConnect = (err) => {
            this.removeListener("error", onError);
            connectListener(err);
          };
          const onError = (err) => {
            this.removeListener("connect", onConnect);
            connectListener(err);
          };
          this.once("connect", onConnect);
          this.once("error", onError);
        }
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * The server has reported that the charset has changed.
       */
      /**
       * The attempt to connect and validate has completed.
       */
      /**
       * The server has reported that the active database has changed.
       * This may be as a result of a successful login, or a `use` statement.
       */
      /**
       * A debug message is available. It may be logged or ignored.
       */
      /**
       * Internal error occurs.
       */
      /**
       * The server has issued an error message.
       */
      /**
       * The connection has ended.
       *
       * This may be as a result of the client calling [[close]], the server
       * closing the connection, or a network error.
       */
      /**
       * The server has issued an information message.
       */
      /**
       * The server has reported that the language has changed.
       */
      /**
       * The connection was reset.
       */
      /**
       * A secure connection has been established.
       */
      on(event, listener) {
        return super.on(event, listener);
      }
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      /**
       * @private
       */
      emit(event, ...args) {
        return super.emit(event, ...args);
      }
      /**
       * Closes the connection to the database.
       *
       * The [[Event_end]] will be emitted once the connection has been closed.
       */
      close() {
        this.transitionTo(this.STATE.FINAL);
      }
      /**
       * @private
       */
      initialiseConnection() {
        const signal = this.createConnectTimer();
        if (this.config.options.port) {
          return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
        } else {
          return (0, _instanceLookup.instanceLookup)({
            server: this.config.server,
            instanceName: this.config.options.instanceName,
            timeout: this.config.options.connectTimeout,
            signal
          }).then((port) => {
            process.nextTick(() => {
              this.connectOnPort(port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
            });
          }, (err) => {
            this.clearConnectTimer();
            if (signal.aborted) {
              return;
            }
            process.nextTick(() => {
              this.emit("connect", new _errors.ConnectionError(err.message, "EINSTLOOKUP"));
            });
          });
        }
      }
      /**
       * @private
       */
      cleanupConnection(cleanupType) {
        if (!this.closed) {
          this.clearConnectTimer();
          this.clearRequestTimer();
          this.clearRetryTimer();
          this.closeConnection();
          if (cleanupType === CLEANUP_TYPE.REDIRECT) {
            this.emit("rerouting");
          } else if (cleanupType !== CLEANUP_TYPE.RETRY) {
            process.nextTick(() => {
              this.emit("end");
            });
          }
          const request = this.request;
          if (request) {
            const err = new _errors.RequestError("Connection closed before request completed.", "ECLOSE");
            request.callback(err);
            this.request = void 0;
          }
          this.closed = true;
          this.loginError = void 0;
        }
      }
      /**
       * @private
       */
      createDebug() {
        const debug = new _debug.default(this.config.options.debug);
        debug.on("debug", (message) => {
          this.emit("debug", message);
        });
        return debug;
      }
      /**
       * @private
       */
      createTokenStreamParser(message, handler) {
        return new _tokenStreamParser.Parser(message, this.debug, handler, this.config.options);
      }
      socketHandlingForSendPreLogin(socket) {
        socket.on("error", (error) => {
          this.socketError(error);
        });
        socket.on("close", () => {
          this.socketClose();
        });
        socket.on("end", () => {
          this.socketEnd();
        });
        socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);
        this.messageIo = new _messageIo.default(socket, this.config.options.packetSize, this.debug);
        this.messageIo.on("secure", (cleartext) => {
          this.emit("secure", cleartext);
        });
        this.socket = socket;
        this.closed = false;
        this.debug.log("connected to " + this.config.server + ":" + this.config.options.port);
        this.sendPreLogin();
        this.transitionTo(this.STATE.SENT_PRELOGIN);
      }
      wrapWithTls(socket, signal) {
        signal.throwIfAborted();
        return new Promise((resolve, reject) => {
          const secureContext = tls.createSecureContext(this.secureContextOptions);
          const serverName = !net.isIP(this.config.server) ? this.config.server : "";
          const encryptOptions = {
            host: this.config.server,
            socket,
            ALPNProtocols: ["tds/8.0"],
            secureContext,
            servername: this.config.options.serverName ? this.config.options.serverName : serverName
          };
          const encryptsocket = tls.connect(encryptOptions);
          const onAbort = () => {
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(signal.reason);
          };
          const onError = (err) => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            encryptsocket.destroy();
            reject(err);
          };
          const onConnect = () => {
            signal.removeEventListener("abort", onAbort);
            encryptsocket.removeListener("error", onError);
            encryptsocket.removeListener("connect", onConnect);
            resolve(encryptsocket);
          };
          signal.addEventListener("abort", onAbort, {
            once: true
          });
          encryptsocket.on("error", onError);
          encryptsocket.on("secureConnect", onConnect);
        });
      }
      connectOnPort(port, multiSubnetFailover, signal, customConnector) {
        const connectOpts = {
          host: this.routingData ? this.routingData.server : this.config.server,
          port: this.routingData ? this.routingData.port : port,
          localAddress: this.config.options.localAddress
        };
        const connect = customConnector || (multiSubnetFailover ? _connector.connectInParallel : _connector.connectInSequence);
        (async () => {
          let socket = await connect(connectOpts, _dns.default.lookup, signal);
          if (this.config.options.encrypt === "strict") {
            try {
              socket = await this.wrapWithTls(socket, signal);
            } catch (err) {
              socket.end();
              throw err;
            }
          }
          this.socketHandlingForSendPreLogin(socket);
        })().catch((err) => {
          this.clearConnectTimer();
          if (signal.aborted) {
            return;
          }
          process.nextTick(() => {
            this.socketError(err);
          });
        });
      }
      /**
       * @private
       */
      closeConnection() {
        if (this.socket) {
          this.socket.destroy();
        }
      }
      /**
       * @private
       */
      createConnectTimer() {
        const controller = new AbortController();
        this.connectTimer = setTimeout(() => {
          controller.abort();
          this.connectTimeout();
        }, this.config.options.connectTimeout);
        return controller.signal;
      }
      /**
       * @private
       */
      createCancelTimer() {
        this.clearCancelTimer();
        const timeout = this.config.options.cancelTimeout;
        if (timeout > 0) {
          this.cancelTimer = setTimeout(() => {
            this.cancelTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRequestTimer() {
        this.clearRequestTimer();
        const request = this.request;
        const timeout = request.timeout !== void 0 ? request.timeout : this.config.options.requestTimeout;
        if (timeout) {
          this.requestTimer = setTimeout(() => {
            this.requestTimeout();
          }, timeout);
        }
      }
      /**
       * @private
       */
      createRetryTimer() {
        this.clearRetryTimer();
        this.retryTimer = setTimeout(() => {
          this.retryTimeout();
        }, this.config.options.connectionRetryInterval);
      }
      /**
       * @private
       */
      connectTimeout() {
        const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
        const server = this.routingData ? this.routingData.server : this.config.server;
        const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
        const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
        const message = `Failed to connect to ${server}${port}${routingMessage} in ${this.config.options.connectTimeout}ms`;
        this.debug.log(message);
        this.emit("connect", new _errors.ConnectionError(message, "ETIMEOUT"));
        this.connectTimer = void 0;
        this.dispatchEvent("connectTimeout");
      }
      /**
       * @private
       */
      cancelTimeout() {
        const message = `Failed to cancel request in ${this.config.options.cancelTimeout}ms`;
        this.debug.log(message);
        this.dispatchEvent("socketError", new _errors.ConnectionError(message, "ETIMEOUT"));
      }
      /**
       * @private
       */
      requestTimeout() {
        this.requestTimer = void 0;
        const request = this.request;
        request.cancel();
        const timeout = request.timeout !== void 0 ? request.timeout : this.config.options.requestTimeout;
        const message = "Timeout: Request failed to complete in " + timeout + "ms";
        request.error = new _errors.RequestError(message, "ETIMEOUT");
      }
      /**
       * @private
       */
      retryTimeout() {
        this.retryTimer = void 0;
        this.emit("retry");
        this.transitionTo(this.STATE.CONNECTING);
      }
      /**
       * @private
       */
      clearConnectTimer() {
        if (this.connectTimer) {
          clearTimeout(this.connectTimer);
          this.connectTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearCancelTimer() {
        if (this.cancelTimer) {
          clearTimeout(this.cancelTimer);
          this.cancelTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRequestTimer() {
        if (this.requestTimer) {
          clearTimeout(this.requestTimer);
          this.requestTimer = void 0;
        }
      }
      /**
       * @private
       */
      clearRetryTimer() {
        if (this.retryTimer) {
          clearTimeout(this.retryTimer);
          this.retryTimer = void 0;
        }
      }
      /**
       * @private
       */
      transitionTo(newState) {
        if (this.state === newState) {
          this.debug.log("State is already " + newState.name);
          return;
        }
        if (this.state && this.state.exit) {
          this.state.exit.call(this, newState);
        }
        this.debug.log("State change: " + (this.state ? this.state.name : "undefined") + " -> " + newState.name);
        this.state = newState;
        if (this.state.enter) {
          this.state.enter.apply(this);
        }
      }
      /**
       * @private
       */
      getEventHandler(eventName) {
        const handler = this.state.events[eventName];
        if (!handler) {
          throw new Error(`No event '${eventName}' in state '${this.state.name}'`);
        }
        return handler;
      }
      /**
       * @private
       */
      dispatchEvent(eventName, ...args) {
        const handler = this.state.events[eventName];
        if (handler) {
          handler.apply(this, args);
        } else {
          this.emit("error", new Error(`No event '${eventName}' in state '${this.state.name}'`));
          this.close();
        }
      }
      /**
       * @private
       */
      socketError(error) {
        if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {
          const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
          const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : "";
          const message = `Failed to connect to ${server}${port}${routingMessage} - ${error.message}`;
          this.debug.log(message);
          this.emit("connect", new _errors.ConnectionError(message, "ESOCKET"));
        } else {
          const message = `Connection lost - ${error.message}`;
          this.debug.log(message);
          this.emit("error", new _errors.ConnectionError(message, "ESOCKET"));
        }
        this.dispatchEvent("socketError", error);
      }
      /**
       * @private
       */
      socketEnd() {
        this.debug.log("socket ended");
        if (this.state !== this.STATE.FINAL) {
          const error = new Error("socket hang up");
          error.code = "ECONNRESET";
          this.socketError(error);
        }
      }
      /**
       * @private
       */
      socketClose() {
        this.debug.log("connection to " + this.config.server + ":" + this.config.options.port + " closed");
        if (this.state === this.STATE.REROUTING) {
          this.debug.log("Rerouting to " + this.routingData.server + ":" + this.routingData.port);
          this.dispatchEvent("reconnect");
        } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {
          const server = this.routingData ? this.routingData.server : this.config.server;
          const port = this.routingData ? this.routingData.port : this.config.options.port;
          this.debug.log("Retry after transient failure connecting to " + server + ":" + port);
          this.dispatchEvent("retry");
        } else {
          this.transitionTo(this.STATE.FINAL);
        }
      }
      /**
       * @private
       */
      sendPreLogin() {
        const [, major, minor, build] = /^(\d+)\.(\d+)\.(\d+)/.exec(_package.version) ?? ["0.0.0", "0", "0", "0"];
        const payload = new _preloginPayload.default({
          // If encrypt setting is set to 'strict', then we should have already done the encryption before calling
          // this function. Therefore, the encrypt will be set to false here.
          // Otherwise, we will set encrypt here based on the encrypt Boolean value from the configuration.
          encrypt: typeof this.config.options.encrypt === "boolean" && this.config.options.encrypt,
          version: {
            major: Number(major),
            minor: Number(minor),
            build: Number(build),
            subbuild: 0
          }
        });
        this.messageIo.sendMessage(_packet.TYPE.PRELOGIN, payload.data);
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendLogin7Packet() {
        const payload = new _login7Payload.default({
          tdsVersion: _tdsVersions.versions[this.config.options.tdsVersion],
          packetSize: this.config.options.packetSize,
          clientProgVer: 0,
          clientPid: process.pid,
          connectionId: 0,
          clientTimeZone: (/* @__PURE__ */ new Date()).getTimezoneOffset(),
          clientLcid: 1033
        });
        const {
          authentication
        } = this.config;
        switch (authentication.type) {
          case "azure-active-directory-password":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "default"
            };
            break;
          case "azure-active-directory-access-token":
            payload.fedAuth = {
              type: "SECURITYTOKEN",
              echo: this.fedAuthRequired,
              fedAuthToken: authentication.options.token
            };
            break;
          case "azure-active-directory-msi-vm":
          case "azure-active-directory-default":
          case "azure-active-directory-msi-app-service":
          case "azure-active-directory-service-principal-secret":
            payload.fedAuth = {
              type: "ADAL",
              echo: this.fedAuthRequired,
              workflow: "integrated"
            };
            break;
          case "ntlm":
            payload.sspi = (0, _ntlm.createNTLMRequest)({
              domain: authentication.options.domain
            });
            break;
          default:
            payload.userName = authentication.options.userName;
            payload.password = authentication.options.password;
        }
        payload.hostname = this.config.options.workstationId || _os.default.hostname();
        payload.serverName = this.routingData ? this.routingData.server : this.config.server;
        payload.appName = this.config.options.appName || "Tedious";
        payload.libraryName = _library.name;
        payload.language = this.config.options.language;
        payload.database = this.config.options.database;
        payload.clientId = Buffer.from([1, 2, 3, 4, 5, 6]);
        payload.readOnlyIntent = this.config.options.readOnlyIntent;
        payload.initDbFatal = !this.config.options.fallbackToDefaultDb;
        this.routingData = void 0;
        this.messageIo.sendMessage(_packet.TYPE.LOGIN7, payload.toBuffer());
        this.debug.payload(function() {
          return payload.toString("  ");
        });
      }
      /**
       * @private
       */
      sendFedAuthTokenMessage(token) {
        const accessTokenLen = Buffer.byteLength(token, "ucs2");
        const data = Buffer.alloc(8 + accessTokenLen);
        let offset = 0;
        offset = data.writeUInt32LE(accessTokenLen + 4, offset);
        offset = data.writeUInt32LE(accessTokenLen, offset);
        data.write(token, offset, "ucs2");
        this.messageIo.sendMessage(_packet.TYPE.FEDAUTH_TOKEN, data);
        this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
      }
      /**
       * @private
       */
      sendInitialSql() {
        const payload = new _sqlbatchPayload.default(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);
        const message = new _message.default({
          type: _packet.TYPE.SQL_BATCH
        });
        this.messageIo.outgoingMessageStream.write(message);
        _stream.Readable.from(payload).pipe(message);
      }
      /**
       * @private
       */
      getInitialSql() {
        const options = [];
        if (this.config.options.enableAnsiNull === true) {
          options.push("set ansi_nulls on");
        } else if (this.config.options.enableAnsiNull === false) {
          options.push("set ansi_nulls off");
        }
        if (this.config.options.enableAnsiNullDefault === true) {
          options.push("set ansi_null_dflt_on on");
        } else if (this.config.options.enableAnsiNullDefault === false) {
          options.push("set ansi_null_dflt_on off");
        }
        if (this.config.options.enableAnsiPadding === true) {
          options.push("set ansi_padding on");
        } else if (this.config.options.enableAnsiPadding === false) {
          options.push("set ansi_padding off");
        }
        if (this.config.options.enableAnsiWarnings === true) {
          options.push("set ansi_warnings on");
        } else if (this.config.options.enableAnsiWarnings === false) {
          options.push("set ansi_warnings off");
        }
        if (this.config.options.enableArithAbort === true) {
          options.push("set arithabort on");
        } else if (this.config.options.enableArithAbort === false) {
          options.push("set arithabort off");
        }
        if (this.config.options.enableConcatNullYieldsNull === true) {
          options.push("set concat_null_yields_null on");
        } else if (this.config.options.enableConcatNullYieldsNull === false) {
          options.push("set concat_null_yields_null off");
        }
        if (this.config.options.enableCursorCloseOnCommit === true) {
          options.push("set cursor_close_on_commit on");
        } else if (this.config.options.enableCursorCloseOnCommit === false) {
          options.push("set cursor_close_on_commit off");
        }
        if (this.config.options.datefirst !== null) {
          options.push(`set datefirst ${this.config.options.datefirst}`);
        }
        if (this.config.options.dateFormat !== null) {
          options.push(`set dateformat ${this.config.options.dateFormat}`);
        }
        if (this.config.options.enableImplicitTransactions === true) {
          options.push("set implicit_transactions on");
        } else if (this.config.options.enableImplicitTransactions === false) {
          options.push("set implicit_transactions off");
        }
        if (this.config.options.language !== null) {
          options.push(`set language ${this.config.options.language}`);
        }
        if (this.config.options.enableNumericRoundabort === true) {
          options.push("set numeric_roundabort on");
        } else if (this.config.options.enableNumericRoundabort === false) {
          options.push("set numeric_roundabort off");
        }
        if (this.config.options.enableQuotedIdentifier === true) {
          options.push("set quoted_identifier on");
        } else if (this.config.options.enableQuotedIdentifier === false) {
          options.push("set quoted_identifier off");
        }
        if (this.config.options.textsize !== null) {
          options.push(`set textsize ${this.config.options.textsize}`);
        }
        if (this.config.options.connectionIsolationLevel !== null) {
          options.push(`set transaction isolation level ${this.getIsolationLevelText(this.config.options.connectionIsolationLevel)}`);
        }
        if (this.config.options.abortTransactionOnError === true) {
          options.push("set xact_abort on");
        } else if (this.config.options.abortTransactionOnError === false) {
          options.push("set xact_abort off");
        }
        return options.join("\n");
      }
      /**
       * @private
       */
      processedInitialSql() {
        this.clearConnectTimer();
        this.emit("connect");
      }
      /**
       * Execute the SQL batch represented by [[Request]].
       * There is no param support, and unlike [[Request.execSql]],
       * it is not likely that SQL Server will reuse the execution plan it generates for the SQL.
       *
       * In almost all cases, [[Request.execSql]] will be a better choice.
       *
       * @param request A [[Request]] object representing the request.
       */
      execSqlBatch(request) {
        this.makeRequest(request, _packet.TYPE.SQL_BATCH, new _sqlbatchPayload.default(request.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));
      }
      /**
       *  Execute the SQL represented by [[Request]].
       *
       * As `sp_executesql` is used to execute the SQL, if the same SQL is executed multiples times
       * using this function, the SQL Server query optimizer is likely to reuse the execution plan it generates
       * for the first execution. This may also result in SQL server treating the request like a stored procedure
       * which can result in the [[Event_doneInProc]] or [[Event_doneProc]] events being emitted instead of the
       * [[Event_done]] event you might expect. Using [[execSqlBatch]] will prevent this from occurring but may have a negative performance impact.
       *
       * Beware of the way that scoping rules apply, and how they may [affect local temp tables](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)
       * If you're running in to scoping issues, then [[execSqlBatch]] may be a better choice.
       * See also [issue #24](https://github.com/pekim/tedious/issues/24)
       *
       * @param request A [[Request]] object representing the request.
       */
      execSql(request) {
        try {
          request.validateParameters(this.databaseCollation);
        } catch (error) {
          request.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request.callback(error);
          });
          return;
        }
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "statement",
          value: request.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        if (request.parameters.length) {
          parameters.push({
            type: _dataType.TYPES.NVarChar,
            name: "params",
            value: request.makeParamsParameter(request.parameters),
            output: false,
            length: void 0,
            precision: void 0,
            scale: void 0
          });
          parameters.push(...request.parameters);
        }
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_ExecuteSql, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Creates a new BulkLoad instance.
       *
       * @param table The name of the table to bulk-insert into.
       * @param options A set of bulk load options.
       */
      newBulkLoad(table, callbackOrOptions, callback) {
        let options;
        if (callback === void 0) {
          callback = callbackOrOptions;
          options = {};
        } else {
          options = callbackOrOptions;
        }
        if (typeof options !== "object") {
          throw new TypeError('"options" argument must be an object');
        }
        return new _bulkLoad.default(table, this.databaseCollation, this.config.options, options, callback);
      }
      /**
       * Execute a [[BulkLoad]].
       *
       * ```js
       * // We want to perform a bulk load into a table with the following format:
       * // CREATE TABLE employees (first_name nvarchar(255), last_name nvarchar(255), day_of_birth date);
       *
       * const bulkLoad = connection.newBulkLoad('employees', (err, rowCount) => {
       *   // ...
       * });
       *
       * // First, we need to specify the columns that we want to write to,
       * // and their definitions. These definitions must match the actual table,
       * // otherwise the bulk load will fail.
       * bulkLoad.addColumn('first_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('last_name', TYPES.NVarchar, { nullable: false });
       * bulkLoad.addColumn('date_of_birth', TYPES.Date, { nullable: false });
       *
       * // Execute a bulk load with a predefined list of rows.
       * //
       * // Note that these rows are held in memory until the
       * // bulk load was performed, so if you need to write a large
       * // number of rows (e.g. by reading from a CSV file),
       * // passing an `AsyncIterable` is advisable to keep memory usage low.
       * connection.execBulkLoad(bulkLoad, [
       *   { 'first_name': 'Steve', 'last_name': 'Jobs', 'day_of_birth': new Date('02-24-1955') },
       *   { 'first_name': 'Bill', 'last_name': 'Gates', 'day_of_birth': new Date('10-28-1955') }
       * ]);
       * ```
       *
       * @param bulkLoad A previously created [[BulkLoad]].
       * @param rows A [[Iterable]] or [[AsyncIterable]] that contains the rows that should be bulk loaded.
       */
      execBulkLoad(bulkLoad, rows) {
        bulkLoad.executionStarted = true;
        if (rows) {
          if (bulkLoad.streamingMode) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that was put in streaming mode.");
          }
          if (bulkLoad.firstRowWritten) {
            throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that already has rows written to it.");
          }
          const rowStream = _stream.Readable.from(rows);
          rowStream.on("error", (err) => {
            bulkLoad.rowToPacketTransform.destroy(err);
          });
          bulkLoad.rowToPacketTransform.on("error", (err) => {
            rowStream.destroy(err);
          });
          rowStream.pipe(bulkLoad.rowToPacketTransform);
        } else if (!bulkLoad.streamingMode) {
          bulkLoad.rowToPacketTransform.end();
        }
        const onCancel = () => {
          request.cancel();
        };
        const payload = new _bulkLoadPayload.BulkLoadPayload(bulkLoad);
        const request = new _request.default(bulkLoad.getBulkInsertSql(), (error) => {
          bulkLoad.removeListener("cancel", onCancel);
          if (error) {
            if (error.code === "UNKNOWN") {
              error.message += " This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.";
            }
            bulkLoad.error = error;
            bulkLoad.callback(error);
            return;
          }
          this.makeRequest(bulkLoad, _packet.TYPE.BULK_LOAD, payload);
        });
        bulkLoad.once("cancel", onCancel);
        this.execSqlBatch(request);
      }
      /**
       * Prepare the SQL represented by the request.
       *
       * The request can then be used in subsequent calls to
       * [[execute]] and [[unprepare]]
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type. Parameter values are ignored.
       */
      prepare(request) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          value: void 0,
          output: true,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "params",
          value: request.parameters.length ? request.makeParamsParameter(request.parameters) : null,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        parameters.push({
          type: _dataType.TYPES.NVarChar,
          name: "stmt",
          value: request.sqlTextOrProcedure,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        request.preparing = true;
        request.on("returnValue", (name2, value) => {
          if (name2 === "handle") {
            request.handle = value;
          } else {
            request.error = new _errors.RequestError(`Tedious > Unexpected output parameter ${name2} from sp_prepare`);
          }
        });
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Prepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Release the SQL Server resources associated with a previously prepared request.
       *
       * @param request A [[Request]] object representing the request.
       *   Parameters only require a name and type.
       *   Parameter values are ignored.
       */
      unprepare(request) {
        const parameters = [];
        parameters.push({
          type: _dataType.TYPES.Int,
          name: "handle",
          // TODO: Abort if `request.handle` is not set
          value: request.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Unprepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Execute previously prepared SQL, using the supplied parameters.
       *
       * @param request A previously prepared [[Request]].
       * @param parameters  An object whose names correspond to the names of
       *   parameters that were added to the [[Request]] before it was prepared.
       *   The object's values are passed as the parameters' values when the
       *   request is executed.
       */
      execute(request, parameters) {
        const executeParameters = [];
        executeParameters.push({
          type: _dataType.TYPES.Int,
          name: "",
          // TODO: Abort if `request.handle` is not set
          value: request.handle,
          output: false,
          length: void 0,
          precision: void 0,
          scale: void 0
        });
        try {
          for (let i = 0, len = request.parameters.length; i < len; i++) {
            const parameter = request.parameters[i];
            executeParameters.push({
              ...parameter,
              value: parameter.type.validate(parameters ? parameters[parameter.name] : null, this.databaseCollation)
            });
          }
        } catch (error) {
          request.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request.callback(error);
          });
          return;
        }
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Execute, executeParameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Call a stored procedure represented by [[Request]].
       *
       * @param request A [[Request]] object representing the request.
       */
      callProcedure(request) {
        try {
          request.validateParameters(this.databaseCollation);
        } catch (error) {
          request.error = error;
          process.nextTick(() => {
            this.debug.log(error.message);
            request.callback(error);
          });
          return;
        }
        this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request.sqlTextOrProcedure, request.parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
      }
      /**
       * Start a transaction.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`
       *   is present.
       * @param isolationLevel The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      beginTransaction(callback, name2 = "", isolationLevel = this.config.options.isolationLevel) {
        (0, _transaction.assertValidIsolationLevel)(isolationLevel, "isolationLevel");
        const transaction = new _transaction.Transaction(name2, isolationLevel);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SET TRANSACTION ISOLATION LEVEL " + transaction.isolationLevelToTSQL() + ";BEGIN TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            if (this.transactionDepth === 1) {
              this.inTransaction = true;
            }
            callback(err);
          }));
        }
        const request = new _request.default(void 0, (err) => {
          return callback(err, this.currentTransactionDescriptor());
        });
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Commit a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string. Required when `isolationLevel`is present.
       */
      commitTransaction(callback, name2 = "") {
        const transaction = new _transaction.Transaction(name2);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("COMMIT TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request = new _request.default(void 0, callback);
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Rollback a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      rollbackTransaction(callback, name2 = "") {
        const transaction = new _transaction.Transaction(name2);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("ROLLBACK TRAN " + transaction.name, (err) => {
            this.transactionDepth--;
            if (this.transactionDepth === 0) {
              this.inTransaction = false;
            }
            callback(err);
          }));
        }
        const request = new _request.default(void 0, callback);
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));
      }
      /**
       * Set a savepoint within a transaction.
       *
       * There should be an active transaction - that is, [[beginTransaction]]
       * should have been previously called.
       *
       * @param callback
       * @param name A string representing a name to associate with the transaction.\
       *   Optional, and defaults to an empty string.
       *   Required when `isolationLevel` is present.
       */
      saveTransaction(callback, name2) {
        const transaction = new _transaction.Transaction(name2);
        if (this.config.options.tdsVersion < "7_2") {
          return this.execSqlBatch(new _request.default("SAVE TRAN " + transaction.name, (err) => {
            this.transactionDepth++;
            callback(err);
          }));
        }
        const request = new _request.default(void 0, callback);
        return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));
      }
      /**
       * Run the given callback after starting a transaction, and commit or
       * rollback the transaction afterwards.
       *
       * This is a helper that employs [[beginTransaction]], [[commitTransaction]],
       * [[rollbackTransaction]], and [[saveTransaction]] to greatly simplify the
       * use of database transactions and automatically handle transaction nesting.
       *
       * @param cb
       * @param isolationLevel
       *   The isolation level that the transaction is to be run with.
       *
       *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
       *   * `READ_UNCOMMITTED`
       *   * `READ_COMMITTED`
       *   * `REPEATABLE_READ`
       *   * `SERIALIZABLE`
       *   * `SNAPSHOT`
       *
       *   Optional, and defaults to the Connection's isolation level.
       */
      transaction(cb, isolationLevel) {
        if (typeof cb !== "function") {
          throw new TypeError("`cb` must be a function");
        }
        const useSavepoint = this.inTransaction;
        const name2 = "_tedious_" + _crypto.default.randomBytes(10).toString("hex");
        const txDone = (err, done, ...args) => {
          if (err) {
            if (this.inTransaction && this.state === this.STATE.LOGGED_IN) {
              this.rollbackTransaction((txErr) => {
                done(txErr || err, ...args);
              }, name2);
            } else {
              done(err, ...args);
            }
          } else if (useSavepoint) {
            if (this.config.options.tdsVersion < "7_2") {
              this.transactionDepth--;
            }
            done(null, ...args);
          } else {
            this.commitTransaction((txErr) => {
              done(txErr, ...args);
            }, name2);
          }
        };
        if (useSavepoint) {
          return this.saveTransaction((err) => {
            if (err) {
              return cb(err);
            }
            if (isolationLevel) {
              return this.execSqlBatch(new _request.default("SET transaction isolation level " + this.getIsolationLevelText(isolationLevel), (err2) => {
                return cb(err2, txDone);
              }));
            } else {
              return cb(null, txDone);
            }
          }, name2);
        } else {
          return this.beginTransaction((err) => {
            if (err) {
              return cb(err);
            }
            return cb(null, txDone);
          }, name2, isolationLevel);
        }
      }
      /**
       * @private
       */
      makeRequest(request, packetType, payload) {
        if (this.state !== this.STATE.LOGGED_IN) {
          const message = "Requests can only be made in the " + this.STATE.LOGGED_IN.name + " state, not the " + this.state.name + " state";
          this.debug.log(message);
          request.callback(new _errors.RequestError(message, "EINVALIDSTATE"));
        } else if (request.canceled) {
          process.nextTick(() => {
            request.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
          });
        } else {
          if (packetType === _packet.TYPE.SQL_BATCH) {
            this.isSqlBatch = true;
          } else {
            this.isSqlBatch = false;
          }
          this.request = request;
          request.connection = this;
          request.rowCount = 0;
          request.rows = [];
          request.rst = [];
          const onCancel = () => {
            payloadStream.unpipe(message);
            payloadStream.destroy(new _errors.RequestError("Canceled.", "ECANCEL"));
            message.ignore = true;
            message.end();
            if (request instanceof _request.default && request.paused) {
              request.resume();
            }
          };
          request.once("cancel", onCancel);
          this.createRequestTimer();
          const message = new _message.default({
            type: packetType,
            resetConnection: this.resetConnectionOnNextRequest
          });
          this.messageIo.outgoingMessageStream.write(message);
          this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);
          message.once("finish", () => {
            request.removeListener("cancel", onCancel);
            request.once("cancel", this._cancelAfterRequestSent);
            this.resetConnectionOnNextRequest = false;
            this.debug.payload(function() {
              return payload.toString("  ");
            });
          });
          const payloadStream = _stream.Readable.from(payload);
          payloadStream.once("error", (error) => {
            payloadStream.unpipe(message);
            request.error ?? (request.error = error);
            message.ignore = true;
            message.end();
          });
          payloadStream.pipe(message);
        }
      }
      /**
       * Cancel currently executed request.
       */
      cancel() {
        if (!this.request) {
          return false;
        }
        if (this.request.canceled) {
          return false;
        }
        this.request.cancel();
        return true;
      }
      /**
       * Reset the connection to its initial state.
       * Can be useful for connection pool implementations.
       *
       * @param callback
       */
      reset(callback) {
        const request = new _request.default(this.getInitialSql(), (err) => {
          if (this.config.options.tdsVersion < "7_2") {
            this.inTransaction = false;
          }
          callback(err);
        });
        this.resetConnectionOnNextRequest = true;
        this.execSqlBatch(request);
      }
      /**
       * @private
       */
      currentTransactionDescriptor() {
        return this.transactionDescriptors[this.transactionDescriptors.length - 1];
      }
      /**
       * @private
       */
      getIsolationLevelText(isolationLevel) {
        switch (isolationLevel) {
          case _transaction.ISOLATION_LEVEL.READ_UNCOMMITTED:
            return "read uncommitted";
          case _transaction.ISOLATION_LEVEL.REPEATABLE_READ:
            return "repeatable read";
          case _transaction.ISOLATION_LEVEL.SERIALIZABLE:
            return "serializable";
          case _transaction.ISOLATION_LEVEL.SNAPSHOT:
            return "snapshot";
          default:
            return "read committed";
        }
      }
    };
    function isTransientError(error) {
      if (error instanceof AggregateError) {
        error = error.errors[0];
      }
      return error instanceof _errors.ConnectionError && !!error.isTransient;
    }
    var _default = exports.default = Connection;
    module.exports = Connection;
    Connection.prototype.STATE = {
      INITIALIZED: {
        name: "Initialized",
        events: {}
      },
      CONNECTING: {
        name: "Connecting",
        enter: function() {
          this.initialiseConnection();
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_PRELOGIN: {
        name: "SentPrelogin",
        enter: function() {
          (async () => {
            var _a3;
            let messageBuffer = Buffer.alloc(0);
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            for await (const data of message) {
              messageBuffer = Buffer.concat([messageBuffer, data]);
            }
            const preloginPayload = new _preloginPayload.default(messageBuffer);
            this.debug.payload(function() {
              return preloginPayload.toString("  ");
            });
            if (preloginPayload.fedAuthRequired === 1) {
              this.fedAuthRequired = true;
            }
            if ("strict" !== this.config.options.encrypt && (preloginPayload.encryptionString === "ON" || preloginPayload.encryptionString === "REQ")) {
              if (!this.config.options.encrypt) {
                this.emit("connect", new _errors.ConnectionError("Server requires encryption, set 'encrypt' config option to true.", "EENCRYPT"));
                return this.close();
              }
              try {
                this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);
                await this.messageIo.startTls(this.secureContextOptions, this.config.options.serverName ? this.config.options.serverName : ((_a3 = this.routingData) == null ? void 0 : _a3.server) ?? this.config.server, this.config.options.trustServerCertificate);
              } catch (err) {
                return this.socketError(err);
              }
            }
            this.sendLogin7Packet();
            const {
              authentication
            } = this.config;
            switch (authentication.type) {
              case "azure-active-directory-password":
              case "azure-active-directory-msi-vm":
              case "azure-active-directory-msi-app-service":
              case "azure-active-directory-service-principal-secret":
              case "azure-active-directory-default":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_FEDAUTH);
                break;
              case "ntlm":
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);
                break;
              default:
                this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
                break;
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      REROUTING: {
        name: "ReRouting",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.REDIRECT);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          reconnect: function() {
            this.transitionTo(this.STATE.CONNECTING);
          }
        }
      },
      TRANSIENT_FAILURE_RETRY: {
        name: "TRANSIENT_FAILURE_RETRY",
        enter: function() {
          this.curTransientRetryCount++;
          this.cleanupConnection(CLEANUP_TYPE.RETRY);
        },
        events: {
          message: function() {
          },
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          retry: function() {
            this.createRetryTimer();
          }
        }
      },
      SENT_TLSSSLNEGOTIATION: {
        name: "SentTLSSSLNegotiation",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_STANDARD_LOGIN: {
        name: "SentLogin7WithStandardLogin",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_NTLM: {
        name: "SentLogin7WithNTLMLogin",
        enter: function() {
          (async () => {
            while (true) {
              let message;
              try {
                message = await this.messageIo.readMessage();
              } catch (err) {
                return this.socketError(err);
              }
              const handler = new _handler.Login7TokenHandler(this);
              const tokenStreamParser = this.createTokenStreamParser(message, handler);
              await (0, _events.once)(tokenStreamParser, "end");
              if (handler.loginAckReceived) {
                if (handler.routingData) {
                  this.routingData = handler.routingData;
                  return this.transitionTo(this.STATE.REROUTING);
                } else {
                  return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
                }
              } else if (this.ntlmpacket) {
                const authentication = this.config.authentication;
                const payload = new _ntlmPayload.default({
                  domain: authentication.options.domain,
                  userName: authentication.options.userName,
                  password: authentication.options.password,
                  ntlmpacket: this.ntlmpacket
                });
                this.messageIo.sendMessage(_packet.TYPE.NTLMAUTH_PKT, payload.data);
                this.debug.payload(function() {
                  return payload.toString("  ");
                });
                this.ntlmpacket = void 0;
              } else if (this.loginError) {
                if (isTransientError(this.loginError)) {
                  this.debug.log("Initiating retry on transient error");
                  return this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
                } else {
                  this.emit("connect", this.loginError);
                  return this.transitionTo(this.STATE.FINAL);
                }
              } else {
                this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
                return this.transitionTo(this.STATE.FINAL);
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_LOGIN7_WITH_FEDAUTH: {
        name: "SentLogin7Withfedauth",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.Login7TokenHandler(this);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.loginAckReceived) {
              if (handler.routingData) {
                this.routingData = handler.routingData;
                this.transitionTo(this.STATE.REROUTING);
              } else {
                this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
              }
              return;
            }
            const fedAuthInfoToken = handler.fedAuthInfoToken;
            if (fedAuthInfoToken && fedAuthInfoToken.stsurl && fedAuthInfoToken.spn) {
              const authentication = this.config.authentication;
              const tokenScope = new _url.URL("/.default", fedAuthInfoToken.spn).toString();
              let credentials;
              switch (authentication.type) {
                case "azure-active-directory-password":
                  credentials = new _identity.UsernamePasswordCredential(authentication.options.tenantId ?? "common", authentication.options.clientId, authentication.options.userName, authentication.options.password);
                  break;
                case "azure-active-directory-msi-vm":
                case "azure-active-directory-msi-app-service":
                  const msiArgs = authentication.options.clientId ? [authentication.options.clientId, {}] : [{}];
                  credentials = new _identity.ManagedIdentityCredential(...msiArgs);
                  break;
                case "azure-active-directory-default":
                  const args = authentication.options.clientId ? {
                    managedIdentityClientId: authentication.options.clientId
                  } : {};
                  credentials = new _identity.DefaultAzureCredential(args);
                  break;
                case "azure-active-directory-service-principal-secret":
                  credentials = new _identity.ClientSecretCredential(authentication.options.tenantId, authentication.options.clientId, authentication.options.clientSecret);
                  break;
              }
              let tokenResponse;
              try {
                tokenResponse = await credentials.getToken(tokenScope);
              } catch (err) {
                this.loginError = new AggregateError([new _errors.ConnectionError("Security token could not be authenticated or authorized.", "EFEDAUTH"), err]);
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
                return;
              }
              const token = tokenResponse.token;
              this.sendFedAuthTokenMessage(token);
            } else if (this.loginError) {
              if (isTransientError(this.loginError)) {
                this.debug.log("Initiating retry on transient error");
                this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
              } else {
                this.emit("connect", this.loginError);
                this.transitionTo(this.STATE.FINAL);
              }
            } else {
              this.emit("connect", new _errors.ConnectionError("Login failed.", "ELOGIN"));
              this.transitionTo(this.STATE.FINAL);
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN_SENDING_INITIAL_SQL: {
        name: "LoggedInSendingInitialSql",
        enter: function() {
          (async () => {
            this.sendInitialSql();
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.InitialSqlTokenHandler(this));
            await (0, _events.once)(tokenStreamParser, "end");
            this.transitionTo(this.STATE.LOGGED_IN);
            this.processedInitialSql();
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function socketError() {
            this.transitionTo(this.STATE.FINAL);
          },
          connectTimeout: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      LOGGED_IN: {
        name: "LoggedIn",
        events: {
          socketError: function() {
            this.transitionTo(this.STATE.FINAL);
          }
        }
      },
      SENT_CLIENT_REQUEST: {
        name: "SentClientRequest",
        enter: function() {
          (async () => {
            var _a3, _b2, _c2;
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            this.clearRequestTimer();
            const tokenStreamParser = this.createTokenStreamParser(message, new _handler.RequestTokenHandler(this, this.request));
            if (((_a3 = this.request) == null ? void 0 : _a3.canceled) && this.cancelTimer) {
              return this.transitionTo(this.STATE.SENT_ATTENTION);
            }
            const onResume = () => {
              tokenStreamParser.resume();
            };
            const onPause = () => {
              var _a4;
              tokenStreamParser.pause();
              (_a4 = this.request) == null ? void 0 : _a4.once("resume", onResume);
            };
            (_b2 = this.request) == null ? void 0 : _b2.on("pause", onPause);
            if (this.request instanceof _request.default && this.request.paused) {
              onPause();
            }
            const onCancel = () => {
              var _a4, _b3;
              tokenStreamParser.removeListener("end", onEndOfMessage);
              if (this.request instanceof _request.default && this.request.paused) {
                this.request.resume();
              }
              (_a4 = this.request) == null ? void 0 : _a4.removeListener("pause", onPause);
              (_b3 = this.request) == null ? void 0 : _b3.removeListener("resume", onResume);
              this.transitionTo(this.STATE.SENT_ATTENTION);
            };
            const onEndOfMessage = () => {
              var _a4, _b3, _c3, _d2;
              (_a4 = this.request) == null ? void 0 : _a4.removeListener("cancel", this._cancelAfterRequestSent);
              (_b3 = this.request) == null ? void 0 : _b3.removeListener("cancel", onCancel);
              (_c3 = this.request) == null ? void 0 : _c3.removeListener("pause", onPause);
              (_d2 = this.request) == null ? void 0 : _d2.removeListener("resume", onResume);
              this.transitionTo(this.STATE.LOGGED_IN);
              const sqlRequest = this.request;
              this.request = void 0;
              if (this.config.options.tdsVersion < "7_2" && sqlRequest.error && this.isSqlBatch) {
                this.inTransaction = false;
              }
              sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);
            };
            tokenStreamParser.once("end", onEndOfMessage);
            (_c2 = this.request) == null ? void 0 : _c2.once("cancel", onCancel);
          })();
        },
        exit: function(nextState) {
          this.clearRequestTimer();
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      SENT_ATTENTION: {
        name: "SentAttention",
        enter: function() {
          (async () => {
            let message;
            try {
              message = await this.messageIo.readMessage();
            } catch (err) {
              return this.socketError(err);
            }
            const handler = new _handler.AttentionTokenHandler(this, this.request);
            const tokenStreamParser = this.createTokenStreamParser(message, handler);
            await (0, _events.once)(tokenStreamParser, "end");
            if (handler.attentionReceived) {
              this.clearCancelTimer();
              const sqlRequest = this.request;
              this.request = void 0;
              this.transitionTo(this.STATE.LOGGED_IN);
              if (sqlRequest.error && sqlRequest.error instanceof _errors.RequestError && sqlRequest.error.code === "ETIMEOUT") {
                sqlRequest.callback(sqlRequest.error);
              } else {
                sqlRequest.callback(new _errors.RequestError("Canceled.", "ECANCEL"));
              }
            }
          })().catch((err) => {
            process.nextTick(() => {
              throw err;
            });
          });
        },
        events: {
          socketError: function(err) {
            const sqlRequest = this.request;
            this.request = void 0;
            this.transitionTo(this.STATE.FINAL);
            sqlRequest.callback(err);
          }
        }
      },
      FINAL: {
        name: "Final",
        enter: function() {
          this.cleanupConnection(CLEANUP_TYPE.NORMAL);
        },
        events: {
          connectTimeout: function() {
          },
          message: function() {
          },
          socketError: function() {
          }
        }
      }
    };
  }
});

// node_modules/tedious/lib/tedious.js
var require_tedious = __commonJS({
  "node_modules/tedious/lib/tedious.js"(exports) {
    init_process();
    init_buffer();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "BulkLoad", {
      enumerable: true,
      get: function() {
        return _bulkLoad.default;
      }
    });
    Object.defineProperty(exports, "Connection", {
      enumerable: true,
      get: function() {
        return _connection.default;
      }
    });
    Object.defineProperty(exports, "ConnectionError", {
      enumerable: true,
      get: function() {
        return _errors.ConnectionError;
      }
    });
    Object.defineProperty(exports, "ISOLATION_LEVEL", {
      enumerable: true,
      get: function() {
        return _transaction.ISOLATION_LEVEL;
      }
    });
    Object.defineProperty(exports, "Request", {
      enumerable: true,
      get: function() {
        return _request.default;
      }
    });
    Object.defineProperty(exports, "RequestError", {
      enumerable: true,
      get: function() {
        return _errors.RequestError;
      }
    });
    Object.defineProperty(exports, "TDS_VERSION", {
      enumerable: true,
      get: function() {
        return _tdsVersions.versions;
      }
    });
    Object.defineProperty(exports, "TYPES", {
      enumerable: true,
      get: function() {
        return _dataType.TYPES;
      }
    });
    exports.connect = connect;
    exports.library = void 0;
    var _bulkLoad = _interopRequireDefault(require_bulk_load());
    var _connection = _interopRequireDefault(require_connection());
    var _request = _interopRequireDefault(require_request());
    var _library = require_library();
    var _errors = require_errors();
    var _dataType = require_data_type();
    var _transaction = require_transaction();
    var _tdsVersions = require_tds_versions();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var library = exports.library = {
      name: _library.name
    };
    function connect(config, connectListener) {
      const connection = new _connection.default(config);
      connection.connect(connectListener);
      return connection;
    }
  }
});
export default require_tedious();
/*! Bundled license information:

@azure/msal-browser/dist/operatingcontext/BaseOperatingContext.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/naa/BridgeProxy.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/operatingcontext/TeamsAppOperatingContext.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/operatingcontext/StandardOperatingContext.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/controllers/ControllerFactory.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/app/PublicClientApplication.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/controllers/UnknownOperatingContextController.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/operatingcontext/UnknownOperatingContext.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/app/PublicClientNext.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/app/IPublicClientApplication.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/event/EventMessage.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/crypto/SignedHttpRequest.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/telemetry/BrowserPerformanceClient.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

@azure/msal-browser/dist/index.mjs:
  (*! @azure/msal-browser v3.13.0 2024-04-11 *)

js-md4/src/md4.js:
  (**
   * [js-md4]{@link https://github.com/emn178/js-md4}
   *
   * @namespace md4
   * @version 0.3.2
   * @author Yi-Cyuan Chen [emn178@gmail.com]
   * @copyright Yi-Cyuan Chen 2015-2027
   * @license MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@js-joda/core/dist/js-joda.esm.js:
  (*! @version @js-joda/core - 5.6.2 *)
  (*! @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors *)
  (*! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos *)
  (*! @license BSD-3-Clause (see LICENSE in the root directory of this source tree) *)
  (**
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (**
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2016, Philipp Thrwchter, Pattrick Hper
   * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
  (*
   * @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors
   * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
   *)
*/
//# sourceMappingURL=tedious.js.map
